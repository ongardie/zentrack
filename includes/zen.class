<?

include_once("$libDir/zenDate.class");  
  
class zen extends zenDate {
 
   // this class includes basic formatting functions
   // and utilities used by the various pages.
   // it also extends the zenDate class to pull those
   // functions into use for the rest of zenTrack.
   
   /*
   **  TEXT FORMATTING
   */
   
   function titleCase( $text = '' ) {
      /*
      ** The title case function converts the string to a title ready
      ** format by capitalizing all words, excepting those 
      ** found in lcwords, and converting all words found in ucwords to
      ** all upper case
      */
      if( strlen($text) ) {
	 $text = ucwords(strtolower($text));
	 foreach($this->getFileArray($this->listDir."/lists/lcwords") as $l) {
	    $l = trim($l);
	    $lu = ucfirst($l);
	    $text = ereg_replace(" $lu\b", " $l", $text);
	 }
	 foreach($this->getFileArray($this->listDir."/lists/ucwords") as $u) {
	    $u = trim($u);
	    $text = eregi_replace("\b$u\b", "$u", $text);
	 }
	 if( eregi("^([^a-zA-Z]*[a-z])", $text, $matches) ) {
	    $text = ereg_replace("^([^a-zA-Z]*[a-z])", strtoupper($matches[1]), $text);
	 }
	 return $text;
      }
   }

   function ffv( $val = '' ) {
     // converts special characters to ascii codes
     // to be used in <input> fields
     if( strlen($val) ) {
       $val = htmlspecialchars($val,ENT_QUOTES);
     }
     return $val;
   }

   function checkAlpha( $val = '', $special = '_' ) {
     // strips all chars not in a-z, A-Z and $special
     if( !strlen($val) )
       return '';
     return preg_replace("@[^a-zA-Z$special]@", "", $val);
   }

   function checkAlphaNum( $val = '', $special = '_' ) {
     // strips all non a-z, A-Z, 0-9 and chars in $special
     // from the entry
     if( !strlen($val) )
       return '';
     return preg_replace("@[^a-zA-Z0-9$special]@", "", $val);
   }
   
   function checkNum( $val = 0, $decimal=false ) {
     // converts values to integer or 
     // decimal if $decimal == true;
     if( !strlen($val) ) {
       return 0;
     }     
     return( ($decimal)? 
	     preg_replace("@[^0-9.]@", "", $val) :
	     preg_replace("@[^0-9]@", "", $val) );
   }
   
   function stripPHP( $val = '' ) {
     // replaces php tags with ascii code
      if( strlen($val) )
	return ereg_replace("<\?", "&lt;?", ereg_replace("\?>", "?&gt;", $val));
   }
   
   function getFileArray( $file, $delim = '', $index = '', $combined = 0 ) {
      // makes an array from a file, each line of the file is one line in the array
      // if $delim is given, then each row of data is split on that expression and 
      // made into a sub-array if $index is set to an integer, then that number of 
      // the sub-array is assigned as the index of the sub-array
      // if $combined is set to 1, then the array is constructed with multiple rows
      // under each index id (rather than overwriting if there is a duplicate)
      if( file_exists($file) ) {
	 $vals = $this->cleanText(file($file));
	 if( is_array($vals) ) {
	    foreach($vals as $v) {
	       if( strlen($v) && !ereg("^#", $v) ) {
		  if( strlen($delim) ) {
		     $vals = explode($delim,$v);
		     if( strlen($index) ) {
			list($n) = array_splice($vals,$index,1);
			if( $combined ) {
			   $arr["$n"][] = $vals;
			} else {
			   $arr["$n"] = $vals;
			}
		     } else {
			$arr[] = $vals;       
		     }
		  } else {
		     $arr[] = $v;
		  }
	       }
	    }
	 }
	 return $arr;
      }
   }
   
   function cleanText( $text = '' ) {   
      /*
      ** The clean text method creates an array out of a multi-line file
      ** by splitting the contents on the carriage returns, and strips
      ** any extraneous carriage return chars from the file
      */
      
      $contents = (is_array($text))? $text : explode("\n", $text);
      for( $i=0; $i<count($contents); $i++ ) {
	 $contents[$i] = ereg_replace(chr(13), "", $contents[$i]);
	 $contents[$i] = ereg_replace(chr(14), "", $contents[$i]);
	 $contents[$i] = ereg_replace(chr(10), "", $contents[$i]);
	 $contents[$i] = trim($contents[$i]);
      }
      return $contents;
   }

   function highlight( $text, $match, $h = '' ) {
     /*
     ** The highlight function searches for matches and highlights them
     ** using the two values of array $h as opening and closing tags
     **    Example:
     **       $text = 'some goats ran';
     **       $match = 'goats';
     **       $h = array('<b>','</b>');
     **    Result:
     **       'some <b>goats</b> ran'
     **
     **  text  - full text
     **  match - words/expressions to highlight
     **  h     - [optional,default is <b></b>] array containing the pre 
     **          and post tags to use for highlighting
     */

     if( !is_array($h) )
        $h = $this->defaultHighlight;
     if( !is_array($text) ) {
       $join = 1;
       $text = array($text);
     }
     if( !is_array($match) )
        $match = array($match);
     for( $i=0; $i<count($text); $i++ ) {
       foreach($match as $m) {
	 $text[$i] = ereg_replace('#','\#',$text[$i]);
         $text[$i] = preg_replace("#($m)#i", "$h[0]\\1$h[1]", $text[$i]);
       }
     }
     if( $join ) {
       return($text[0]);
     } else {
       return($text);
     }
   }

   /*
   **  FORM UTILITIES
   */

   function cleanInput( $fields = '', $vals = '' ) {
     /*
     **  Formats incoming data from forms
     **
     **  There are several ways to call this function:
     **    
     **    With with only $vals -- strips html excepting html_allowed from $vals and returns array
     **    With $fields & $vals -- formats $vals as specified in $fields(both indexed arrays) 
     **                            and returns array
     **    With only $fields -- pulls variables listed in $fields by reference, formats 
     **                         (using global attribute) and returns nothing
     **
     **  There are several values for the indexed array 'fields' which can be used
     **
     **	   case "alpha":     letters only
     **    case "alphanum":  letters and numbers only
     **    case "string":    letters, numbers and spaces only
     **    case "num":       numbers and decimal symbols only
     **    case "int":       numbers only
     **	   case "date":      date chars format only
     **	   case "html":      all but php tags allowed
     **	   case "text":      strip all html
     **	   case "ignore":    leave this fields alone
     **    case "email":     email format
     **    case "array":     also ignored
     **	   case "":          strip all html excepting $mda->html_allowed (determined by lists/okhtmltags)
     **
     */

      if( is_array($vals) ) {
	$vars = $vals;
	$vals = array();
	foreach($vars as $k=>$v ) {
	  if( is_array($fields) ) {
	    $f = $fields["$k"];
	  } else if( $fields ) {
	    $f = $fields;
	  }
	  if( !$k ) {
	    $vals[] = strip_tags( $v, $this->html_allowed );
	  } else if( !$f ) {
	    $vals["$k"] = strip_tags( $v, $this->html_allowed );
	  } else {
	    switch( $f ) {
	    case "alpha":
	      $vals["$k"] = $this->checkAlpha($v);
	      break;
	    case "alphanum":
	      $vals["$k"] = $this->checkAlphaNum($v);
	      break;	   
	    case "array":
	      $vals["$k"] = (is_array($v))? $v : array();
	      break;		  
	    case "date":
	      $vals["$k"] = ereg_replace("[^0-9/: -]", "", $v);
	      break;
	    case "email":
	      $vals["$k"] = ereg_replace("[^0-9a-zA-Z@._-]", "", $v);
	      break;		  		  
	    case "html": 
	      $vals["$k"] = $this->stripPHP( $v );
	      break;
	    case "int":
	      $vals["$k"] = $this->checkNum($v);
	      break;		  
	    case "ignore":
	      $vals["$k"] = $v;
	      break;
	    case "num":
	      $vals["$k"] = $this->checkNum($v,true);
	      break;
	    case "string":
	      $vals["$k"] = $this->checkAlphaNum($v," _-");
	      break;
	    case "text":
	      $vals["$k"] = htmlspecialchars($v);
	      break;
	    default:
	      $vals["$k"] = strip_tags($v, $this->html_allowed);
	    }
	  }       
	}
	return $vals;
      } else {
	 foreach( $fields as $k=>$v ) {
	    global $$k;
	    switch( strtolower($v) ) {
	      case "alpha":
	       $$k = $this->checkAlpha($$k);
	       break;
	      case "alphanum":
	       $$k = $this->checkAlphaNum($$k);
	       break;	   
	      case "array":
	       $$k = (is_array($$k))? $$k : null;
	       break;		  
	      case "date":
	       $$k = ereg_replace("[^0-9/: -]", "", $$k);
	       break;
	      case "email":
	       $$k = ereg_replace("[^0-9a-zA-Z@._-]", "", $$k);
	       break;		  		  
	      case "html": 
	       $$k = $this->stripPHP( $$k );
	       break;
	      case "int":
	       $$k = $this->checkNum($$k);
	       break;		  
	      case "ignore":
	       $$k = $$k;
	       break;
	      case "num":
	       $$k = $this->checkNum($$k,true);
	       break;
	      case "string":
	       $$k = $this->checkAlphaNum($$k," _-");
	       break;
	      case "text":
	       $$k = htmlspecialchars($$k);
	       break;
	      default:
	       $$k = strip_tags($$k, $this->html_allowed);
	    }	 
	 }
      }
   }

   function hiddenField( $name, $value = '' ) {
     // there are 4 possibilities for this function
     // option 1: $name is string, $value is string
     //     one hidden tag created for this
     // option 2: $name is array, $value = ""
     //     name is expected to be an indexed array
     //     containing array("name"=>"value",...)
     //     one hidden tag created for each name/value pair
     // option 3: $name is array, $value is array
     //     each element of $name matched to $value
     //     arrays must be equal length
     // option 4: $name is string, $value is array
     //     $name is the name of an array that is to
     //     be submitted, and $value contains the values
     //     <... name='name_string[]' value='value_1'...>, etc
     // option 5: $name is an array, $value is a string
     //     $name is a list of names, and $value is to
     //     be assigned to all of them
     // this function checks the data for funky symbols, etc
     // before displaying

     if( is_array($name) && !strlen($value) ) {
       // show each name=>value pair
       foreach($name as $k=>$v) {
	 print "<input type=\"hidden\" name=\"".$this->ffv($k)
	   ."\" value=\"".$this->ffv($v)."\">\n";
       }
     } else if( is_array($name) && is_array($value) ) {
       // show each matching pair
       for($i=0; $i<count($name); $i++) {
	 print "<input type=\"hidden\" name=\"".$this->ffv($name[$i])
	   ." value=\"".$this->ffv($value[$i])."\">\n";	 
       }
     } else if( is_array($name) ) {
       // show same value for all of $name
       $value = $this->ffv($value);
       for($i=0; $i<count($name); $i++) {
	 print "<input type=\"hidden\" name=\""
	       .$this->ffv($name[$i])."\" value=\"".$value."\">\n";	 
       }
     } else if( is_array($value) ) {
       // make an array set
       $name = $this->ffv($name);
       for($i=0; $i<count($value); $i++) {
	 print "<input type=\"hidden\" name=\"".$name."[".$i."]\" value=\""
               .$this->ffv($value[$i])."\">\n";	 
       }
     } else {
       print "<input type=\"hidden\" name=\"".$this->ffv($name)
	 ."\" value=\"".$this->ffv($value)."\">\n";
     }
   }

   /*
   **  UTILITIES
   */   
   
   function encval( $text ) {
      // creates an encrypted value suitable
      // for passphrase use
      // abstracted to prevent problems
      // with future versions
      return( md5($text) );
   }

   function setOffsetImages( $left, $right ) {
     // replaces the images used for createOffsetLinks()
     // method.  These should be arrays containing the following:
     // ( "valid url", "image width", "image height" )

     $this->leftOffsetImage = $left;
     $this->rightOffsetImage = $right;
   }

   function createOffsetLinks( $current, $step, $total, $more = '' ) {
     // return 4 links for offsetting
     // they are: ( start, left, text, right )
     // corresponding to "<<<<", "<<previous", "x of n", and "next>>"
     // if $more is given, then it will be added onto the query string
     // for the links (i.e. "id=20&name=ralph" will add &id=20&name=ralph to the url)
     // example: 10-30 of 50
     // $current corresponds to the offset number, i.e. 10
     // $step corresponds to the number per page, i.e. 20
     // $total corresponds to the total number, i.e. 50

     // find out where we are (for links)
     global $SCRIPT_NAME;
     // make sure links are applicable
     if( $total > $step ) {
       if( $more )
         $more_link = "&$more";
       // set image properties
       $pts = $this->leftOffsetImage;
       $lt = "<img src='$pts[0]' width='$pts[1]' height='$pts[2]' alt='$pts[3]' border='0' hspace='6'>";
       $llt = "<img src='$pts[0]' width='$pts[1]' height='$pts[2]' alt='$pts[3]' border='0'>";
       $prev = $pts[3];
       $pts = $this->rightOffsetImage;
       $gt = "<img src='$pts[0]' width='$pts[1]' height='$pts[2]' alt='$pts[3]' border='0' hspace='6'>";
       $next = $pts[3];
       // determine starting and end points for links
       $next_to = ($current + $step > $total)?
         $total : $current + $step;
       $next_curr = $current + 1;
       // if current > 0, then there is a previous
       if( $current > 0 ) {
         $next_down = ($current - $step > 0)?
           $current - $step : 0;
       }
       // if next_to < total, then there is a next
       if( $next_to < $total ) {
         $next_up = $next_to;
       }
       // if last > 0, then make the 'start' link
       if( $next_down ) {
         $pplink = "<a href='$SCRIPT_NAME?offset=0$more_link'>$llt$llt</a>";
       }
       // if last exists, then make the 'last' link
       if( strlen($next_down) ) {
         $diff = $current - $next_down;
         $plink = "<a href='$SCRIPT_NAME?offset=$next_down$more_link'>$lt$prev $diff</a>";
       }
       // create the text
       $text = "$next_curr-$next_to of $total";
       // if next_up then create the next link
       if( $next_up ) {
         $diff = ($next_up + $step > $total)?
           ($total - $next_up) : $step;
         $nlink = "<a href='$SCRIPT_NAME?offset=$next_up$more_link'>$next $diff$gt</a>";
       }
       // return the links
       return( array($pplink,$plink,$text,$nlink) );
     }
   }
   
   /*
   **  ERROR REPORTING
   */      
   
   function printErrors( $errs = '' ) {
      // prints an array of errors
      // in red, as a formatted list
      if( is_array($errs) ) {
	 print "<span class='red'><b>Errors Detected</b>";
	 print "<br>If problems persist, contact your "
	   ."<a href='{$this->settings['admin_email']}'>Administrator</a>\n<ul>\n";
	 foreach($errs as $e)
	   print "<li>$e</li>\n";
	 print "</ul></span>";
      }
   }
   
   function print_errors( $errs = '' ) {
      // alias to printErrors()
      
      return($this->printErrors($errs));
   }
   
   
   /*
   **  DEBUGGING
   */

   /**
    *  This creates some debugging output to
    *  display errors and messages
    *
    *  @param string $title is the name of the method/page calling addDebug
    *  @param string $msg is the text to display for the debug message
    *  @param integer $lvl 1-error, 2-warning, 3-notice
    */
   function addDebug( $title, $msg, $lvl = 3 ) {
     if( $lvl <= $this->debug )
       $this->debugMessages[] = (is_array($msg))?
	  array($title,$msg,$lvl) :
	  array($title,htmlentities($msg),$lvl);
   }

   /**
    * Prints the debug output collected by addDebug()
    */
   function printDebugMessages() {	
     if( is_array($this->debugMessages) ) {
	$styles = array("","error","","note");
       print "<p>--------<b>DEBUG</b>--------<ul>\n";
       if( is_array($this->debugMessages) ) {	
	 foreach($this->debugMessages as $v) {
	   $n = $v[2];
	   $style = $styles[$n];
	   print "<li class='$style'>$v[0]: \"";
	   if( is_array($v[1]) ) {
	     print "<pre>\n";
	     print_r($v[1]);
	     print "</pre>\n";
	   }
	   else {
	     print $v[1];
	   }
	   print "\"\n";
	 }
       }
       print "</ul>------<b>END DEBUG</b>------</p>\n";
     }
   }
   
   /*
   **  SYSTEM METHODS
   */
   
   
   function zen() {
      $this->zenDate();
   }
   
   /*
   **  VARIABLES
   */ 
   
   var $html_allowed;
   var $debugMessages;
   var $defaultHighlight;
} 
  
?>
