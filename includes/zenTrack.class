<? /* -*- Mode: C; c-basic-indent: 3; indent-tabs-mode: nil -*- ex: set tabstop=3 expandtab: */ 

/* 
**  zenTrack Class
**
**  Author: Kato "phpzen"
**  Description: Ticketing system functions
**  Version: See CVS Repository for version information
**  Created: 02/22/21
**  Email:  postmaster@phpzen.net
**  URL: http://www.phpzen.net
**
**  This is the main class containing all of the functionality for use
**  with the zentrack system.  This class extends zen (basic text formatting
**  and page utilities), zenDate (date manipulations and calculations) and 
**  db.class (database access and retrieval)
*/

include_once("$libDir/zen.class");  

class zenTrack extends zen {


  /*
  **  RETRIEVAL 
  */

  
  function get_access( $user_id, $flag = 0, $withnull = false ) {
    // retrieves the access priviledges
    // by the user_id (user id)
    // if flag set to 1, then it returns
    // a simple array containing all the columns
    //  ( [0] = array(..all columns in db..) )
    // otherwise, returns an array indexed by bin_id, 
    // with a value of the level for that bin
    //  ( ["bin_id"] = $bin_level )
    
    $query = "SELECT * FROM ".$this->table_access." WHERE user_id = $user_id ";
    if( !$withnull ) { $query .= " AND lvl is not null"; }
    $this->addDebug("get_access()Query",$query,3);
    $vars = $this->db_queryIndexed($query);
    if( $flag ) {
      return $vars;  
    } else {
      $bins = $this->getBins();
      for($i=0; $i<count($vars); $i++) {
        $n = $vars[$i]['bin_id'];
        if( isset($bins["$n"]) ) {
          $vals["$n"] = $vars[$i]['lvl'];
        }
      }
      return( $vals );
    }
  }

  function get_attachment($access_id) {
    // retrieves all properties for a given attachment
    // this is by the attachment_id and not the ticket or log ID
    // and creates a file location to the actual 
    // attachment which is stored as ["location"]

    $query = "SELECT * FROM ".$this->table_attachments
      ." WHERE attachment_id = $access_id";
    $vars = $this->db_quickIndexed($query);
    if( is_array($vars) ) {
      $vars["location"] = $this->attachmentsDir."/".$vars["name"];
    }
    return($vars);
  }

  function get_attachments($id, $flag = 0, $indexed = 0) {
    // retrieves all attachements for a given ticket_id
    // indexed by log entry they are associated with
    // if $flag = 1, retrieves by log_id instead of ticket_id
    // if $indexed = 1, then retrieves in a complex array
    // indexed by ticket_id and log_id as follows:
    // $vals["ticket1"]["log1"] = array(datarow)
    // otherwise, returns in a simple, non-indexed array

    $field = ($flag)? "log_id" : "ticket_id";
    $where = (is_array($id))?
      " $field IN(".join(",",$id).")" :
      " $field = $id";
    $query = "SELECT * FROM ".$this->table_attachments
      ." WHERE $where ORDER BY name";
    $vars = $this->db_queryIndexed($query);
    if( $indexed ) {
      for( $i=0; $i<count($vars); $i++ ) {
        $n = $vars[$i]["log_id"];
        $v = $vars[$i]["ticket_id"];
        $vals["$v"]["$n"][] = $vars[$i];
      }
    } else {
      $vals = $vars;
    }
    return($vals);
  }   

  function get_log( $lid ) {
    // returns a specific logs data
    $query = "SELECT * FROM ".$this->table_logs." WHERE lid = $lid";
    return( $this->db_quick($query) );
  }

  function get_logs( $id, $sort = 'created DESC', $limit = '' ) {
    // retrieve log entries for the given ticket id
    // $limit specifies the max number to return      
    $query = "SELECT * FROM ".$this->table_logs." WHERE ticket_id = $id";
    if( $sort )
      $query .= " ORDER BY $sort";
    if( $limit )
      $query .= " LIMIT $limit";
    return( $this->db_queryIndexed($query) );
  }  

  function get_project( $pid, $archive_flag = 0 ) {
    // retrieves all properties from database for given
    // project.  Also returns the following:
    //    children -  an array of tickets that belong to this project 
    //    est_hours - is the estimated time for all tickets associated with 
    //                this project
    //    wkd_hours - is the total hours worked on all tickets for this project
    //    percent_hours - is the percentage completion based on est_ and wkd_
    // if $archive_flag = 1, then will look in archived tickets instead of 
    // active tickets table

    $table = ($archive_flag)? 
      $this->table_tickets_archived : $this->table_tickets;
    $query = "SELECT * FROM $table WHERE id = $pid";
    $vars = $this->db_quickIndexed($query);
    list($vars["est_hours"], $vars["wkd_hours"]) = 
      $this->getProjectHours($pid, $archive_flag);
    $vars["children"] = $this->getProjectChildren($pid, NULL, $archive_flag);
    return($vars);
  }

  function get_projects( $params, $sort = 'priority, otime desc', $archive_flag =0 ) {
    // retrieves a list of projects
    // see get_tickets() for a list of valid params
    // (with the exception of 'type_id' which is set to
    // the id for projects)
    // note that this does not return an accurate result
    // for est_hours and wkd_hours.  Use getProjectHours() 
    // to determine these values
    // if $archive_flag = 1, then retrieves from archive table

    $params["type_id"] = $this->projectTypeID();
    return( $this->get_tickets($params, $sort, NULL, $archive_flag) );
  }

  function get_ticket( $id, $archive_flag = 0 ) {
    // retrieves the properties for a 
    // specific ticket by id
    // use get_project() instead for projects
    // to retreive accurate est_hours and wkd_hours relative
    // to a project and all it's children
    // $archive_flag retrieves tickets from archive db instead
    // of the ticket db

    $table = ($archive_flag)? 
      $this->table_tickets_archived : $this->table_tickets;
    $query = "SELECT * FROM $table WHERE id = $id";
    $vals = $this->db_quickIndexed($query);
    $this->addDebug("get_ticket","result: ".(is_array($vals)?"success":"failed")
                    ."/".$query,3);
    return( $vals );
  }
  
  function getPriorityStyle($priority) {
     // checks settings for priority styles and return the
     // appropriate cell style
     
     if (!$this->settings["color_priority_low"]) {
        return ("cell");
     } else {
        return ("priority$priority");
     }
  }

  /**
   * returns a count of entries concerning this ticket
   * 
   * indexes returned are attachments, logs, tasks, notify, related
   *
   * @param integer $id the id of the ticket
   * @return array indexed array of integers
   */
  function get_ticket_stats( $id ) {
    // if $id is an array, we probably have the ticket, so
    // just use that
    if( is_array($id) ) {
      $t = $id;
      $id = $t["id"];
    }
    else {
      $t = $this->get_ticket($id);
    }
    $vals = array();
    // get attachments
    $query = "SELECT count(*) FROM ".$this->table_attachments
      ." WHERE ticket_id = $id";
    $vals["attachments"] = $this->db_get($query);
    // get log entries
    $query = "SELECT count(*) FROM ".$this->table_logs." WHERE ticket_id = $id";
    $vals["log"] = $this->db_get($query);
    // get related
    $vals["related"] = strlen($t["relations"])? count(explode(",",$t["relations"])) : 0;
    $this->addDebug("get_ticket_stats","returning counts: ".implode(",",$vals),3);
    // get notify
    $query = "SELECT count(*) FROM ".$this->table_notify_list
      ." WHERE ticket_id = $id";
    $vals["notify"] = $this->db_get($query);
    return $vals;
  }

  /**
   * retrieves a list of tickets
   * 
   * $params can contain:
   *     bins  - string/array of bins to retrieve for
   *     users - string/array of users to retrieve for
   *     id    - an array of specific ticket ids to retrieve
   * the default columns returned can be overriden by using $columns to 
   * specify what should be returned from this function.  Note that the 
   * sort must correspond to the $columns values for SQL compatibility
   * @param array $params see description
   * @param string $sort [optional] comma separated list for ORDER BY clause
   * @param string $columns [optional] comma separated list of columns to select 
   */
  function get_tickets( $params = '', $sort = 'priority desc, otime desc', $columns = '', $archive_flag = 0 ) {
    $tf_pri = preg_match("/priority/", $sort);

    $tables = $this->table_tickets;
    if( $tf_pri ) {
      $tbl = $this->table_tickets;
      $tblpri = $this->table_priorities;
      $tables .= ", ".$tblpri;
      $sort = preg_replace("/priority/", "$tblpri.priority", $sort);
    }

    if( !is_array($columns) )
      $columns = $tf_pri? array("$tbl.*") : array("*");

    $where = ($tf_pri)? " WHERE $tbl.priority = $tblpri.pid " : "";
    if( is_array($params) ) {
      $where = $where? "$where AND " : "WHERE ";
      $where .= $this->simpleWhere($params);
    }
    $query = "SELECT ".join(",",$columns)." FROM $tables $where";
    if( $sort )
      $query .= " ORDER BY $sort";
    $this->addDebug("get_tickets",$query,3);
    return( $this->db_queryIndexed($query) );
  }      

  function get_user( $user_id ) {
    // returns a specific user
    // by the user id

    $query = "SELECT * FROM ".$this->table_users." WHERE user_id = $user_id";
    return( $this->db_quickIndexed($query) );
  }

  function get_user_by_login( $login ) {
    // returns a user's information by 
    // the login account
    $login = $this->checkSlashes($login);
    $query = "SELECT * FROM ".$this->table_users." WHERE login = $login";
    return( $this->db_quickIndexed($query) );
  }

  /**
   * returns a list of users matching the given name
   *
   * @param string $first first name
   * @param string $last last name
   * @param string $initials users initials
   * @return array of user_ids matching
   */
  function get_users_by_name( $first = '', $last = '', $initials = '' ) {
    $query = "SELECT user_id FROM ".$this->table_users." WHERE user_id > 0";
    if( $first ) {
      $first = $this->checkSlashes($first);
      $query .= " AND fname = $first";
    }
    if( $last ) {
      $last = $this->checkSlashes($last);
      $query .= " AND lname = $last";
    }
    if( $initials ) {
      $initials = $this->checkSlashes($last);
      $query .= " AND initials = $initials";
    }
    return( $this->db_list($query) );
  }

  /**
   * returns a list of users matching the given email address
   *
   * @param string $email the address of users to match
   * @return array of user_ids matching
   */
  function get_users_by_email( $email ) {
    // this is a $this->db_method, even though it doesn't look like one
    $email = $this->checkSlashes($email);    
    $query = "SELECT user_id FROM ".$this->table_users." WHERE email = $email";
    return( $this->db_list($query) );
  }

  /**
   * grabs all users matching the priviledges given for the bins designated
   *
   * @param array $bins the bin ids to match
   * @param string $level the access level to match to each bin
   * @param integer $active 1-active members, 0-active and inactive members
   * @return array indexed, containing all fields from each row matched
   */
  function get_users( $bins = '', $level = 'level_view', $active = 1 ) {
    // get our level
    $lvl = ($level)? $this->settings["$level"] : 0;

    // get a list from the access table
    $outs = array();  //ones to skip
    $ins  = array();   //ones to keep
    if( $bins ) {
      $query = "SELECT user_id,bin_id,lvl FROM ".$this->table_access;      
      $query .= " WHERE bin_id IN(".join(",",$bins).")";
      $query .= " AND lvl IS NOT NULL";
      $vals = $this->db_query($query);
      for($i=0; $i<count($vals); $i++) {
        $v = $vals[$i];
        if( $v[2] < $lvl )
          $outs[] = $v[0];
        else
          $ins[] = $v[0];
      }
    }

    // set the query for users
    $query = "SELECT * FROM ".$this->table_users;
    $query .= " WHERE (access_level >= $lvl";
    // add the users with bin specific access
    $query .= count($ins)? " OR user_id IN(".join(',',$ins)."))" : ")";    
    // remove the users with bin specific overrides
    if( count($outs) ) {
      $query .= " AND user_id NOT IN(".join(",",$outs).")";
    }
    // set the ordering
    $query .= " ORDER BY lname,fname";
    // query
    $vals = $this->db_queryIndexed($query);
    // debug
    $this->addDebug("get_users","results: ".count($vals)."/$query",3);
    // return
    return $vals;
  }

  /*
   * NOTIFY LIST FUNCTIONS
   */

  function get_notify_recipients( $ticket_id ) {
    // Get an array of email addresses.
    // Will need two queries here as some versions of mysql
    // doesn't support JOINS and/or UNIONS as needed for this.

    // query for registered users
    $query  = "SELECT u.email FROM ".$this->table_users." u, ";
    $query .= $this->table_notify_list." nl WHERE ";
    $query .= "u.user_id = nl.user_id AND nl.ticket_id = '";
    $query .= $ticket_id."' ";

    // query for non-registered users
    $query2  = "SELECT email FROM ".$this->table_notify_list." WHERE ";
    $query2 .= "user_id IS NULL AND ticket_id = '".$ticket_id."' ";    
   
    // get the lists of recipients and merge them
    $list = array_merge($this->db_list($query),$this->db_list($query2));
    // print a debug message
    $this->addDebug("get_notify_recipients","Found ".count($list)
                    ." recipients for ticket $ticket_id",3);
    return $list;
  }

  function get_notify_list( $ticket_id ) {
    $query  = "SELECT * FROM ".$this->table_notify_list." WHERE ";
    $query .= "ticket_id = '".$ticket_id."' ";
    $this->addDebug("get_notify_list",$query,3);
    return $this->db_queryIndexed($query);
  }

  function set_notify_list( $ticket_id, $list ) {
    // Do a $this->drop_notify_list($ticket_id)
    // first and then loop through the $list doing INSERTS.
    // note that this list must contain indexed arrays representing
    // each entry to be added
    $this->drop_notify_list($ticket_id); 

    // perform database inserts, and return ids
    $insert_ids = array();
    // save what we insert to avoid duplicates
    $done = array();
    foreach($list as $l) {
      if( ($l["user_id"] && in_array($l["user_id"],$done))
          || (!$l["user_id"] && in_array($l["email"],$done)) ) {
        $this->addDebug("set_notify_list","skipped "
                        .($l["user_id"]? "user {$l['user_id']}" : "email {$l['email']}")
                        .": duplicate");
      }
      else {
        $new_id = $this->add_to_notify_list($ticket_id,$l);
        if( $new_id ) {
          $insert_ids[] = $new_id;
          $done[] = $l["user_id"]? $l["user_id"] : $l["email"];
        }
      }
    }
    $this->addDebug("set_notify_list",count($insert_ids)
                    ." inserts for ticket $ticket_id",3);
    return $insert_ids;
  }

  /**
   * add a new entry to the notify list
   *
   * @param integer $ticket_id the id of the ticket
   * @param array $params indexed array of "column"=>"value"
   * @return id if success, "duplicate" if failed on dup entry, false otherwise
   */
  function add_to_notify_list( $ticket_id, $params ) {
    // check for existing entry (avoid dups)
    $list = $this->get_notify_list($ticket_id);
    if( is_array($list) ) {
      foreach($list as $l) {
        if( $params["user_id"] && $params["user_id"] == $l["user_id"] ) {
          $this->addDebug("add_to_notify_list",
                          "Skipping {$params['user_id']}/{$params['email']}, duplicate",2);
          return "duplicate";
        }
        else if( !$params["user_id"] && $l["email"] 
                 && $l["email"] == $params["email"] ) {
          $this->addDebug("add_to_notify_list",
                          "Skipping {$params['user_id']}/{$params['email']}, duplicate",2);
          return "duplicate";
        }
      }
    }
    // make sure we don't add the egate user
    if( $params["user_id"] ) {
      $usr = $this->get_user($params["user_id"]);
      if( $usr["login"] == "egate" || $usr["initials"] == "egate" ) {
        $this->addDebug("add_to_notify_list","Ignoring egate account",3);
        return false;
      }
    }

    // make sure we have a valid entry
    if( (!isset($params["user_id"])||!trim($params["user_id"]))
        &&
        (!isset($params["email"])||!trim($params["email"])) ) {
      $this->addDebug("add_to_nofiy_list","Entry was blank",2);
      return false;
    }
    
    // appends a new entry to the existing notify list
    $params["ticket_id"] = $ticket_id;
    $id = $this->db_insert($this->table_notify_list,$params);
    if( $id ) {
      $msg = ($params["user_id"])?
        "user {$params['user_id']} added to ticket $ticket_id"
        : "email address {$params['email']} added to ticket $ticket_id"; 
      $this->addDebug("add_to_notify_list",$msg,2);
      return( $id );
    }
  }

  function delete_from_notify_list( $notify_id ) {
    // removes a single entry from the notify list table
    $query = "DELETE FROM ".$this->table_notify_list
      ." WHERE notify_id = $notify_id";
    $this->addDebug("delete_from_notify_list",$query,3);
    return $this->db_result($query);
  }

  /**
   * deletes entries from notify list based on user_id
   *
   * @param integer user_id
   * @param integer ticket_id optional, restricts matches to this ticket
   * @return integer query results
   */
  function drop_notify_by_user( $user_id, $ticket_id = 0 ) {
    $query = "DELETE FROM {$this->table_notify_list} WHERE user_id = $user_id";
    if( $ticket_id )
      $query .= " AND ticket_id = $ticket_id";
    return $this->db_result($query);
  }

  /**
   * deletes entries from notify list based on email address
   *
   * this checks both the user table and the notify table for matching
   * email addresses
   *
   * @param string email address
   * @param integer ticket_id optional, restricts matches to this ticket
   * @return boolean true if matched, false if not
   */
  function drop_notify_by_email( $email, $ticket_id = 0 ) {
    // delete entries in the notify list table
    $query = "DELETE FROM {$this->table_notify_list} WHERE email = '$email'";
    if( $ticket_id )
      $query .= " AND ticket_id = $ticket_id";
    $res = $this->db_result($query);
    // get a list of users matching from users table
    // and delete those from notify too
    $query = "SELECT user_id FROM {$this->table_users} WHERE email = '$email'";
    $ids = $this->db_list($query);
    if( is_array($ids) && count($ids) ) {
      $query = "DELETE FROM {$this->table_notify_list} WHERE user_id in(".
        join(",",$ids).")";
      if( $ticket_id )
        $query .= " AND ticket_id = $ticket_id";
      $res2 = $this->db_result($query);
    }
    return($res || $res2);
  }

  function drop_notify_list( $ticket_id ) {
    // Do a DELETE FROM ZENTRACK_NOTIFY_LIST WHERE ticket_id = $ticket_id
    $q  = "DELETE FROM {$this->table_notify_list} WHERE ticket_id = '";
    $q .= "$ticket_id' ";
    $this->addDebug("drop_notify_list",
                    "notify list dropped for ticket $ticket_id",2);
    $this->db_result($q);
  }

  /**
   * update notify list based on changes
   *
   * given an old ticket and a new ticket
   * this function attempts to update the notify
   * list by removing old owners/testers/managers
   * and adding new ones
   * 
   * @param array $old is the old ticket's properties
   * @param array $new is the new ticket's properties
   */
  function update_notify_list($old, $new) {
    $id = $old["id"];
    if( strlen($new["user_id"]) && $new["user_id"] != 'NULL' 
	&& $this->settings["default_notify_owner"] == "on" ) {
      // modify the owner notification
      if( $this->settings["default_notify_owner"] == "on" ) {
	// see if they changed
	if( $old["user_id"] != $new["user_id"] ) {
	  // drop the old user
	  if( $old["user_id"] ) {
	    $this->drop_notify_by_user($old["user_id"],$id);
	  }
	  // add the new user
	  if( $new["user_id"] ) {
	    $p = array("user_id"=>$new["user_id"]);
	    $this->add_to_notify_list($id,$p);
	  }
	}
      }
    }
    // shorten up some settings for brevity
    $dnm = ($this->settings["default_notify_manager"] == "on");
    $dnt = ($this->settings["default_notify_tester"] == "on");
    if( isset($new["bin_id"]) && ($dnm || $dnt) ) {
      // check if bin has changed
      if( $old["bin_id"] != $new["bin_id"] ) {
	$tester_id = $this->getRoleID("tester");
	$mgr_id = $this->getRoleID("manager");
	// drop the managers and testers from old bin
	if( $old["bin_id"] ) {
	  $vars = array();
	  $roles = $this->fetch_bin_roles($old["bin_id"]);
	  if( is_array($roles) ) {
	    foreach($roles as $r) {
	      if( $r["notes"] == $mgr_id && $dnm ) { 
		$vars[] = $r["user_id"];
	      }
	      else if( $r["notes"] == $tester_id && $dnt ) {
		$vars[] = $r["user_id"];
	      }
	    }
	  }
	  // remove the completed list
	  foreach($vars as $v) {
	    $this->drop_notify_by_user($v,$id);
	  }
	}
	// add managers and testers for new bin
	if( $new["bin_id"] ) {
	  $roles = $this->fetch_bin_roles($new["bin_id"]);
	  if( is_array($roles) ) {
	    foreach($roles as $r) {
	      if( ($r["notes"] == $tester_id && $dnt) ||
		  ($r["notes"] == $mgr_id && $dnm) )
		$this->add_to_notify_list($id,
					  array("user_id"=>$r["user_id"]));
	    }
	  }
	}
      }
    }
  }

  /**
   * BEHAVIORS
   */

  /**
   * Returns a list of behaviors mapped by the behavior_id with the detail fields for each.  The list
   * will be sorted by the sort_order from the behavior table.
   *
   * @param array $ids is a list of behavior ids to retrieve, if ommitted, all behaviors are listed
   * @return array containing behavior_id -> array( data values... )
   */
  function getBehaviorList( $ids = null ) {
    // construct sql statement to retrieve behaviors
    $query = "SELECT * FROM ".$this->table_behavior;
    if( $ids ) {
      $query .= " WHERE behavior_id IN(".join(',',$ids).")";
    }
    $query .= " ORDER BY sort_order, behavior_name";
    $this->addDebug("getBehaviorListQuery:",$query,3);
    $vals = $this->db_queryIndexed($query);

    // create a map of behaviors indexed by the behavior_id
    $map = array();
    foreach( $vals as $v ) {
      $k = $v['behavior_id'];
      $v['fields'] = array();
      $map[$k] = $v;
    }

    // collect the fields for our list of behaviors
    // we will always use the ids from our map for
    // data integrity
    $genIds = array_keys($map);
    $query = "SELECT * FROM ".$this->table_behavior_detail;
    $query .= " WHERE behavior_id IN(".join(',', $genIds).")";
    $query .= " ORDER BY sort_order, field_name";
    $fieldVals = $this->dbQueryIndexed($query);
    foreach($fieldVals as $f) {
      $b = $f['behavior_id'];
      $k = $f['field_name'];
      $map[$b]['fields'][$k] = $f;
    }

    $this->addDebug("getBehaviorList",count($map)." behaviors mapped", 3);
    return $map;
  }

  /**
   * Add a new behavior to the database
   *
   * @param array $props contains the database fields for this behavior
   * @param array $details is mapped field_name -> array( db fields ) and holds all detail entries for this behavior
   * @return integer the id of the newly created behavior or null on failure
   */
  function addBehavior( $props, $details ) { 
    $id = $this->db_insert( $this->table_behavior, $props );
    if( $id ) {
      $this->updateBehaviorDetails( $id, $details );
      $this->addDebug("addBehavior", "Added new behavior with id '".$id."'", 2);
    }
    else {
      $this->addDebug("addBehavior", "Failed to add new behavior!", 3);
    }
    return $id;
  }

  /**
   * Remove a behavior and all of its detail entries from the database
   *
   * @param integer $behavior_id the behavior to remove
   * @return integer representing the query result
   */
  function removeBehavior( $behavior_id ) { 
    return $this->db_delete( $this->table_behavior, "behavior_id", $behavior_id );
  }

  /**
   * Update the properties for a behavior.
   *
   * @param integer $behavior_id the behavior to update
   * @param array $props the new properties for this behavior
   */
  function updateBehavior( $behavior_id, $props ) { 
    return $this->db_update( $this->table_behavior, "behavior_id", $behavior_id, $props );
  }

  /**
   * Update the detail entries for a behavior.  This is accomplished by deleting all current entries and
   * adding the updated values to the table.
   *
   * @param ingteger $behavior_id the behavior to update.
   * @param array $fields mapped field_name -> array(data fields)
   */
  function updateBehaviorDetails( $behavior_id, $fields ) { 
    $this->db_delete($this->table_behavior_detail, "behavior_id", $behavior_id);
    foreach($fields as $f) {
      // make sure we add in the behavior id to each row
      $v['behavior_id'] = $behavior_id;
      list($ck,$cv) = $this->makeInsertVals($v);
      $this->db_result("INSERT INTO ".$this->table_behavior_detail." ($ck) VALUES($cv)");
    }
  }


  /*
   *  VARIABLE FIELDS
   */


  /**
   * Get variable field properties from the index table.  These fields will be returned sorted
   * and with all information needed to determine where fields are active and how to display them.
   */
  function getVarfieldIndex() { 
    return $this->getCustomFields(1);
  }


  /**
   * Update the properties for variable fields in the index table.
   *
   * @param array $fields is mapped (String)field_name -> array( (String)prop -> (mixed)value )
   * @return integer count of fields updated
   */
  function updateVarfieldIndex( $fields ) { 
    $count = 0;
    foreach( $fields as $name=>$props ) {
      $set = $this->makeInsertVals($props, 1);
      if( $this->db_update($this->table_varfield_idx, "field_name", $name, $props) ) 
        { $count++; }
    }
    return $count;
  }


  /**
   * Removes an entry from the variable field index table.  Use this method with great care.  This
   * is not used to disable fields, and should only be used for removing fields which do not exist
   * in the database.
   *
   * @param string $field_name the variable field which no longer exists in the database
   */
  function removeVarfieldIndex( $field_name ) { 
    return $this->db_delete( $this->table_varfield_idx, "field_name", $field_name );
  }


  /**
   * Adds a new entry to the variable field index table
   *
   * @param array $props mapped (String)field -> (mixed)value
   */
  function addVarfieldIndex( $props ) { 
    // we don't use the $this->db_insert() method here because it requires
    // a sequence/auto_increment field, which isn't used in this table
    list($cols,$vals) = $this->makeInsertVals($props);
    $query = "INSERT INTO ".$this->table_varfield_idx." ($cols) VALUES($vals)";
    return $this->db_result($query);
  }

  /**
   * Get variable field values for a given ticket
   *
   * @param integer $ticket_id
   * @return array containing variable field entries for this ticket
   */
  function getVarfieldVals( $ticket_id ) { 
    $query = "SELECT * FROM ".$this->table_varfield." WHERE ticket_id = $ticket_id";
    return $this->db_quickIndexed($query);
  }


  /**
   * Update the entries in the variable field table for a given ticket
   *
   * @param integer $ticket_id
   * @param array $field_values mapped (String)field_name -> (String)value
   */
  function updateVarfieldVals( $ticket_id, $field_values ) { 
    return $this->db_update( $this->table_varfield, "ticket_id", $ticket_id, $field_values );
  }


  /**
   * DATA GROUP FUNCTIONS
   */


  /**
   * Return the information of the data group specified by $group_id
   *
   * @param integer $group_id
   * @return array with information about the data group
   */
  function get_data_group( $group_id ) {
    $query = "SELECT * FROM ".$this->table_group." WHERE group_id = $group_id";
    $vals = $this->db_quickIndexed($query);
    $vals['details'] = $this->get_data_group_details($group_id);
    return $vals;
  }
                                                                                                                             
  /**
   * Return the information of the data group detail specified by $group_id
   *
   * @param mixed $group_id (integer)group_id
   * @return array with information about the data group detail
   */
  function get_data_group_details( $group_id ) {
    $query = "SELECT * FROM ".$this->table_group_detail." WHERE group_id = $group_id"
      ." ORDER BY sort_order";
    return( $this->db_queryIndexed($query) );
  }

  /**
   * Return the labels for each detail in a data group, mapped by the id
   *
   * @param string $table the data table, available from the data group info
   * @param array $details the results of get_data_group_details()
   */
  function getDataGroupLabels( $table, $details ) {
    $table = strtoupper($table);
    $idfield = $this->getDataTypeId($table);
    $sortfield = $this->getDataTypeSort($table);
    if( !is_array($details) || !count($details) ) {
      $this->addDebug("getDataGroupLabels", "Empty detail list, returning empty set", 2);
      return array();
    }
    $ids = array();
    foreach($details as $d) {
      $ids[] = $d['value'];
    }
    $query = "SELECT * FROM {$table} WHERE {$idfield} IN( ".join(",",$ids).")";
    $query .= " ORDER BY {$sortfield}";
    $vals = $this->db_queryIndexed($query);
    $retvals = array();
    foreach($vals as $val) {
      $k = $val[ $idfield ];
      $retvals[$k] = $this->getDataTypeLabel($table,$val);
    }
    return $retvals;
  }

  /**
   * returns information about available data groups
   *
   * if flag is set, retrieves a full
   * indexed array, otherwise, just
   * a list of names, indexed by group_id,
   *
   * @param int $flag 1=return full info, 0=return group_ids and names
   * @return array of data groups
   */
  function getDataGroups($flag = 0) {
    if( !$flag ) {
      $query = "SELECT group_id, group_name FROM ".$this->table_group." ORDER BY group_name";
      $vars = $this->db_query($query);
      foreach($vars as $v) {
        $vals["$v[0]"] = $v[1];
      }
      return($vals);
    } else {
      $query = "SELECT * FROM ".$this->table_group;
      $query .= " ORDER BY group_name";
      return( $this->db_queryIndexed($query) );
    }
  }

  /**
   * Create a new group with the provided information
   *
   * @param string $name name of the group
   * @param string $table the table this group applies to
   * @param array $vals the values as they would be passed to {@link ZenTrack::updateDataGroupDetails()}
   * @return integer
   */
  function addDataGroup( $name, $table, $descript, $vals ) { 
    // create the group first
    $id = $this->db_insert( $this->table_group, array("table_name"=>$table, "group_name"=>$name, "descript"=>$descript) );
    if( $id ) {
      $this->_insertGroupDetails($id, $vals);
    }
    return $id;
  }

  /**
   * Get an array with the tables that are available for data groups
   *
   * @return array
   */
  function getDataGroupTablesArray() {
    return array("Bins"           =>  $this->table_bins,
                 "Priorities"     =>  $this->table_priorities,
                 "Systems"        =>  $this->table_systems,
                 "Tasks"          =>  $this->table_tasks,
                 "Types"          =>  $this->table_types,
                 "Users"          =>  $this->table_users,
                 "Custom"         =>  "");
  }

  
  /**
   * Update an existing data group.  To update the detail values, use {@link ZenTrack::updateDataGroupDetails()}.
   *
   * @param integer $group_id the id of the data group to be updated
   * @param string $name the updated name of the group
   * @param string $table the updated table for the group
   */
  function updateDataGroup( $group_id, $name, $table, $descript ) { 
    return $this->db_update($this->table_group, "group_id", $group_id, 
			    array("group_name"=>$name,"table_name"=>$table,"descript"=>$descript));
  }

  /**
   * Update the detail values for a given group.  This deletes any existing entries and replaces them
   * with the values passed here
   *
   * @param integer $group_id the group to update
   * @param array $vals the new detail table values
   */
  function updateDataGroupDetails( $group_id, $vals ) { 
    $this->db_delete($this->table_group_detail, "group_id", $group_id);
    $this->_insertGroupDetails($group_id, $vals);
  }

  /**
   * Delete an existing data group and all associated details
   *
   * @param integer $group_id
   */
  function removeDataGroup( $group_id ) { 
    $this->db_delete($this->table_group_detail, "group_id", $group_id);
    return $this->db_delete($this->table_group, "group_id", $group_id);
  }

  /**
   * Inserts group details into the database
   */
  function _insertGroupDetails( $group_id, $vals ) {
    foreach($vals as $v) {
      // make sure we add in the group id to each row
      $v['group_id'] = $group_id;
      list($ck,$cv) = $this->makeInsertVals($v);
      $this->db_result("INSERT INTO ".$this->table_group_detail." ($ck) VALUES($cv)");
    }
  }



  /*
   *  SEARCH FUNCTIONS 
   */


  function search_logs( $params, $offset = 0, $archive_flag = 0 ) {
    // search through log entries for given text
    // params is an indexed array with two elements:
    //   $params[key][0] = LIKE, =, >, <, >=, etc..
    //   $params[key][1] = '%value', '%value%', lower('value'), etc
    // see db.class complexWhere() for more details concerning
    // the params array
    // this function requires the values to be provided with single
    // quotes and escape chars in place, they will not be added!
    // if archive_flag = 1, then searches ticket archives as well
    // if archive_flag = 2, then searches archives only

    $columns = array(
                     "lid",     "ticket_id", 
                     "user_id",  "action",
                     "entry",   "bin_id", "created"
                     );

    $where = $this->build_search_clause($params, "AND");
    if( $archive_flag ) {
      $tables = ($archive_flag == 2)? 
        $this->table_logs_archived : 
        $this->table_logs_archived.", ".$this->table_logs;
    }
    else {
      $tables = $this->table_logs;
    }
    $query = "SELECT ".join(",",$columns)
      ." FROM $tables WHERE $where ORDER BY created DESC";
    $this->addDebug("search_logsQuery",$query,2);
    return(  $this->db_queryIndexed($query) );
  }

  function search_tickets( $params, $andor = 'AND', 
                           $archive_flag=0,$order_by='status DESC, priority DESC' ) {
    // search through tickets for given text
    // acceptable params are:
    // params is an indexed array with two elements:
    //   $params[key][0] = LIKE, =, >, <, >=, etc..
    //   $params[key][1] = '%value', '%value%', lower('value'), etc
    // see db.class->build_search_clause() for details concerning
    // the params array
    // if archive_flag = 1, then searches ticket archives as well
    // if archive_flag = 2, then searches archives only

    $where = $this->build_search_clause($params, $andor);
    
    if( $archive_flag ) {
      $tables = ($archive_flag == 2)? 
        $this->table_tickets_archived : 
        $this->table_tickets_archived.", ".$this->table_tickets;
    }
    else {
      $tables = $this->table_tickets;
    }

    $tf_pri = preg_match("/priority/", $order_by);
    $tbl = $this->table_tickets;
    $leftjoin = " LEFT JOIN $this->table_varfield ON "
              . "$this->table_tickets.id=$this->table_varfield.ticket_id";

    if( $tf_pri ) {
      $tblpri = $this->table_priorities;
      $tables .= ", ".$tblpri;
      $order_by = preg_replace("/priority/", "$tblpri.priority", $order_by);
      
      $where = ($where)? "$tbl.priority = $tblpri.pid AND ($where)": "$tbl.priority = $tblpri.pid";
    }

    $query = "SELECT $tbl.* "
      ." FROM $tables "
      ." $leftjoin "
      ." WHERE $where"
      ." ORDER BY $order_by";
    $this->addDebug("search_ticketsQuery:",$query,2);
    return(  $this->db_queryIndexed($query) );      
  }

  function search_users( $params, $andor = "AND", $order_by = 'lname,fname' ) {
    // search for users and return a detailed list
    // of users who match the criteria given
    // see db.class->build_search_clause() for details about
    // constructing a $params array

    $table = $this->table_users;
    $where = $this->build_search_clause($params,$andor);
    $query = "SELECT * FROM $table WHERE $where"
      ." ORDER BY $order_by";
    $this->addDebug("search_users()Query",$query,2);
    return( $this->db_queryIndexed($query) );
  }


  /*
   *  PROJECT ADMINISTRATION 
   */


  function add_project( $params ) {
    // create a new project with the given params
    // (abstracted from add_ticket() to allow
    // for custom functionality)
    // all dates are to be sent as unix timestamps

    $params["type_id"] = $this->projectTypeID();
    unset($params["est_hours"]);
    unset($params["wkd_hours"]);
    return( $this->add_ticket($params) );
  }

  function delete_project( $pid, $archive_flag = 0 ) {
    // drop project, all associated tickets
    // all log entries of those tickets, and
    // all their data from the db
    // if $archive_flag = 1, then deletes from the
    // archive table

    $children = $this->getProjectChildren($pid, array('id'), $archive_flag);
    for($i=0; $i<count($children); $i++) {
      $ids[] = $children["id"];
    }
    //drop the tickets under this project      
    $this->delete_ticket($ids, $archive_flag); 
    $this->delete_log($pid, NULL, $archive_flag);
    $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
    $query = "DELETE FROM $table WHERE id = $pid";
    return( $this->db_result($query) );
  }

  function close_project( $pid, $params = '', $override = 0 ) {
    // sets the status of a project to 'CLOSED' assuming
    // that the project doesn't require testing and approval
    // and that all children are closed (otherwise will skip)
    // if $override is passed, then this method will
    // close a project, even if testing or approval are
    // required, or there are open children.
    // $params is an array passed on to the log function
    //   (user_id, comments)

    if( $override || $this->check_status($pid, 'READY') ) {
      $children = $this->getProjectChildren($pid, array('id'));
      for( $i=0; $i<count($children); $i++ ) {
        $this->close_ticket($children[$i]);    
      }
      return( $this->change_status($pid, 'CLOSED', $params) );    
    }
  }


  /*
   *  TICKET ACTIONS 
   */


  function accept_ticket( $id, $user_id, $comments = '', $bin_id = '' ) {
    // changes the tickets user_id to reflect
    // a new owner for the ticket
    // logs this in the db if settings["log_accept"] = "On";
    // the bin_id is used for logging, if it is available, this just
    // saves a db query

    // if we passed the ticket
    // rather than the id then use it
    if( is_array($id) ) {
      $ticket = $id;
      $id = $ticket["id"];
    }

    $params = array( "user_id" => $user_id );
    $res = $this->update_ticket($id,$params);
    if( $res && $this->settings["log_accept"] == "on" ) {
      $logParams = array(
                         "action"   =>  'ACCEPTED',
                         "user_id"   =>  $user_id,
                         "ticket_id" =>  $id
                         );
      if( !$bin_id ) {
        if( !is_array($ticket) ) {
          $ticket = $this->get_ticket($ticket);
        }
        $bin_id = $t["bin_id"];
      }
      $logParams["bin_id"] = $bin_id;
      if( $comments )
        $logParams["entry"] = htmlentities($comments);   
      $res = $this->add_log($id, $logParams);
    }
    if( $res && $this->settings["email_accept"] == "on" ) {
      $recipients = $this->get_notify_recipients($id);
      if( is_array($recipients) && count($recipients) ) {
        $subject = $this->ptrans("ticket #?: accepted by ?",array($id,$name));
        $emailParams["Assigned by"] = $this->formatName($user_id);
        if( $comments )
          $emailParams["body"] = htmlentities($comments);
        $emailParams["tid"] = (is_array($ticket))? $ticket : $id;
        $message = $this->formatEmailMessage($emailParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return( $res );
  }

  function approve_ticket( $id, $user_id, $comments = '' ) {
    // changes the approval status to 2 for the ticket
    // if the ticket is ready for closure, then this function
    // will also close out the ticket

    // if we have the ticket array, use this instead
    if( is_array($id) ) {
      $t = $id;
      $id = $t["id"];
    }
    else {
      $t = $this->get_ticket($id);
    }
    $params = array("approved"=>2);
    $res = $this->update_ticket($id,$params);
    if( $res && $this->settings["log_approve"] ) {
      $logParams = array(
                         "action"   =>  'APPROVED',
                         "user_id"   =>  $user_id,
                         "ticket_id" =>  $id
                         );
      $logParams["bin_id"] = $t["bin_id"];
      if( $comments )
        $logParams["entry"] = htmlentities($comments);
      $this->add_log($id, $logParams);    
    }     
    if( $t["tested"] != 1 ) {
      $res = $this->close_ticket($id);
    }
    else if( $this->settings["email_pending"] == "on" ) {
      $recipients = $this->get_notify_recipients($id);
      // make sure testers get notification      
      $vals = $this->fetch_bin_role_emails($t['bin_id'], $this->getRoleId("tester"));
      $this->checkIncludedRecipients($recipients,$vals);
      // create email
      if( is_array($recipients) && count($recipients) ) {
        $bin = $t["bin_id"];
        $subject = $this->ptrans("Ticket #?: closed",array($id));
        $emailParams["Close Time"] = $this->showDateTime($this->currTime);
        if( $comments )
          $emailParams["body"] = htmlentities($comments);
        $emailParams["tid"] = $t;
        $message = $this->formatEmailMessage($emailParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return( $res );
  }

  function assign_ticket( $id, $recipient, $user_id = '', $comments = '' ) {
    // set the user_id for the ticket to another person
    // the recipient recieves the ticket, the user_id is for the 
    // sender

    $params = array( "user_id" => $recipient );
    if( is_array($id) ) {
      $ticket = $id;
      $id = $ticket["id"];
    }
    else {
      $ticket = $this->get_ticket($id);
    }
    $res = $this->update_ticket($ticket, $params);
    if( $res ) {
      // move the ticket somewhere that the user
      // will be able to access it, if required
      $userBins = $this->getUsersBins($recipient,"level_user");
      if( is_array($userBins)&&!in_array($ticket["bin_id"],$userBins) ) {
        $user = $this->get_user($recipient);
        if( $user["homebin"] ) {
          $this->update_ticket($id,array("bin_id"=>$user["homebin"]));
        }
        else {
          $this->update_ticket($id,array("bin_id"=>$userBins[0]));
        }
      }
    }
    $name = $this->formatName($recipient,1);
    if( $res && $this->settings["log_assign"] == 'on' ) {
      $logParams = array(
                         "action"   =>  'ASSIGNED',
                         "user_id"   =>  $user_id
                         );
      $logParams["bin_id"] = $ticket["bin_id"];
      $logParams["entry"] = "Assigned to $name";
      if( $comments )
        $logParams["entry"] .= "\n\n".$comments;
      $this->add_log($id, $logParams);                
    }
    if( $res && $this->settings["email_assign"] == "on" ) {
      $user = $this->get_user($recipient);
      $recipients = $this->get_notify_recipients($id);
      // make sure the assignee gets a notification
      $this->checkIncludedRecipients($recipients,$user["email"]);
      // create email
      if( is_array($recipients) && count($recipients) ) {
//        if( !$name )
//          $name = $this->formatName($recipient,1);
        $subject = $this->ptrans("Ticket #?: assigned to ?",array($id,$name));
        $emailParams["Assigned by"] = $this->formatName($user_id);
        $emailParams["Assigned to"] = $name;
        if( $comments )
          $emailParams["body"] = htmlentities($comments);
        $emailParams["tid"] = $id;
        $message = $this->formatEmailMessage($emailParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return( $res );
  }   

  function attach_to_ticket( $id, $user_id, $params, $log_id = 0 ) {
    // creates an attachment to the given ticket and logs
    // the event if needed
    // the params array contains:
    //     name         - name of the file to display
    //     filename     - name of file on system
    //     filetype     - mime type (i.e. image/gif)
    //     description  - [optional] comments about the file for display
    extract($params);
    $res = $this->add_attachment($name, $filename, $filetype, $id, 
                                 $log_id, $description);
    if( $res && $this->settings["log_attachment"] == 'on' ) {
      $logParams = array(
                         "user_id"   => $user_id,
                         "action"   => "ATTACHMENT"
                         );
      $logParams["entry"] = "$name--$filetype";
      if( $description )
        $logParams["entry"] .= "--".$description;   
      if( $log_id )
        $logParams["entry"] .= "\nattached to log $log_id";
      $r = $this->add_log( $id, $logParams );
      if( !$r )
        die("couldn't log it");
    }
    return $res;
  }

  function close_ticket( $id, $user_id = '', $hours = '', $comments = '' ) {
    // closes the ticket (sets the status to CLOSED)
    // if there is testing or approval yet required, then
    // simply sets status to pending.
    // however, if both of these are completed, then 
    // closes out the ticket
    
    // get ticket info
    if( is_array($id) ) {
      $t = $id;
      $id = $t["id"];
    }
    else {
      $t = $this->get_ticket($id);
    }
    if( $this->check_status($t,"READY") ) {
      // if ticket is ready to close, then close it
      $params = array(
		      "status"  =>  'CLOSED',
		      "ctime"   =>  $this->currTime
		      );
      if( strlen($user_id) ) {
	$params["user_id"] = $user_id;
      }
      $res = $this->update_ticket($id, $params);
      if( $this->settings["log_close"] == "on" ) {
	// create a log entry
	$logParams = array(
			   "action"   =>  'CLOSED',
			   "ticket_id" =>  $id 
			   );
	// get the params
	if( $user_id ) {
	  $logParams["user_id"] = $user_id;
	}
	$logParams["bin_id"] = $t["bin_id"];
	if( $hours )
	  $logParams["hours"] = $hours;
	if( $comments )
	  $logParams["entry"] = $comments;
	// send the log
	$this->add_log($id, $logParams);    
      }
      if( $this->settings["email_closed"] == "on" ) {
	// send email
	$recipients = $this->get_notify_recipients($id);
        // make sure the manager gets a notification
        $vals = $this->fetch_bin_role_emails($t['bin_id'],$this->getRoleId('manager'));
        $this->checkIncludedRecipients($recipients,$vals);
        // create email
	if( is_array($recipients) && count($recipients) ) {
	  $bin = $t["bin_id"];
	  $subject = $this->ptrans("Ticket #?: closed",array($id));
	  $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	  if( $comments )
	    $emailParams["body"] = $comments;
	  $emailParams["tid"] = $t;
	  $message = $this->formatEmailMessage($emailParams);
	  $this->sendEmail($recipients,$subject,$message,$user_id);       
	}
      } 
    } else if( ($t["tested"] == 1 || $t["approved"] == 1) 
	       && $t["status"] == "OPEN" ) {
      // update status to pending
      $params = array(
		      "status"  =>  'PENDING',
		      "user_id"  =>  'NULL'
		      );
      $res = $this->update_ticket($id, $params);
      if( $this->settings["log_pending"] == "on" ) {
	// make a log entry
	$logParams = array(
			   "action"   =>  'PENDING',
			   "ticket_id" =>  $id,
			   "entry"    =>  $entry
			   );
	if( $user_id ) {
	  $logParams["user_id"] = $user_id;
	}
	$logParams["bin_id"] = $t["bin_id"];      
	if( $hours )
	  $logParams["hours"] = $hours;
	if( $comments )
	  $logParams["entry"] = $comments;
	$this->add_log($id, $logParams);    
      }  
      if( $this->settings["email_pending"] == "on" ) {
	// send an email
	$recipients = $this->get_notify_recipients($id);
        // make sure the testers/managers gets a notification
        if( $t['tested'] == 1 ) {
          $vals = $this->fetch_bin_role_emails($t['bin_id'], $this->getRoleId('tester'));
        }
        if( $t['tested'] != 1 || !is_array($vals) ) {
          $vals = $this->fetch_bin_role_emails($t['bin_id'], $this->getRoleId('manager'));
        }        
        $this->checkIncludedRecipients($recipients, $vals);
        // create email
	if( is_array($recipients) && count($recipients) ) {
	  $bin = $t["bin_id"];
	  $subject = $this->ptrans("Ticket #?: closed",array($id));
	  $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	  if( $comments )
	    $emailParams["body"] = htmlentities($comments);
	  $emailParams["tid"] = $id;
	  $message = $this->formatEmailMessage($emailParams);
	  $this->sendEmail($recipients,$subject,$message,$user_id);
	} 
      } 
    }
    return($res);
  }
  
  function log_ticket( $id, $user_id, $action = 'LOG', $hours = '', $comments = '' ) {
    // create an entry in the ticket log to track hours
    // or work done

    $logParams["user_id"] = $user_id;
    if( $action )
      $logParams["action"] = $action;
    if( $hours )
      $logParams["hours"] = $hours;
    if( $comments )
      $logParams["entry"] = $comments;
    $res = $this->add_log($id, $logParams);
    if( $res && $this->settings["email_log"] == "on" ) {
      $recipients = $this->get_notify_recipients($id);
      if( is_array($recipients) && count($recipients) ) {
        $eParams = array(
                         "Sent" => $this->showDateTime(),
                         "By"   => $this->formatName($user_id)
                         );
        if( $hours )
          $eParams["hours"] = $hours;
        if( $comments )
          $eParams["body"] = $comments;  
        $eParams["tid"] = $id;
        $message = $this->formatEmailMessage($eParams);
        $subject = $this->ptrans("Ticket #?: Log added by ?", array($id,$this->formatName($user_id,2)));
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return $res;
  }

  function move_ticket( $id, $newBin, $user_id = '', $comments = '' ) {
    // moves the ticket to a new bin location
    // if comments field is set to 'skip_log' then
    // no log will be generated (assumed to have 
    // been done before calling this)

    $t = $this->get_ticket($id);      
    $params = array(
                    "bin_id"  => $newBin,
                    "user_id" => 'NULL'
                    );
    $res = $this->update_ticket($id, $params);
    if( $res && $this->settings["log_move"] == "on" ) {
      $logParams["action"] = "MOVED";
      $logParams["bin_id"] = $t["bin_id"];
      $logParams["entry"] = "MOVED TO ".$this->bins["$newBin"];
      $logParams["ticket_id"] = $id;
      if( $user_id )
        $logParams["user_id"] = $user_id;
      if( $comments )
        $logParams["entry"] .= "\n\n".$comments;
      $this->add_log($id,$logParams);
    }
    if( $res && $this->settings["email_arrival"] == "on" ) {
      $recipients = $this->get_notify_recipients($id);
      // make sure the manager gets a notification
      $vals = $this->fetch_bin_role_emails($t['bin_id'], $this->getRoleId('manager'));
      $this->checkIncludedRecipients($recipients,$vals);
      // create email
      if( is_array($recipients) && count($recipients) ) {
        $eParams = array(
                         "From" => $this->bins["$t[bin_id]"], 
                         "Sent" => $this->showDateTime(),
                         "By"   => $this->formatName($user_id)
                         );
        if( $comments )
          $eParams["body"] = $comments;
        $eParams["tid"] = $t;
        $message = $this->formatEmailMessage($eParams);
        $subject = $this->ptrans("Ticket #?: moved to ?",array($id,$this->getBinName($newBin)));
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return($res);
  }

  function reject_ticket( $id, $user_id, $comments = '' ) {
    $sender = $this->getTicketSender($id);
    if( !$sender["bin_id"] && $sender["user_id"] )
      $res = $this->assign_ticket($id,$sender["user_id"],$user_id);
    else if( $sender["bin_id"] )
      $res = $this->move_ticket( $id, $sender["bin_id"], $user_id );
    $t = $this->get_ticket($id);
    if( $res && $this->settings["log_reject"] == "on" ) {
      $logParams["action"] = "REJECTED";
      $logParams["bin_id"] = $t["bin_id"];
      $logParams["user_id"] = $user_id;
      $logParams["ticket_id"] = $t["id"];
      if( $comments )
        $logParams["entry"] = $comments;
      $this->add_log($id,$logParams);
    }
    if( $res && $this->settings["email_reject"] == "on" ) {
      $recipients = $this->get_notify_recipients($id);
      // make sure the sender gets an email
      if( is_array($sender) && isset($sender["user_id"]) ) {
	$user = $this->get_user($sender["user_id"]);
	$this->checkIncludedRecipients($recipients,$user['email']);
      }
      if( is_array($recipients) && count($recipients) ) { 
        // add the sender if not on notify list
        if( $sender && $sender["user_id"] ) {
          $usr = $this->get_user($sender["user_id"]);
          $dup = false;
          foreach($recipients as $r) {
            if( $usr["email"] = $r ) {
              $dup = true;
              break;
            }
          }
          if( !$dup ) {
            $recipients[] = $usr["email"];
          }
        }
        $subject = $this->ptrans("Ticket #?: rejected",array($id));
        $eParams = array(
                         "From" => $this->bins["$t[bin_id]"], 
                         "Time" => $this->showDateTime(),
                         "By"   => $this->formatName($user_id)           
                         );
        if( $comments )
          $eParams["body"] = $comments;
        $eParams["tid"] = $id;  
        $message = $this->formatEmailMessage($eParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }      
    return($res);
  }

  function relate_ticket( $id, $relations, $user_id = '', $comments = '' ) {
    // takes either a comma delimited string
    // or an array of ticket ids
    // checks to insure they exist before performing
    // relations
    // 
    // THIS FUNCTION IS VERY INEFFICIENT AND NEEDS TO BE REVISED
    // IT'S A HORRIBLE HACK FIX NOW, AND PROBABLY REQUIRES
    // THE CREATION OF A NEW DB TABLE AND SOME EDITS
    // TO THIS FUNCTION (possibly the addition of an addRelation()
    // and dropRelation() method to encompass non-global updates)

    $t = $this->get_ticket($id);      
    if( !is_array($relations) ) {
      $relations = trim($relations);
      $relations = split(" *, *", $relations);
    }
    $relations = $this->checkRelations($relations,$id);

    $rel = (is_array($relations))? join(",",$relations) : "";
    $res = $this->update_ticket($id, array("relations"=>$rel));
    if( is_array($relations) ) {      
      //
      // 
      // 
      // 
      // need to add some methodology here to update the tickets
      // which this one is related to to reflect that relation as
      // well, and to remove relations from tickets which used to
      // be related to this one which aren't anymore
      // 
      // see the comments at the top of this method for more gripes
      // about this bug
      // 
      // 
      // 
    }

    if( $res && $this->settings["log_relate"] == "on" && $user_id ) {
      $logParams["action"] = "RELATED";
      $logParams["bin_id"] = $t["bin_id"];
      $logParams["user_id"] = $user_id;
      $logParams["ticket_id"] = $t["ticket_id"];
      $logParams["entry"] = join(",",$relations);
      if( $comments )
        $logParams["entry"] .= "\n\n".$comments;
      $this->add_log($id,$logParams);
    }
    return( $res );
  }

  function reopen_ticket( $id, $user_id = 'NULL', $comments = '' ) {
    // opens a ticket that has been closed
    // this can be used to reopen tickets
    // closed in error, or to make modifications
    // to a closed ticket

    $t = $this->get_ticket($id);      
    $params = array(
                    "ctime"    =>   'NULL',
                    "user_id"   =>   $user_id,
                    "status"   =>   'OPEN',
                    "bin_id"    =>   $t["bin_id"],
                    "tested"   =>   ($t["tested"]>0)? 1 : 0,
                    "approved" =>   ($t["approved"]>0)? 1 : 0
                    );
    $res = $this->update_ticket($id, $params);
    if( $res ) {
      $logParams["action"] = "REOPENED";
      $logParams["bin_id"] = $t["bin_id"];
      $logParams["user_id"] = $user_id;
      $logParams["ticket_id"] = $t["ticket_id"];   
      $logParams["entry"] = "Ticket #$id: opened in ".$this->bins["$bin_id"];
      if( $comments )
        $logParams["entry"] .= "\n\n".$comments;
      $this->add_log($id,$logParams);
    }
    if( $res && ($this->settings["email_created"] == "on" 
                 || $this->settings["email_arrival"] == "on")  ) {
      $recipients = $this->get_notify_recipients($id);
      if( $t['user_id'] ) {
	$user = $this->get_user($t["user_id"]);
	if( is_array($user) && $user["email"] ) {
	  $this->checkIncludedRecipients($recipients,$user['email']);
	}
      }
      if( is_array($recipients) && count($recipients) ) {
        $subject = $this->ptrans("Ticket #?: reopened",array($id));
        $eParams = array(
                         "message" => $this->ptrans("Ticket ? has been reopened.",array($id)) . '',
                         "From"    => $this->bins["$t[bin_id]"], 
                         "Time"    => $this->showDateTime(),
                         "By"      => $this->formatName($user_id)        
                         );
        if( $comments )
          $eParams["body"] = $comments;
        $eParams["tid"] = $id;
        $message = $this->formatEmailMessage($eParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }
    }
    return( $res );
  }

  function test_ticket( $id, $user_id, $hours = '', $comments = '' ) {
    // updates the testing parameter to reflect
    // a status of 'testing completed' for the ticket

    $t = $this->get_ticket($id);
    $res = $this->update_ticket($id, array("tested"=>2));
    if( $res && $this->settings["log_test"] ) {
      $logParams["action"] = "TESTED";
      $logParams["bin_id"] = $t["bin_id"];
      $logParams["user_id"] = $user_id;
      $logParams["ticket_id"] = $t["ticket_id"];   
      if( $comments )
        $logParams["entry"] = $comments;
      $this->add_log($id,$logParams);  
    }
    if( $t["approved"] != 1 ) {
      // go ahead and close the ticket
      // since it doesn't need to be
      // approved       
      $this->close_ticket($id);
    }         
    else if( $this->settings["email_pending"] == "on" ) {
      $bin = $t["bin_id"];
      $recipients = $this->get_notify_recipients($id);
      // make sure the testers/managers gets a notification
      $vals = $this->fetch_bin_role_emails($t['bin_id'], $this->getRoleId('manager'));
      $this->checkIncludedRecipients($recipients,$vals);
      // create email
      if( is_array($recipients) ) {
        $subject = $this->ptrans("Ticket #?: closed",array($id));
        $emailParams["Close Time"] = $this->showDateTime($this->currTime);
        if( $comments )
          $emailParams["body"] = htmlentities($comments);
        $emailParams["tid"] = $id;
        $message = $this->formatEmailMessage($emailParams);
        $this->sendEmail($recipients,$subject,$message,$user_id);
      }       
    }
    return( $res );
  }

  function yank_ticket( $id, $user_id, $comments = '' ) {
    // takes a ticket from it's current location and status 
    // (whatever those might be) and 
    // assigns it to the user specified

    $t = $this->get_ticket($id);
    $bin_id = $t["bin_id"];
    if( is_array($t) ) {
      if( $this->settings["log_yank"] == "on" ) {
        $lParams = array(
                         "action"   =>   "YANKED",
                         "user_id"   =>   $user_id,
                         "bin_id"    =>   $bin_id
                         );
        if( $comments )
          $lParams["entry"] = $comments;
        $this->add_log($id,$lParams);
      }
      if( $this->settings["email_assign"] == "on" ) {
        $recipients = $this->get_notify_recipients($id);
	if( $t["user_id"] ) {
	  $user = $this->get_user($t["user_id"]);
	  if( $user['email'] ) {
	    $this->checkIncludedRecipients($recipients,$user['email']);
	  }
	}
        $name = $this->formatName($user_id);
        if( is_array($recipients) && count($recipients) ) {
          $subject = $this->ptrans("Ticket #?: yanked by ?",array($id,$name));
          $emailParams["Assigned To"] = $name;
          $emailParams["body"] = $subject;
          $emailParams["tid"] = $id;
          $message = $this->formatEmailMessage($emailParams);
          $this->sendEmail($recipients,$subject,$message,$user_id);
        }
      }
      if( $t["status"] == 'CLOSED' ) {
        $tested = ($t["tested"] == 2)? 1:0;
        $approved = ($t["approved"] == 2)? 1:0;
        $this->reopen_ticket($id, $user_id, $tested, $approved, $comments);
      }
      $this->assign_ticket($id,$user_id);
      return( 1 );
    }
  }

  /*
   *  TICKETS ADMINISTRATION
   */

  /*
   * create a new ticket
   * 
   * @param array $params is an indexed array("database_column"=>value), the values will be quoted and checked
   * @param string $log_notes is extra notes to add to create log
   * @return integer returns the new ticket's id, if creation succeeded
   */
  function add_ticket( $params, $log_notes = '' ) {
    // perform the ticket insert
    $id = $this->db_insert($this->table_tickets,$params);
    if( $id ) {
      // create the notify list for this ticket
      $notify_list = array();
      // the bin owners
      if( $this->settings["default_notify_owner"] == "on" ) {
        $vars = $this->fetch_bin_roles($params["bin_id"],"manager");
        if( is_array($vars) && count($vars) ) {
          foreach($vars as $v) {
            $notify_list[]["user_id"] = $v["user_id"];
          }
        }
      }
      // the bin testers
      if( $this->settings["default_notify_tester"] == "on" ) {
        $vars = $this->fetch_bin_roles($params["bin_id"],"tester");
        if( is_array($vars) && count($vars) ) {
          foreach($vars as $v) {
            $notify_list[]["user_id"] = $v["user_id"];
          }
        }
      }
      // the ticket creator
      if( $this->settings["default_notify_creator"] == "on" ) {
        $notify_list[]["user_id"] = $params["creator_id"];
      }
      // the ticket owner
      if( $this->settings["default_notify_owner"] == "on"
          && $params["user_id"] ) {
        $notify_list[]["user_id"] = $params["user_id"];   
      }
      // create the list
      $this->set_notify_list($id,$notify_list);

      // create a log entry
      $lParams = array(
                       "action"   =>   "CREATED",
                       "user_id"   =>   $params["creator_id"],
                       "bin_id"    =>   $params["bin_id"]
                       );
      if( $log_notes ) {
        $lParams["entry"] = $log_notes;
      }
      $this->add_log($id,$lParams);

      if( $this->settings["email_created"] == "on" ) {
        // send email
        $bin = $t["bin_id"];
        // set the recipient list
        $recipients = $this->get_notify_recipients($id);
	if( $params["user_id"] ) {
	  $user = $this->get_user($params["user_id"]);	
	  if( $user["email"] ) {
	    $this->checkIncludedRecipients($recipients,$params['user_id']);
	  }
	}
        if( is_array($recipients) && count($recipients) ) {
          $recipient = array_unique($recipients);
          $subject = $this->ptrans("Ticket #?: created",array($id));
          $emailParams["Open Time"] = $this->showDateTime($this->currTime);
          if( $comments )
            $emailParams["body"] = htmlentities($comments);
          $emailParams["tid"] = $id;
          $message = $this->formatEmailMessage($emailParams);
          $this->sendEmail($recipients,$subject,
                           $message,$params["creator_id"]);
        }
      } 
    }
    return $id;
  }
   
  function delete_ticket( $id, $archive_flag = 0 ) {
    // drop a ticket, its log entries, and 
    // all associated data from the db
    // $id can be an array
    $this->delete_log($id, $archive_flag);
    $table = ($flag)? 
      $this->table_tickets_archived : $this->table_tickets;
    $where = (is_array($id))? " id IN(".join(",",$id).")" : " id = $id";
    $query = "DELETE FROM $table WHERE $where";
    $this->addDebug("delete_ticket",$query,2);
    return( $this->db_result($query) );
  }

  /**
   * updates the properties of a ticket
   *
   * @param integer $id is the id of the ticket
   * @param array $params is an indexed array "column_name"=>value. These values will be quoted and formatted for sql use
   * @return integer result value
   */
  function update_ticket( $id, $params ) {
    if( is_array($id) ) {
      $t = $id;
      $id = $t["id"];
    }
    else {
      $t = $this->get_ticket($id);
    }
    foreach($params as $k=>$v) {
      if( !strlen($v) ) {
        switch($k) {
        case "otime":
        case "ctime":
        case "tested":
        case "approved":
        case "priority":
          $params["$k"] = 0;
          break;
        case "est_hours":
        case "wkd_hours":
          $params["$k"] = 0.00;
          break;
        case "status":
          $params["$k"] = "OPEN";
          break;
        default:
          $params["$k"] = "NULL";
        }
      }
    }
    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_tickets." SET $set WHERE id = $id";
    $this->update_notify_list($t,$params);
    $this->addDebug("update_ticket",$query,3);
    return( $this->db_result($query) );
  }      
   
  /*
   *  LOG AND TIME FUNCTIONS 
   */


  function add_log( $id, $params ) {
    // add a new log entry for ticket
    // with $id
    // params can include any of the 
    // following indexes:
    //    user_id
    //    bin_id
    //    action (the action logged)
    //    entry (the log entry)
    //    ticket_id

    // set up the parameters for the insert statement
    $table = $this->table_logs;
    $params["ticket_id"] = $id;
    $params["created"] = $this->currTime;
    if( !$params["action"] )
      $params["action"] = "LOG";
    if( !$params["user_id"] )
      $params["user_id"] = 0;//$this->settings["bot_name"];
    if( !$params["bin_id"] ) {
      $ticket = $this->get_ticket($id);
      $params["bin_id"] = $ticket["bin_id"];
    }
    // add hours to the ticket's total
    if( $params["hours"] ) {
      if( !$ticket )
        $ticket = $this->get_ticket($id);
      $wkd = $params["hours"] + $ticket["wkd_hours"];
      $query = "UPDATE ".$this->table_tickets
        ." set wkd_hours = $wkd WHERE id = $id";
      $this->db_result($query);
    }
    return( $this->db_insert($table, $params) );      
  }

  function delete_log( $id, $flag = 0, $archive_flag = 0 ) {
    // delete log entries for ticket with
    // $id, if $flag = 1, then deletes only
    // the entry with log_id of $id (i.e. by the
    // log id instead of ticket id)
    // id can be a string or an array

    $column = ($flag)? "lid" : "ticket_id";
    if( is_array($id) )
      $where = " $column IN(".join(",",$id).")";
    else
      $where = " $column = $id";
    $table = ($archive_flag)? 
      $this->table_logs_archived :
      $this->table_logs;
    if( !$archive_flag ) {
      $attachments = $this->get_attachments($id, $flag);
      if( is_array($attachments) ) {
        foreach($attachments as $a) {
          $att[] = $a["attachment_id"];
        }
        $this->delete_attachment($att);
      }  
    }
    $query = "DELETE FROM $table WHERE $where";
    return( $this->db_result($query) );
  }

  function add_attachment( $name, $filename, $filetype, 
                           $ticket_id, $log_id = 0, $description = '' ) {
    // adds an attachment to the db for tracking
    // does not add the actual file, just it's associations
    // with logs and tickets, log_id is optional, the ticket_id is not
    // filetype represents the complete mime type as will be used
    // to supply the file back to the user when requested

    if( !$ticket_id ) {
      $log = $this->get_log($log_id);
      $ticket_id = $log["ticket_id"];
    }
    $params = array(
                    "log_id"       => $log_id,
                    "ticket_id"    => $ticket_id,
                    "name"        => $name,
                    "filename"    => $filename,
                    "filetype"    => $filetype
                    );
    if( $description )
      $params["description"] = $description;
    $table = $this->table_attachments;
    return( $this->db_insert($table,$params) );
  }

  function delete_attachment( $access_id ) { 
    // deletes attachments by attachment_id
    // can be an array

    if( !is_array($access_id) )
      $access_id = array($access_id);
    for( $i=0; $i<count($access_id); $i++ ) {
      $att = $this->get_attachment($access_id[$i]);
      $file = $this->attachmentDir."/$att[name]";
      unlink($file);   
    }
    $query = "DELETE FROM ".$this->table_attachments
      ." WHERE attachment_id IN(".join(",",$id).")";
    return( $this->db_result($query) );
  }

  function delete_all_attachments( $id ) {
    // deletes all attachments by their log_id
    // $id can be an array

    if( !is_array($id) )
      $id = array($id);
    foreach($id as $i) {
      $att = $this->get_attachments($i, $flag);
      for( $i=0; $i<count($att); $i++ ) {
        $access_id[] = $att["attachment_id"];
      }
    }
    return( $this->deleteAttachment($access_id) );
  }


  /*
   *  USER ADMINISTRATION
   */

  function check_user_login( $login ) {
    // check for duplicate login names
    $query = "SELECT user_id FROM ".$this->table_users." WHERE login = '$login'";
    return $this->db_get($query);
  }

  function check_user_id( $user_id ) {
    // check to make sure a user_id appears
    // in the database
    $query = "SELECT count(*) FROM ".$this->table_users
      ." WHERE user_id = $user_id";
    return( $this->db_get($query) > 0 );
  }

  function add_user( $params ) {
    // creates a new user entry in the db
    // if $params["access"] is an array
    // then it will also run add_access()
    // with this array once the user has
    // been created
    // if ["passphrase"] is given, it should
    // be the unencrypted value.. if blank,
    // ["passphrase"] will be set automatically
    // to the users last name until that user
    // logs into the system and changes it

    if( isset($params["access"]) ) {
      $access = $params["access"];
      unset($params["access"]);
    }
    $params["passphrase"] = ($params["passphrase"])?
      $this->encval($params["passphrase"]) : $this->encval($params["lname"]);
    $table = $this->table_users;
    $id = $this->db_insert($table, $params);
    if( $id ) {
      if( is_array($access_level) )
        $this->add_access($id, $access_level);
      return($id);
    }
  }

  function delete_user( $user_id ) {
    // deletes a user from the db by the
    // user's id.  also deletes all access
    // and prefs entries for this user
    // $user_id can be an array

    $where = (is_array($user_id))? " user_id IN(".join(",",$user_id).")" : " user_id = $user_id";
    $query = "DELETE FROM ".$this->table_users." WHERE $where";
    $this->addDebug("delete_user()Query",$query,2);
    $this->delete_access($user_id);
    return( $this->db_result($query) );
  }

  function update_user( $user_id, $params ) {
    // updates user settings by user_id
    // do not encrypt the passphrase, this is done
    // automatically

    if( $user["login"] == "egate" ) {
      // don't allow password entry for the egate account
      $params["passphrase"] = 'NULL';
    }
    else if( $params["passphrase"] ) {
      // encrypt the password
      $params["passphrase"] = $this->encval($params["passphrase"]);
    }
    foreach($params as $k=>$v) {
      if( !strlen($v) ) {
	if( $k == "active" )
	  $params["$k"] = 1;
	else
	  $params["$k"] = "NULL";
      }
    }
    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_users." SET $set WHERE user_id = $user_id";
    $this->addDebug("update_user()Query",$query,2);
    return( $this->db_result($query) );
  }

  function add_access( $user_id, $params ) {
    // adds new access parameters for the 
    // given user, ignores ones that 
    // currently exist for that user
    // $params is an indexed array containing:
    //   "bin_id" => level (integer)

    foreach($params as $k=>$v) {
      if( !strlen($v[0]) )
	$v[0] = 'NULL';
      if( !strlen($v[1]) )
	$v[1] = 'NULL';
      else
	$v[1] = "$v[1]";
      $arr = array( "user_id"=>$user_id,
		    "bin_id"=>$k,
		    "lvl"=>$v[0],
		    "notes"=>$v[1] );
      $res = $this->db_insert($this->table_access,$arr);
      if( $res )
	$i++;
    }
    return($i);
  }

  function update_access( $user_id, $params ) {
    // deletes the users old access privileges 
    // and replaces them with the ones given in 
    // $params, $user_id is the user_id

    $this->delete_access( $user_id );
    return( $this->add_access($user_id, $params) );
  }

  function delete_access( $id, $flag = '' ) {
    // deletes access privedges based on $flag
    //   NULL - by user_id
    //   1    - by bin_id
    //   2    - by access_id
    // $id can be an array

    if( $flag == 1 )
      $field = "bin_id";
    else if( $flag == 2 )
      $field = "access_id";
    else
      $field = "user_id";
    $where = (is_array($id))?
      " $field IN(".join(",",$id).")" :
      " $field = $id";      
    $query = "DELETE FROM ".$this->table_access." WHERE $where";
    $this->addDebug("delete_access()Query",$query,2);
    return( $this->db_result($query) );
  }

  function get_prefs( $user_id, $pref = '' ) {
    $query = "SELECT * FROM ".$this->table_preferences
      ." WHERE user_id = $user_id";
    if( $pref ) {
      $query .= " AND prefname = '$prefname'";
    }
    $vals = array();
    $vars = $this->db_queryIndexed($query);
    if( is_array($vars) ) {
      foreach($vars as $v) {
	$n = $v["prefname"];
	$vals["$n"] = $v["prefval"];
      }
    }
    return $vals;
  }

  function update_prefs( $user_id, $params, $prefname = '' ) {
    $this->delete_prefs($user_id, $prefname);
    return $this->add_prefs($user_id,$params);
  }

  function add_prefs( $user_id, $params ) {
    // adds prefs for a user_id
    
    $i = 0;
    foreach($params as $p) {
      $vars = array("user_id"=>$user_id);
      foreach($p as $k=>$v) {
	$vars["prefname"] = $k;
	$vars["prefval"] = strlen($v)? $v : "NULL";
      }
      list($cols,$vals) = $this->makeInsertVals($vars);
      $query = "INSERT INTO ".$this->table_preferences
	." ($cols) values($vals)";
      $res = $this->db_result($query);
      if( $res ) {
	$i++;
      }
      $this->addDebug("add_prefs","$res/$query",3);
    }
    return( $i );
  }

  function delete_prefs( $user_id, $prefname = '' ) {
    // deletes prefs entries by user_id
    // user_id can be an array      
    $query = "DELETE FROM ".$this->table_preferences." WHERE user_id = $user_id";
    if( $prefname ) {
      $query .= " AND prefname = '$prefname'";
    }
    $res = $this->db_result($query);
    $this->addDebug("delete_prefs","$res/$query",3);
    return( $res );
  }

  function reset_password( $user_id ) {
    // resets the users passphrase to the default value
    // for a user.  This will probably be the users last name
    // note that the password cannot be changed
    // for the egate account (to prevent users logging in as
    // egate
    $user = $this->get_user($user_id);
    $params["passphrase"] = $user["lname"];
    return $this->update_user($user_id, $params);
  }


  /*
   *  SYSTEM ADMINISTRATION
   */


  function add_bin( $params ) {
    // add a new bin to the bins table
    return( $this->db_insert( $this->table_bins, $params ) );
  }

  function add_priority( $params ) {
    // add a new priorty
    return( $this->db_insert( $this->table_priorities, $params ) );
  }

  function add_setting( $params ) {
    // add a new setting into the db
    return( $this->db_insert($this->table_settings, $params) );
  }

  function add_system( $params ) {
    // add a new system to the db
    return( $this->db_insert( $this->table_systems, $params ) );      
  }

  function add_task( $params ) {
    // add a new task to the system
    return( $this->db_insert( $this->table_tasks, $params) );
  }

  function add_type( $params ) {
    // add a new ticket type
    return( $this->db_insert($this->table_types, $params) );
  }

  function update_custom_field_idx( $field_name, $params ) {
    // update properties for a given custom_field definition (key= field_name)
    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_varfield_idx." SET $set WHERE field_name = '$field_name'";
    $this->addDebug("update_custom_field_idx()Query",$query,2);
    return( $this->db_result($query) );
  }

  function update_bin( $bid, $params ) {
    // update properties for a given bid (bin id)
    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_bins." SET $set WHERE bid = $bid";
    $this->addDebug("update_bin()Query",$query,2);
    return( $this->db_result($query) );
  }

  function update_priority( $pid, $params ) {
    // update properties for a given priority

    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_priorities." SET $set WHERE pid = $pid";
    $this->addDebug("update_priority()Query",$query,2);
    return( $this->db_result($query) );
  }

  function update_setting( $setting_id, $params ) {
    // update a setting based on it's setting_id

    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_settings." SET $set WHERE setting_id = $setting_id";
    $this->addDebug("update_setting()Query",$query,2);
    return( $this->db_result($query) );
  }

  function update_system( $sid, $params ) {
    // update settings for a given 
    // sid (system_id)

    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_systems." SET $set WHERE sid = $sid";
    $this->addDebug("update_system()Query",$query,2);
    return( $this->db_result($query) );      
  }

  function update_task( $task_id, $params ) {
    // update a ticket task by task_id

    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_tasks." SET $set WHERE task_id = $task_id";
    $this->addDebug("update_task()Query",$query,2);
    return( $this->db_result($query) );            
  }

  function update_type( $type_id, $params ) {
    // update a ticket type by the type_id

    $set = $this->makeInsertVals($params,1);
    $query = "UPDATE ".$this->table_types." SET $set WHERE type_id = $type_id";
    $this->addDebug("update_type()Query",$query,2);
    return( $this->db_result($query) );            
  }


  /*
   *  ACCESS UTILITIES
   */


  function login_user( $username, $passphrase ) {
    // perform a login check for username and passphrase
    // returns the user's user_id

    $query = "select user_id from ".$this->table_users
      ." where login = '$username' and passphrase = '".$this->encval($passphrase)."' and active > 0";
    $user_id = $this->db_get($query);
    $this->addDebug("zentrack.class:login_user($user_id)",$query,2);
    if( $user_id )
      $this->getUser($user_id);
    return($user_id);
  }

  function check_bin_access( $user_id, $bin_id, $level = 1 ) {
    // check the user's access priviledges for the given bin_id
    // based on the users user_id. and $level (returns true
    // if equal to or greater than this)

    $access =  $this->getAccess( $user_id );
    return( ($access["$bin_id"] >= $level) );
  }

  /*
   *  TOOLS 
   */   

  /**
   * insures that members are included in a recipient list
   *
   * @param array $recipients the list to be added to
   * @param array $vals an array of email addresses, or a single email address to check
   * @return array complete list
   */
  function checkIncludedRecipients( &$recipients, $vals ) {
    if( !is_array($recipients) && $vals ) {
      $recipients = (is_array($vals))? $vals : array($vals);
    }
    else if( is_array($vals) ) {
      foreach($vals as $v) {
        if( !in_array($v,$recipients) ) {
          $recipients[] = $v;
        }
      }
    }
    else if( $vals ) {
      if( !in_array($vals,$recipients) ) {
        $recipients[] = $vals;
      }
    }
  }

  function check_status( $id, $code = 'OPEN' ) {
    // checks to see if a ticket is ready for the 
    // given action, the $code codes are:
    //    OPEN    - is open?
    //    PEND    - is pending?
    //    TEST    - ready for testing?
    //    APPR    - ready for approval?
    //    READY   - ready for closing?
    //    CLOSED  - is closed?
    // returns 1 if $code can be met
    $c = strtoupper(substr($code,0,2));
    if( is_array($id) ) {
      $ticket = $id;
    } else {
      $ticket = $this->get_ticket($id);
    }
    if( $c == 'OP' ) {
      return( $ticket["status"] == 'OPEN' );
    } else if( $c == 'PE' ) {
      return( $ticket["status"] == 'PENDING' );
    } else if( $c == 'TE' ) {
      return( $ticket["status"] == 'PENDING' && ($ticket["tested"] == 1) );
    } else if( $c == 'AP' ) {
      return( $ticket["status"] == 'PENDING' && $ticket["tested"] != 1 );
    } else if( $c == 'RE' ) {
      return( ($ticket["status"] == 'PENDING' && $ticket["tested"] != 1 
               && $ticket["approved"] != 1)
              ||
              ($ticket["status"] == 'OPEN' && $ticket["tested"] == 0 
               && $ticket["approved"] == 0));
    } else if( $c == 'CL' ) {
      return( $ticket["status"] == 'CLOSED' );
    }
  }   

  function get_bin_roles( $bin_id, $role = '') {
    // Pending further testing, this function simply acts as a pass-through to
    // fetch_bin_roles()
    
    $result = $this->fetch_bin_roles($bin_id, $role);
    
    return ($result);
  }

  function fetch_bin_role_emails( $bin_id, $role = '' ) {
    $vars = array();
    $vals = $this->fetch_bin_roles($bin_id, $role, 'email');
    if( is_array($vals) ) {
      foreach($vals as $v) {
	$user = $this->get_user($v["user_id"]);
	$vars[] = $user["email"];
      }
    }
    return $vars;
  }
  
  function fetch_bin_roles( $bin_id, $role = '' ) {
    // fetches members of bin with a particular
    // role.  If $role is given, fetches only
    // members listed as fulfilling that particular
    // role. Returns the user_id and their role in an
    // indexed array

    // check the role id
    if( preg_match("@[^0-9]@", $role) ) {
      $role = $this->getRoleID($role);
    }
    // set up the query parameters
    $where = " bin_id = $bin_id";
    if( $role ) {
      $where .= " AND notes = '$role' ";
    }
    else {
      $where .= " AND notes IS NOT NULL ";
    }
    // set the fields to retrieve
    $fields = ($role)? " user_id " : " user_id, notes ";
    
    // run the query
    $query = "SELECT $fields FROM ".$this->table_access
      ." WHERE $where";
    $vals = $this->db_queryIndexed($query);
    $this->addDebug("fetch_bin_roles","result: ".count($vals)
                    .", query: $query",3);
    return( $vals );
  }

  function fetch_user_roles( $user_id, $bin_id = '' ) {
    // fetches a specific user's roles in zenTrack
    // if bin_id is given, returns only roles for that specific bin
    // returns the bin_id and role in an indexed array

    $where = ($bin_id)? " user_id = $user_id AND bin_id = $bin_id " : 
      " user_id = $user_id ";
    $query = "SELECT bin_id, notes FROM "
      .$this->table_access." WHERE $where"
      ." AND (notes IS NOT NULL) ";
    $vals = $this->db_queryIndexed($query);
    // remove inactive bins
    $bins = $this->getBins();
    for($i=0; $i<count($vals); $i++) {
      $n = $vals[$i]['bin_id'];
      if( !isset($bins["$n"]) ) { unset($vals[$i]); }
    }
    $this->addDebug("fetch_user_roles","result: ".count($vals)
                    .", query: $query",3);
    return( $vals );
  }

  function format_name( $user_id, $flag = '' ) {
    // alias for formatName()      
    return($this->formatName($user_id, $flag));
  }

  function formatName( $user_id, $flag = '' ) {
    // if the user properties are available, pass those here
    // otherwise pass the user id, and he/she will be retrieved
    // from the db (user properties can be passed as an array in
    // place of $id)
    // if $flag = 2, then returns "initials"
    // if $flag = 1, then returns "lname, fname"
    // if !$flag, then returns "fname lname"

    if( is_array($user_id) )
      $user = $user_id;
    else
      $user = $this->get_user($user_id);

    if( !is_array($user) )
      return( "n/a" );
    if( $flag == 2 )
      return( $user["initials"] );
    else if( $flag == 1 )
      return( $user["lname"].", ".$user["fname"] );
    else
      return( $user["fname"]." ".$user["lname"] );
  }

  function percentWorked( $etc = 0, $wkd = 0 ) {
    // determines the percent completion for this
    // project
    if( $etc > 0 ) {
      return( round($wkd/$etc*100,1) );
    }
  }   

  function formatEmailMessage( $params ) {
    // takes a list of input parameters and makes
    // a formatted message to be sent, including links 
    // and information about the ticket referenced
    // special params:
    //     message - printed at the top of the email with
    //               line breaks afterwards
    //     body    - printed with extra line breaks
    //     tid     - retrieves the ticket by this id and 
    //               includes it in the email body
    //     log     - retrieves log entries for this ticket
    //               by the id given by log, limited by the
    //               system setting email_max_logs
    //     link    - displays a link to the ticket
    //               (this is done with the tid property too,
    //                use this one instead of tid to display
    //                the link only)
    // all others are printed as is, with html stripped

    if( $params["message"] ) {
      // insure the message gets printed first
      $message = $params["message"]."\n\n";
      unset($params["message"]);
    }

    // loop through the parameters and print them
    foreach( $params as $k=>$v ) {
      if( $k == 'body' ) {
        // include the body of the message
        $message .= "\n\n$v\n\n";
      } else if( $k == 'link' ) {
        $message .= $this->settings["url_view_ticket"]."?id=$v";       
      } else if( $k == 'tid' ) {
        // print a summary of the ticket
        $message .= "\n\n--- ".strtoupper($this->trans("Ticket Summary"))." ---\n\n";
        if( !is_array($ticket) ) {
          // if we passed the ticket
          // then use it
          if( is_array($v) ) {
            $ticket = $v;
            $v = $ticket["id"];
          }
          // otherwise, retrieve it by the id
          else {
            $ticket = $this->get_ticket($v);
          }
        }
        $url = $this->settings["url_view_ticket"]."?id=$v";
        $n = $ticket["bin_id"];
        $u = $ticket["user_id"];
        $s = $ticket["system_id"];
        if( $ticket["user_id"] ) {
          $name = $this->formatName($ticket["user_id"]);
        } else {
          $name = "n/a";
        }
        
        $des = preg_replace("#&quot;#",'"',
                            preg_replace("#&amp;#","&",$ticket["description"]));
        $des = preg_replace("@<br( /)?>@", "", $des);

        // Create message template
        $msg = new zenTemplate($this->templateDir."/email/ticket_summary.template");
        
        // Set variables for message
        unset($vars);
        $vars["title"] = $ticket["title"];
        $vars["id"] = $ticket["id"];
        $vars["type"] = $this->getTypeName($ticket["type_id"]);
        $vars["priority"] = $this->priorities[$ticket["priority"]];
        $vars["status"] = $ticket["status"];
        $vars["deadline"] = $this->showDate($ticket["deadline"]);
        $vars["bin"] = $this->bins[$n];
        $vars["owner"] = $name;
        $vars["url"] = $url;
        $vars["desc"] = $des;
        
        // Process the template
        $msg->values($vars);
        
        $message .= $msg->process();
      } else if( $k == "log" ) {
        // print the log for the ticket
        if( $this->settings["email_max_logs"] )
          $lim = $this->settings["email_max_logs"];
        $logs = $this->get_logs($v, 'created DESC', $lim);
        $message .= "\n\n";
        if( is_array($logs) ) {
          $att = $this->get_attachments($v,null,1);
          $message .= "\n".strtoupper($this->trans("Log History"))."\n------------------\n";
          $sep = "--";
          foreach( $logs as $l ) {
             // Create log entry template
             $logentry = new zenTemplate($this->templateDir."/email/ticket_log.template");
             
             // Set the variables for the log entry
             unset ($vars);
             $vars["date"] = $this->showDateTime($l["created"],'M');
             $vars["action"] = $sep.str_pad($l["action"],8,"-",STR_PAD_LEFT);
             $vars["user_initials"] = $sep.str_pad($this->formatName($l["user_id"],2),
                                      6,"-",STR_PAD_LEFT);
             $vars["hours"] = (strlen($l["hours"]))? 
                              $sep.str_pad($l["hours"],4,"-",STR_PAD_LEFT)." hrs":"";
             
             //
             // the log and attachments
             if( $l["entry"] ) {
                $log["entry"] = "\n".stripslashes($l["entry"])."\n";
                $log["entry"] = preg_replace("#&amp;#", "&", $log["entry"]);
                $log["entry"] = preg_replace("#&quot;#", '"', $log["entry"]);
                $l["entry"] = preg_replace("@<br( /)?>@", "", $log["entry"]);
                $vars["log"] = $l["entry"];
             }
             
             // Process the template and add it to the message.
             $logentry->values($vars);
             $message .= $logentry->process();
             
             // Add attachments to the message.
             if( $att["$id"]["$lid"] ) {
                $message .= "\n".strtoupper($this->trans("Attachments") . '').":\n";
                foreach( $att["$id"]["$lid"] as $a ) {
                   $message .= "$a[name] ($a[description])\n";
                   $message .= "\t".$this->attachmentUrl."?file=$a[filename]\n";
                }
             }
          }
          if( $v > 0 && count($logs) == $v ) {
            $message .= "\n".$this->trans("There are more log entries.")
              .$this->trans("Please log in to view the entire ticket.")."\n";
            if( !$params["tid"] && !$params["link"] ) {
              $message .= $this->settings["url_view_ticket"]."?id=$v";
            }
          }
        } else {
          $message .= $this->trans("No logs found")."\n";
        }
        $message .= "\n";          
      } else {
	// just print whatever is indexed, since it didn't
	// match any special settings
	$v = strip_tags($v);
	$message .= "$k:\t$v\n";
      }
    }

    return($message);
  }

  function sendEmail( $recipients, $subject, $message, 
                      $sender = '', $cc = '' ) {
    // send email updates to $recipients
    // $recipients and $sender are the user_id of the sender and recipient
    // alternately, $recipients can contain valid email addresses rather 
    // than a user_id value (to send to non-zentrack users)
    // $recipients, $sender, and $cc can all be an array

    // grab the egate account
    $egate_email = "";
    $egate_user = $this->get_user_by_login("egate");
    if( is_array($egate_user) ) {
      $egate_email = $egate_user["email"];
    }

    // add the obligatory email stuff
    $subject = "[".$this->settings["bot_name"]."] ".$subject;

    // figure out who sent it
    $message = (get_magic_quotes_gpc())? stripslashes($message) : $message;
    $message = preg_replace(
                            array("#&lt;#", "#&gt;#", "#&quot;#", "#&amp;#"),
                            array("<",">",'"',"&"),
                            $message);
    if( !$sender ) {
      $sender_address = $this->settings["admin_email"];
    } else {
      if( eregi("^[0-9]+$", $sender) ) {
	$s = $this->get_user($sender);
	$sender_address = $s["email"];
      } else {
	$sender_address = $sender;
      }
    }

    // figure out who it is being set to
    if( !is_array($recipients) )
      $recipients = array($recipients);
    foreach($recipients as $r) {      
      if( strlen($r) ) {
        if( $recipient_address )
          $recipient_address .= ", ";
        if( eregi("^[0-9]+$", $r) ) {
          $s = $this->get_user($r);
          if( $s["email"] && $s["email"] != $egate_email ) {
            $recipient_address .= $s["email"];
          }
        } else {
          if( $r != $egate_email )
            $recipient_address .= $r;
        }
      }
    }
    
    if( strlen($recipient_address) ) {
      // create headers and CC fields
      $headers .= "From: $sender_address\n";
      if( $cc ) {
	if( !is_array($cc) )
	  $cc = array($cc);
	foreach($cc as $c) {
	  if( $cc_address )
	    $cc_address .= ", ";
	  if( eregi("^[0-9]+$", $c) ) {
	    $s = $this->get_user($c);
	    $cc_address .= $s["email"];
	  } else {
	    $cc_address .= $c;
	  }
	}
	$headers .= "cc: $cc_address\n";
      }
      
      if( $this->settings["email_interface_enabled"] == "on" ) {
        // set reply address to egate user        
        $s = $egate_user;
        if( !is_array($s) ) {
          $this->addDebug("sendEmail", "Egate login not found!",1);
          $message = (get_magic_quotes_gpc())? $message : addslashes($message);
        }
        else {
          $sender = $s["email"];

          // load the header and footer
          $hd_tmp = new zenTemplate($this->templateDir."/email/heading.template");
          $ft_tmp = new zenTemplate($this->templateDir."/email/footer.template");
          // try to find the id
          if( preg_match("/ticket #?([0-9]+)/i",$subject,$mt) ) {
            $id = $mt[1];
          }
          else {
            $id = "nnnn";
          }
          $ft_tmp->values(array("id"=>$id));
          // finalize and send the message
          $message = (get_magic_quotes_gpc())? $message : addslashes($message);
          $message = $hd_tmp->process().$message.$ft_tmp->process();
        }
      }
      else {
	$message = (get_magic_quotes_gpc())? $message : addslashes($message);
      }
      $subject = (get_magic_quotes_gpc())? $subject : addslashes($subject);
      if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
        $headers = str_replace("\n", "\r\n", $headers);
      }
      $this->addDebug("sendEmail","$recipient_address::$subject::$headers",3);
      return( mail( $recipient_address, $subject, $message, $headers ) );
    } else {
      $this->addDebug("sendEmail","recipient_address was blank... "
		      ."this could be that the email was sent to a user "
		      ."who doesn't have an email address",2);
    }
  }
  
  function getTicketCount( $status = '', $bin_id = '' ) {
    // counts the number of tickets matching
    // bin_id and status (if provided) and returns
    // the total

    // figure out the where clause
    if( $bin_id && $status ) {
      $where = " WHERE bin_id = $bin_id AND status = '$status' ";
    } else if( $bin_id ) {
      $where = " WHERE bin_id = $bin_id ";
    } else if( $status ) {
      $where = " WHERE status = '$status' ";
    }
    // prepare and execute the select
    $query = "SELECT COUNT(id) FROM ".$this->table_tickets." $where";
    return( $this->db_get($query) );
  }


  /*
   *  DATE TRANSLATION UTILITIES
   */

  function showLongDate($utime = '') {
    // displays a long date format
    if( !$utime )
      $utime = time();
    return strftime($this->date_fmt_long,$utime);
  }

  function showDate( $utime = '') {
    // displays a short date and time
    if( !$utime )
      $utime = time();
    return strftime($this->date_fmt_short,$utime);
  }

  function showDateTime( $utime = '' ) {
    // displays a short date with time
    if( !$utime )
      $utime = time();
    return strftime($this->date_and_time,$utime);
  }

  function showTime( $utime = '' ) {
    if( !$utime )
      $utime = time();
    return strftime($this->time_fmt,$utime);
  }

  function showTimeElapsed($start,$end,$round=1,$units=1) {
    // shows the elapsed time rounded to $round decimals
    // and the units abbreviated to $substr length
    // if $units is 0, shows whole name
    // if $units is null, skips unit name
    // if $units is > 0, abbreviate units
    $num = round($this->dateDiff($end,$start,$this->elapsed_unit),$round);
    $abr = "";
    if( $units > 0 ) {
      $abr = " "
        .substr(preg_replace("@[aeiou]@", "", $this->elapsed_unit),0,2)
        ."s.";
    } else if( strlen($units) ) {
      $abr = " ".$this->elapsed_unit;
    }
    return "$num$abr";    
  }


  /*
   *  SYSTEM UTILS 
   */

  function getDataTypeLabel( $table, $vals ) {
    // be careful using this, it's still limited
    // $vals is a data row from the data type table
    // this returns a formatted string representing the
    // name of this row: i.e. for users, last_name, first_name
    // and for bins, the name field
    switch( strtoupper($table) ) {
    case "ZENTRACK_BINS":
    case "ZENTRACK_PRIORITIES":
    case "ZENTRACK_SYSTEMS":
    case "ZENTRACK_TASKS":
    case "ZENTRACK_TYPES":
      return $vals['name'];
    case "ZENTRACK_USERS":
      return $this->formatName($vals);
    }
    return null;
  }

  functiong getDataTypeSort( $table ) {
    // be careful using this, it's still limited
    switch( strtoupper($table) ) {
    case "ZENTRACK_BINS":
    case "ZENTRACK_PRIORITIES":
    case "ZENTRACK_SYSTEMS":
    case "ZENTRACK_TASKS":
    case "ZENTRACK_TYPES":
      return "priority";
    case "ZENTRACK_USERS":
      return "last_name, first_name";
    }
    return null;
  }

  function getDataTypeId( $table ) {
    // be careful using this, it's still limited
    switch( strtoupper($table) ) {
    case "ZENTRACK_BINS":
      return "bid";
    case "ZENTRACK_PRIORITIES":
      return "pid";
    case "ZENTRACK_SYSTEMS":
      return "sid";
    case "ZENTRACK_TASKS":
      return "task_id";
    case "ZENTRACK_TYPES":
      return "type_id";
    case "ZENTRACK_USERS":
      return "user_id";
    }
    return null;
  }

  function get_report_id( $n ) {
    // this function needs help
    // don't use it for anything except reports
    // needs to be fixed up
    // and made dynamic... right now
    // it's just a quick hack to prevent 
    // a horrible fix later
    $n = strtolower($n);
    $n = preg_replace("@s$@", "", $n);
    $n = preg_replace("@^zentrack_?@", "", $n);
    $names = array( "project"    => "id",
                    "ticket"     => "id",
                    "system"     => "sid",
                    "type"       => "type_id",
                    "user"       => "user_id",
                    "bin"        => "bid",
                    "setting"    => "setting_id",
                    "log"        => "lid",
                    "attachment" => "attachment_id");
    return $names["$n"];
  }

  function getUser( $user_id ) {
    // retrieves the user who is logged in 
    // to zenTrack.  This function prevents 
    // multiple queries to retrieve user info
    // on a single page by checking the stored
    // user information and validating the user_id
    // first.
    // 
    // Do not use this function for any data other
    // than that of the logged in system user

    if( !$this->user || $this->user["user_id"] != $user_id ) {
      $this->user = $this->get_user($user_id);
    }
    return( $this->user );
  }

  function getAccess( $user_id ) {
    if( !$this->access || $this->access["user_id"] != $user_id ) {
      $this->access = $this->get_access($user_id);
      $this->access["user_id"] = $user_id;
    }
    return( $this->access );
  }

  function getUsersBins( $user_id, $level = "level_view" ) {
    // gets the users bins, compares those to the
    // settings required to access $this->bins and 
    // then checks against the users default level to
    // return a simple list of binIDs that this user
    // has access to
    // $user_id is the user's id
    // $level is the access level to meet
    // (i.e. could be set to level_user to only
    // retrieve bins this user_id is a "user" for,
    // defaults to level_view)
    // this function caches results for efficiency, so repeating
    // calls for the same user will not result slow the system

    $access = $this->getAccess($user_id);
    $user   = $this->getUser($user_id);
    if( is_array($this->bins) ) {
      foreach($this->getBins() as $k=>$v) {
        if( $k ) {
          if( strlen($access["$k"]) ) {
            if( $access["$k"] >= $this->settings["$level"] ) {
              $vars[] = $k;
            }
          } else {
            if( $user["access_level"] >= $this->settings["$level"] ) {
              $vars[] = $k;
            }
          }
        }
      }
    }
    $adp = (is_array($vars))? 
      join(",",$vars) : "-none-";
    $this->addDebug("getUsersBins()results",$adp,3);
    return $vars;
  }
  
  function checkCreator( $user_id, $ticket_id ) {
    // checks to see if the $user is the creator the ticket
    // they have special priviledges
    if( !$this->settings["allow_cview"] )
      return false;
    $ticket = $this->get_ticket($ticket_id);
    return( $user_id == $ticket["creator_id"] );
  }

  function checkAccess( $user_id, $bin_id, $action = '' ) {
    // takes the user_id, the bin_id and the action in
    // question, and determines whether the logged in
    // user can perform it

    // get a list of actions
    $actions = $this->getActions();
    // make sure our action is in the list
    if( isset($actions["$action"]) ) {
      $level = $actions["$action"]["level"];
    }
    else {
      // return the default level
      $level = (preg_match("@^level_@", $action) && $this->settings["$action"])? 
        $this->settings["$action"] : $this->settings["level_view"];
    }
    // find out what access our user has
    $access = $this->getAccess($user_id);
    // if they have a bin specific access check that
    if( strlen($access["$bin_id"]) ) {
      return( $access["$bin_id"] >= $level );
    } 
    // otherwise just check against their default access
    else {
      $user = $this->getUser($user_id);
      return( $user["access_level"] >= $level );
    }
  }

  function actionApplicable( $id, $action, $user_id = '', $noaccess = 0 ) {
    // check to see if an action is applicable to
    // the current ticket, based on it's status, the
    // logged in users access, and the actions requirements
    // if an array is sent in place of the ticket id, it will
    // be used as the tickets parameters (saving a db lookup)
    // $noaccess can be used to override the access requirements
    // for the action (in the case of email interface)

    // get a list of actions
    $actions = $this->getActions();
    $action = strtolower($action);

    // look at the settings to make sure
    // this action is on
    //todo: when we move to action sets
    // this should check the enabled field
    // for the action instead
    $n = "allow_$action";
    if( $this->settings["$n"] && $this->settings["$n"] != "on" )
      return false;

    // get the action's properties
    $c = $actions["$action"];
    // return an error if this fails
    if( !$c ) {
      $this->addDebug("actionApplicable",
                      "The action $action doesn't exist!",1);
      return false;
    }
    // check for an access override
    if( $noaccess )
      $c["access"] = 0;

    // get the ticket's properties
    if( is_array($id) ) {
      // if it's already an array, we must
      // have passed the whole thing instead of
      // the array, so don't fetch it
      $ticket = $id;
      $id = $ticket["id"];
      $bin_id = $ticket["bin_id"];
    } else { 
      // query for properties
      $ticket = $this->get_ticket($id);
      $bin_id = $ticket["bin_id"];
    }

    // check to see if we meet ownership requirements
    if( $c["owner"] == 2 ) {
      // here we must not be the owner
      if( $ticket["user_id"] == $user_id )
        return false;
    } else if( $c["owner"] == 3 ) {
      // here there must be no owner
      if( $ticket["user_id"] )
        return false;
    } else if( $c["owner"] == 4 ) {
      // here it must be owned and we must not be
      // the owner
      if( !$ticket["user_id"] || $ticket["user_id"] == $user_id )
        return false;
    } else if( $c["owner"] == 5 ) {
      // here we must be the owner, or it is unowned
      if( $ticket["user_id"] && $ticket["user_id"] != $user_id )
	return false;
    } else if( $c["owner"] > 0 ) {
      // here we must be the owner (or there is an override)
      // see if we can override this
      // if so, we need to find out if we are a super
      if( $c["override"] ) {
        $user = $this->get_user($user_id);
        $access = $this->getAccess($user_id);
      }
      // if we aren't the owner, check special conditions
      // then return false if not met
      if( $ticket["user_id"] != $user_id ) {
        if( !$c["override"] 
            || ( strlen($access["$bin_id"]) 
                 && $access["bin_id"] < $this->settings["level_super"] )
            || ( !strlen($access["$bin_id"]) 
                 && $user["access_level"] < $this->settings["level_super"])
            )
          return false;
      }
    }
    // check to see if there is an access requirement
    if( $c["access"] > 0 ) {
      if( !$this->checkAccess($user_id, $bin_id, $action) ) 
        return false;
    }
    // check to see if there is a status requirement
    if( is_array($c["status"]) ) {
      if( !in_array($ticket["status"],$c["status"]) )
        return false;
    }
    // special conditions if it's an approval
    if( $action == "approve" 
        && ($ticket["tested"] == 1 || $ticket["approved"] != 1) )
      return false;  // it needs testing first
    else if( $action == "reject" && !$this->getTicketSender($id) ) 
      return false;  // there's no one to reject to
    else if( $action == "test" && $ticket["tested"] != 1 )
      return false;  // ticket doesn't require testing

    // all checks passed, return true
    return true;
  }

  function listValidActions( $ticket_id, $user_id ) {
    // returns a complete list of actions which are valid for the given ticket
    // the entire ticket can be passed as an array in $ticket_id
    // to save an extra database lookup
    $actions = $this->getActions();
    $valid = array();
    foreach($actions as $k=>$v) {
      if( $this->actionApplicable($ticket_id,$k,$user_id) ) {
        $valid["$k"] = $v;
      }
    }
    return $valid;
  }

  /**
   ** returns a list of valid activities for logs
   **
   ** @return array of activities (strings)
   */
  function getActivities() {
    return array(
                 "ACTION",
                 "LABOR",
                 "NOTE",
                 "QUESTION",
                 "SOLUTION"
                 );
  }

  function getActions() {
    // actions array contains the following params
    //   "level"   - required access level to perform action 
    //   "owner"   - must be owner of ticket
    //                0 - false
    //                1 - true
    //                2 - must NOT be owner
    //                3 - must not be owned by anyone
    //                4 - must be owned, and must not be owner
    //                5 - must be owner, or not owned by anyone
    //   "access"   - must meet checkAccess
    //   "status"   - ticket status
    //   "override" - supervisor override?     
    // this array is sorted by key
    if( !$this->actions ) {
      $actions = array();
      $actions["accept"] = array( 
                                 "owner"    => 3, 
                                 "access"   => 1, 
                                 "status"   => array('OPEN'),
                                 "override" => 0,
                                 "egate"    => 1,
                                 "level"    => $this->settings["level_accept"]
                                 );
      $actions["approve"] = array( 
                                  "owner"    => 0, 
                                  "access"   => 1, 
                                  "status"   => array('PENDING'),
                                  "override" => 0,
                                  "egate"    => 1,
                                  "level"    => $this->settings["level_approve"]
                                  );
      $actions["assign"] = array(
                                 "owner"    => 5,
                                 "access"   => 1,
                                 "status"   => array('OPEN'),
                                 "override" => 0,
                                 "egate"    => 1,
                                 "level"    => $this->settings["level_assign"]
                                 );
      $actions["close"] = array(
                                "owner"    => 1,
                                "access"   => 1,
                                "status"   => array('OPEN'),
                                "override" => 0,
                                "egate"    => 1,
                                "level"    => $this->settings["level_user"]
                                );
      $actions["create"] = array(
                                 "owner"    => 0,
                                 "access"   => 1,
                                 "status"   => null,
                                 "override" => 0,
                                 "egate"    => 1,
                                 "level"    => $this->settings["level_create"]
                                 );
      $actions["edit"] = array(
                               "owner"    => 0,
                               "access"   => 1,
                               "status"   => array('OPEN','PENDING'),
                               "override" => 0,
                               "egate"    => 0,
                               "level"    => $this->settings["level_edit"]
                               );
      $actions["email"] = array(
                                "owner"    => 0,
                                "access"   => 1,
                                "status"   => null,
                                "override" => 0,
                                "egate"    => 1,
                                "level"    => $this->settings["level_view"]
                                );
      $actions["estimate"] = array(
                                   "owner"    => 1,
                                   "access"   => 1,
                                   "status"   => array('OPEN'),
                                   "override" => 1,
                                   "egate"    => 1,
                                   "level"    => $this->settings["level_user"]
                                   );
      $actions["log"] = array(
                              "owner"    => 0,
                              "access"   => 1,
                              "status"   => array('OPEN','PENDING'),
                              "override" => 1,
                              "egate"    => 1,
                              "level"    => $this->settings["level_user"]
                              );
      $actions["move"] = array(
                               "owner"    => 1,
                               "access"   => 1,
                               "status"   => array('OPEN','PENDING'),
                               "override" => 1,
                               "egate"    => 1,
                               "level"    => $this->settings["level_move"]
                               );
      // add an entry to notify list
      // used exclusively by egate system
      // use 'notify' for all permissions
      $actions["notify_add"] = array(
                                     "owner"    => 0,
                                     "access"   => 1,
                                     "status"   => array('OPEN','PENDING'),
                                     "override" => 0,
                                     "egate"    => 1,
                                     "level"    => $this->settings["level_view"]
                                     );
      // drop an entry from the notify list
      // used exclusively by the egate system
      // use 'notify' for all permissions
      $actions["notify_drop"] = array(
                                      "owner"    => 0,
                                      "access"   => 1,
                                      "status"   => array('OPEN','PENDING'),
                                      "override" => 0,
                                      "egate"    => 1,
                                      "level"    => $this->settings["level_view"]
                                      );
      // used to modify the list of recipients in
      // ticket's notify list
      $actions["notify"] = array(
                                 "owner"    => 1,
                                 "access"   => 1,
                                 "status"   => array('OPEN','PENDING'),
                                 "override" => 1,
                                 "egate"    => 0,
                                 "level"    => $this->settings["level_user"]
                                 );
      $actions["print"] = array(
                                "owner"    => 0,
                                "access"   => 1,
                                "status"   => null,
                                "override" => 0,
                                "egate"    => 0,
                                "level"    => $this->settings["level_view"]
                                );
      $actions["reject"] = array(
                                 "owner"    => 1,
                                 "access"   => 1,
                                 "status"   => array('OPEN','PENDING'),
                                 "override" => 0,
                                 "egate"    => 1,
                                 "level"    => $this->settings["level_user"]
                                 );
      $actions["relate"] = array(
                                 "owner"    => 0,
                                 "access"   => 1,
                                 "status"   => null,
                                 "override" => 0,
                                 "egate"    => 0,
                                 "level"    => $this->settings["level_user"]
                                 );
      $actions["reopen"] = array(
                                 "owner"    => 0,
                                 "access"   => 1,
                                 "status"   => array('PENDING','CLOSED'),
                                 "override" => 0,
                                 "egate"    => 0,
                                 "level"    => $this->settings["level_user"]
                                 );
      $actions["test"] = array(
                               "owner"    => 0,
                               "access"   => 1,
                               "status"   => array('PENDING'),
                               "override" => 0,
                               "egate"    => 1,
                               "level"    => $this->settings["level_test"]
                               );
      $actions["upload"] = array(
                                 "owner"    => 1,
                                 "access"   => 1,
                                 "status"   => null,
                                 "override" => 1,
                                 "egate"    => 0,
                                 "level"    => $this->settings["level_user"]
                                 );
      $actions["view"] = array(
                               "owner"    => 0,
                               "access"   => 1,
                               "status"   => null,
                               "override" => 0,
                               "egate"    => 1,
                               "level"    => $this->settings["level_view"]
                               );
      $actions["yank"] = array(
                               "owner"    => 4,
                               "access"   => 1,
                               "status"   => null,
                               "override" => 0,
                               "egate"    => 0,
                               "level"    => $this->settings["level_yank"]
                               );
      $this->actions = $actions;
    }
    return $this->actions;
  }   

  function getBinName($id) {
    // returns the name of a bin
    // from the given bin id
    $bins = $this->getBins(0,0);
    return( isset($bins["$id"])? $bins["$id"] : "" );
  }

  /**
   * returns information about custom fields definition
   *
   * Returns an array with information about custom fields definition
   * ordered by sort_order and field_label
   * 
   * The filterUse variable is used to filter for fields which apply only
   * to tickets or projects, and the filterShow variable is used to filter
   * for fields which only appear in certain areas (such as the search screen).
   *
   * @param int $indexedMode if set, returns the field_label indexed by field_name, otherwise all data is returned
   * @param string $filterUse "P"roject, "T"icket or blank
   * @param string $filterShow "S"earch, "L"ist, "C"ustom, "D"etail or blank
   * @return array of custom fields
   */
  function getCustomFields($indexedMode = 1, $filterUse = "", $filterShow = "") {
    // we create an associative array if $indexedMode, otherwise it is just a list 
    if ( $indexedMode ) {
      $query = "SELECT field_name, field_label FROM ".$this->table_varfield_idx; 
    }
    else { 
      $query = "SELECT * FROM ".$this->table_varfield_idx; 
    }

    // initialize connector, which will switch to 
    // AND after the first query parameter is added
    $connector = " WHERE ";

    // we filter based on whether this custom field is used
    // in tickets or projects
    switch ( strtoupper(substr($filterUse,0,1)) ) {
      case "P":
        $query .= $connector . "use_for_project=1";
        $connector = " AND ";
        break;
      case "T":
        $query .= $connector . "use_for_ticket=1";
        $connector = " AND ";
        break;
    }

    // we filter based on the location we are viewing the custom
    // field from, so that we only recieve fields which have been
    // configured to appear in this location
    switch ( strtoupper(substr($filterShow,0,1)) ) {
      case "S":
        $query .= $connector . "show_in_search=1";
        $connector = " AND ";
        break;
      case "L":
        $query .= $connector . "show_in_list=1";
        $connector = " AND ";
        break;
      case "C":
        $query .= $connector . "show_in_custom=1";
        $connector = " AND ";
        break;
      case "D":
        $query .= $connector . "show_in_detail=1";
        $connector = " AND ";
        break;
    }
    $query .= " ORDER BY sort_order, field_label";

    $this->addDebug("getCustomFields", $query, 3);
    
    if ( $indexedMode ) {
      $vals = array();
      $vars = $this->db_query($query);
      foreach ($vars as $v) {
        $vals["$v[0]"] = $v[1];
      }
      return( $vals );
    } 
    else {
      return( $this->db_queryIndexed($query) );
    }
  }

  /**
   * returns information about available bins
   *
   * if flag is set, retrieves a full
   * indexed array, otherwise, just
   * a list of names, indexed by bid,
   * ordered by priority and alphebetized 
   * set $active to zero to retrieve 
   * the bins which are disabled as well
   * the main reason for this method is that we will be updating
   * the structure of the settings before long to become more rigid.
   *
   * @param int $flag 1=return full info, 0=return bids and names
   * @param int $active 1=only active bins, 0=all bins
   * @return array of bins
   */
  function getBins($flag = 0,$active = 1) {
    if( !$flag ) {
      $query = "SELECT bid, name FROM ".$this->table_bins;
      if( $active )
        $query .= " WHERE active = $active";       
      $vars = $this->db_query($query);
      foreach($vars as $v) {
        $vals["$v[0]"] = $v[1];
      }
      return($vals);
    } else {
      $query = "SELECT * FROM ".$this->table_bins;
      if( $active )
        $query .= " WHERE active = $active";
      $query .= " ORDER BY priority DESC, name";
      return( $this->db_queryIndexed($query) );
    }
  }

  /**
   * returns whether a zen->settings["field"] is an On/Off type
   *
   * the main reason for this method is that we will be updating
   * the structure of the settings before long to become more rigid.
   *
   * @param string $field the name of field in settings
   * @return boolen yes or no
   */
  function isOnOffSetting( $field ) {
    return ($this->settings["$field"] == "on" || $this->settings["$field"] == "off");
  }

  /**
   * returns whether this field is a date format
   *
   * the main reason for this method is that we will be updating
   * the structure of the settings before long to become more rigid.
   *
   * @param string $field the name of field in settings
   * @return boolen yes or no
   */
  function isDateFormatSetting( $field ) {
    return ($field == "default_start_date" || $field == "default_deadline");
  }

  /**
   * returns default values for fields set in configuration settings
   *
   * @param string $field name of setting to check
   * @return string value to insert into form
   */
  function getDefaultValue( $field ) {
    if( $this->isDateFormatSetting($field) ) {
      // make a date
      $val = ($this->settings[$field])?
        strtotime($this->settings["$field"]) : "";
    }
    else if( $this->isOnOffSetting($field) ) {
      // tell whether its checked
      $val = ($this->settings["$field"] == "on")?
        " checked " : "";
    } else {
      // there isn't one, so return the actual value
      $val = $this->settings["$field"];
    }
    return $val;
  }

  function checkRelations( $relations, $id = '' ) {
    // takes either an array or comma delimited
    // string.  insures that the tickets to be 
    // related actually exist and returns only
    // the ids that are in db

    if( !is_array($relations) ) {
      $join = 1;
      $relations = ereg_replace("[^0-9,]", "", $relations);
      $relations = explode(",",$relations);
    }
    foreach($relations as $r) {
      if( !$id || ($id && $r != $id) ) {
        if( $this->get_ticket($r) ) {
          $vals[] = $r;
        }
      }
    }
    if( $join ) {
      return( join(",",$vals) );
    } else {
      return( $vals );
    }
  }

  function getRoleName($id) {
    // returns the name
    // for a given role id
    $roles = $this->getRoles();
    return $roles["$id"]["name"];
  }

  function getRoleID($name) {
    // returns the id for
    // a given role name
    $roles = $this->getRoles();
    foreach($roles as $k=>$v) {
      if( strtolower($v["name"]) == strtolower($name) )
        return $k;
    }
    $this->addDebug("getRoleID","role '$name' wasn't found!", 1);
  }

  function getRoles($active = 1) {
    // planning for the future
    // we will probably want to add these
    // to the database
    // to make them customizeable and
    // available for triggers and flowpaths
    return array(
                 "1"=>array("role_id"=>1,"name"=>"Manager"),
                 "2"=>array("role_id"=>2,"name"=>"Tester")
                 );
  }

  function getTasks($flag = 0,$active = 1) {
    // if flag is set, retrieves an
    // indexed array, otherwise, just
    // a list of names ordered by priority
    // and alphebetized      

    if( !$flag ) {
      $query = "SELECT task_id, name, priority FROM ".$this->table_tasks;
      if( $active )
        $query .= " WHERE active = $active";
      $vars = $this->db_query($query);
      if( is_array($vars) ) {
        foreach($vars as $v) {
          $vals["$v[0]"] = $v[1];
        }
      }
      return $vals;
    } else {
      $where = ($active)? " WHERE active = $active" : "";
      $query = "SELECT * FROM ".$this->table_tasks." $where ORDER BY priority DESC, name";
      return( $this->db_queryIndexed($query) );
    }
  }

  function getSystems($flag = 0,$active = 1) {
    // if flag is set, retrieves an
    // array, ordered by priority and
    // alphebatized, otherwise, just
    // an array of names indexed by id

    if( !$flag ) {
      $query = "SELECT sid, name FROM ".$this->table_systems;
      if( $active )
        $query .= " WHERE active = $active ORDER BY priority DESC, name";
      $vars = $this->db_query($query);
      if( is_array($vars) ) {
        foreach($vars as $v) {
          $vals["$v[0]"] = $v[1];
        }
      }
      return($vals);
    } else {
      $where = ($active)? " WHERE active = $active" : "";
      $query = "SELECT * FROM ".$this->table_systems." $where ORDER BY priority DESC, name";
      return( $this->db_queryIndexed($query) );
    }            
  }

  function getPriorities( $flag = 0, $active = 1 ) {
    // if flag is set, retrieves all
    // details in an unordered list
    // otherwise, retrieves an indexed
    // list sorted by priority

    if( !$flag ) {
      $query = "SELECT pid,priority,name FROM ".$this->table_priorities;
      if( $active )
        $query .= " WHERE active = $active";
      $vars = $this->db_query($query);
      for($i=0; $i<count($vars); $i++) {
        $p = $vars[$i][0];
        $vals["$p"] = $vars[$i][2];
      }
      return($vals);
    } else {
      $where = ($active)? " WHERE active = $active" : "";
      $query = "SELECT * FROM ".$this->table_priorities." $where ORDER BY priority DESC, name";
      return( $this->db_queryIndexed($query) );
    }            
  }

  function statusHighlight( $priority ) {
    // prints out status with proper <span>
    // tags to highlight critical status items

    if( $priority <= $this->settings["level_hot"] ) {
      $pri = "hot";
    } else if( $priority <= $this->settings["level_highlight"] ) {
      $pri = "highlight";
    } else {
      $pri = "";
    }
    return $pri;
  }

  function getSettings($flag = 0) {
    // pulls the variables from the settings table
    // into an indexed array.
    // if flag is set, then it retrieves all
    // data for the settings into an array
    // otherwise, just sets a string equal to the value
    global $rootUrl;        

    $fields = ($flag)? "*" : "name, value";
    if( $flag )
      $order = " ORDER BY name";
    else
      $order = "";
    $query = "SELECT $fields FROM ".$this->table_settings." $order";
    $vars = $this->db_queryIndexed($query);
    if( isset($rootUrl) && $rootUrl != "" ) {
      foreach($vars as $v) {
        if( preg_match("@^url_@",$v["name"]) ) {
          if(preg_match("@/$@", $rootUrl) && preg_match("@^/@", $v["value"]) ) {
            preg_replace("@/$@", $rootUrl) . $v["value"];
          } else if( !preg_match("@/$@", $rootUrl) 
                     && !preg_match("@^/@", $v["value"]) ) {
            $v["value"] = $rootUrl ."/".$v["value"];    
          } else {
            $v["value"] = $rootUrl . $v["value"];
          }
        }
        $vals["{$v['name']}"] = ($flag)? $v : $v["value"];
      }
      return($vals);
    }
  }

  function getTypeName($id) {
    // retrieves the name of the type
    // with the given id
    $types = $this->getTypes();
    return( (isset($types["$id"]))? $types["$id"] : "" );
  }

  function getTypes($flag = 0, $active = 1) {
    // if flag is not set, retrieves an
    // indexed array, otherwise, just
    // a list of names ordered by priority
    // and alphebetized

    if( !$flag ) {
      $query = "SELECT type_id,name FROM ".$this->table_types;
      if( $active )
        $query .= " WHERE active = $active ORDER BY priority DESC, name";
      $vars = $this->db_query($query);
      if( is_array($vars) ) {
        foreach($vars as $v) {
          $vals["$v[0]"] = $v[1];
        }
      }
      return($vals);
    } else {
      $where = ($active)? " WHERE active = $active" : "";
      $query = "SELECT * FROM ".$this->table_types." $where ORDER BY priority DESC, name";
      return( $this->db_queryIndexed($query) );
    }
  }

  function getProjectChildren( $pid, $columns = '', $archive_flag = 0 ) {
    // returns array of tickets for the project by its pid ($pid)
    // this is seperated from the get_tickets() for abstraction
    // (i.e. future expansion compatability)
    // the returned values of getProjectChildren() will always be
    // unsorted if using $columns (sorry!)

    $params = array("project_id"=>$pid);
    $sort = "status desc, priority desc, otime desc";
    $vars = $this->get_tickets($params, $sort, $columns, $archive_flag);
    return( $vars );
  }

  function getTicketHours( $id ) {
    // returns a total count of the number of hours associated with this ticket
    // if you just want the estimated and actual worked, and none of the sub-tickets
    // then just use get_ticket and look at those columns directly

    $ticket = $this->get_ticket($id);
    $est_hours = $ticket["est_hours"];
    $wkd_hours = $ticket["wkd_hours"];

    // get the children for this project
    $columns = array("id","est_hours","wkd_hours","type_id");
    $children = $this->getProjectChildren($id,$columns,$archive_flag);
    if( is_array($children) ) {
      for( $i=0; $i<count($children); $i++ ) {
        list($e,$w) = $this->getTicketHours($children[$i]["id"]);
        $est_hours += $e;
        $wkd_hours += $w;
      }
    }
    $this->addDebug("getTicketHours","Retrieving hours for $id, with ".count($children)
                    ." children: $est_hours, $wkd_hours",3);
    return( array($est_hours,$wkd_hours) );   
  }

  function getProjectHours( $pid, $archive_flag = 0 ) {
    // alias to getTicketHours
    // just to keep things sane, for now
    return $this->getTicketHours($pid);
  }   

  function getTicketSender( $id ) {
    $query = "SELECT user_id,bin_id FROM "
      .$this->table_logs
      ." WHERE ticket_id = $id"
      ." AND (action = 'MOVED' OR action = 'ASSIGNED' OR action = 'CREATED')"
      ." ORDER BY created DESC";
    $vars = $this->db_quickIndexed($query);      
    if( count($vars) ) {
      $this->addDebug("getTicketSender",join(",",$vars)."/".$query,3);
    } else {
      $this->addDebug("getTicketSender","couldn't find sender/".$query,2);
    }
    return $vars;
  }

  function projectTypeID() {
    // returns the type id associated with projects
    // this function prevents multiple calls for this
    // id by storing it the first time it is called
    // if $val is provided, returns true/false whether
    // $val is a project type id
    if( !strlen($this->projectTypeID) ) {
      $this->projectTypeID = null;
      foreach( $this->getTypes() as $k=>$b ) {
	if( preg_match("@project@i",$b) ) {
	  $this->projectTypeID = $k;
	  break;
	}
      }
    }
    return $this->projectTypeID;
  }

  function projectTypeIDs() {
    // returns the type id associated with projects
    // this function prevents multiple calls for this
    // id by storing it the first time it is called
    // if $val is provided, returns true/false whether
    // $val is a project type id
    if( !is_array($this->projectTypeIDs) ) {
      $this->projectTypeIDs = array();
      foreach( $this->types as $k=>$b ) {
        if( preg_match("@project@i",$b) ) {
          $this->projectTypeIDs[] = $k;
        }
      }
    }
    return $this->projectTypeIDs;
  }

  function notProjectTypeIds() {
    $vars = array();
    foreach( $this->getTypes() as $k=>$v ) {
      if( !preg_match("@project@i",$v) ) {
        $vars[] = $k;
      }
    }
    return $vars;
  }

  function inProjectTypeIDs($type_id) {
    // determines whether the id provided
    // is a valid project id
    // and returns true or false
    return( in_array($type_id,$this->projectTypeIDs()) );
  }

  function noteTypeIDs( ) {
    // returns the bin id associated with note
    // types for use with the auto-close function
    if( !is_array($this->noteTypeID) ) {
      $this->noteTypeID = array();
      foreach( $this->types as $k=>$b ) {
        if( preg_match("@note@i",$b) ) {
          $this->noteTypeID[] = $k;
        }
      }
    }
    return $this->noteTypeID;
  }

  /*
   *  INVOKE 
   */


  function zenTrack( $file, $language = '' ) {
    // $file is the configuration file
    // containing all of the settings for
    // zenTrack to use during operation
    // $user is the logged in userid for this
    // user.  If given, then the user will be retrieved
    // and saved for use in other methods (to
    // prevent multiple queries)
    // if $language is given, it will override the value
    // from the configVars file

    include("$file");

    $this->zen();
    $this->DB( $this->database_host, $this->database_login, 
               $this->database_password, $this->database_instance);

    $this->bins        = $this->getBins();
    $this->systems     = $this->getSystems();
    //$this->strings     = $this->getStrings($this->language);
    $this->settings    = $this->getSettings();
    $this->settings["font_size_small"] = $this->settings["font_size"] - 2;
    $this->settings["font_size_large"] = $this->settings["font_size"] + 4;
    // this is a quick hack to fix an oops
    // should eventually go through code and fix this
    $this->settings["color_title_txt"] = $this->settings["color_title_text"];
    $this->types       = $this->getTypes();
    $this->priorities  = $this->getPriorities();
    $this->tasks       = $this->getTasks();
    $this->custom_fields = $this->getCustomFields(1);

    // set the date formatting
    $this->date_fmt_long  = $this->settings["date_fmt_long"];
    $this->date_fmt_short = $this->settings["date_fmt_short"];
    $this->time_fmt       = $this->settings["date_fmt_time"];
    $this->elapsed_unit   = $this->settings["time_elapsed_unit"];
    $this->date_and_time  = $this->date_fmt_short." ".$this->time_fmt;
    $this->euroEnabled    = ($this->settings['use_euro_date'] == "on");

    // set language params
    $this->language       = ($language)? $language : $this->settings["language_default"];

    // cache length
    $this->cache_time = $this->settings["sql_cache_time"];

  }


  /*
   *  REPORTING FUNCTIONS
   */     

  /**
   * retrieves a list of report templates, bin_id and user_id are
   * both optional, and can be arrays.
   */
  function getReportTemplates( $bin_id = '', $user_id = '' ) {
    $query = "SELECT DISTINCT i.report_id,r.report_name FROM "
      .$this->table_reports_index
      ." i,".$this->table_reports." r WHERE i.report_id = r.report_id AND ("
      ."((i.bid IS NULL OR i.bid = '') "
      ." AND (i.user_id IS NULL or i.user_id = ''))";
    if( $bin_id ) {
      $query .= (is_array($bin_id))? 
        " OR i.bid IN(".join(",",$bin_id).")" : " OR i.bid = $bin_id";
    }
    if( $user_id ) {
      $query .= (is_array($user_id))? 
        " OR i.user_id IN(".join(",",$user_id).")" : " OR i.user_id = $user_id";
    }
    $query .= ") ORDER BY r.report_name";
    $this->addDebug("getReportTemplates",$query,3);
    return $this->db_queryIndexed($query);
  }

  /**
   * saves a report format
   * from the temporary templates
   * to the permanent database
   * $bins is optional list of bins who can view report
   * $users is optional list of users who can view report
   */
  function saveReport( $name, $temp_id, $bins = '', $users = '' ) {
    // get the params
    $params = $this->getTempReport($temp_id);
    if( !is_array($params) || !count($params) )
      return false;
    // get rid of extra tempid info
    unset($params["created"]);
    unset($params["report_id"]);
    $params["report_name"] = $name;
    $res = $this->db_insert($this->table_reports,$params);
    // add indexes to bins
    $t = $this->table_reports_index;
    if( $res && is_array($bins) ) {
      foreach($bins as $v) {
        $this->db_result("INSERT INTO $t (report_id,bid) VALUES($res,$v)");
      }
    }
    // add indexes to users
    if( $res && is_array($users) ) {
      foreach($users as $v) {
        $this->db_result("INSERT INTO $t (report_id,user_id) VALUES($res,$v)");
      }       
    }
    // return results
    return $res;
  }

  /**
   * drops a report template from the permanent database
   */
  function deleteReport( $rid ) {
    $query = "DELETE FROM ".$this->table_reports." WHERE report_id = $rid";
    return $this->db_result($query);
  }

  /**
   * adds a report format to the
   * temporary database
   */
  function addTempReport( $params ) {
    $params["created"] = $this->dateSQL();
    $this->cleanTempReports($this->cleanTempReports);
    return $this->db_insert($this->table_reports_temp,$params);
  }

  /**
   * removes old temporary reports from 
   * the database
   */
  function cleanTempReports( $days ) {
    $date = $this->dateSQL(strtotime("-$days days"));
    $query = "DELETE FROM ".$this->table_reports_temp." WHERE created < '$date'";
    $this->addDebug("cleanTempReports",$query,3);
    return $this->db_result($query);
  }

  /**
   * retrieves all properties for a temporary
   * report by the id
   */
  function getTempReport( $rid ) {
    $query = "SELECT * FROM ".$this->table_reports_temp." WHERE report_id = $rid";
    return $this->db_quickIndexed($query);
  }

  /**
   * retrieves all properties for a permanent
   * report by the id
   */
  function getReportParams( $rid ) {
    $query = "SELECT * FROM ".$this->table_reports." WHERE report_id = $rid";
    return $this->db_quickIndexed($query);
  }

  function reportActivity($params) {
    // returns a set of data to be graphed on the report
    // will be a count of entries matching given criteria
    // $params is a complex array (see db.class->complexWhere)     
    // any field from ZENTRACK_LOGS table may be used in the params
    // clause.. if not given, matches all activity between start and end
    // you will need to provide a date range or it will probably be a massive and
    // hardly useful report
    list($tables,$where) = $this->reportLogQuery($params);
    $query = "SELECT count(*) FROM $tables $where ORDER BY created";
    $val = $this->db_get($query);
    if( !strlen($val) )
      $val = 0;
    $this->addDebug("reportActivity","result: $val/params:"
                    .count($params)."/$query",3);
    return $val;
  }

  function reportTickets($params) {
    // returns a set of data to be graphed on a report
    // the return will be a count of tickets matching criteria
    // $params is a complex array (see db.class->complexWhere)   
    // any field from ZENTRACK_TICKETS may be used in $params
    // note that it is probably important to include some sort
    // of date range on either the otime or ctime or use 
    // ctime >= $start and otime <= $end... otherwise
    // this could be a massive report
    list($tables,$where) = $this->reportTicketQuery($params);
    $query = "SELECT count(*) FROM $tables $where";
    $val = $this->db_get($query);
    if( !strlen($val) )
      $val = 0;
    $this->addDebug("reportTickets","result: $val/params:"
                    .count($params)."/$query",3);
    return $val;
  }

  function reportElapsed($params) {
    // returns a set of data to be graphed on a report
    // the return will be a sum of hours for the given criteria
    // $params is a complex array (see db.class->complexWhere)   
    // any field from ZENTRACK_TICKETS may be used in $params
    // you will need to provide a date range or it will probably 
    // be an unwieldy report
    $tte = 0;
    list($tables,$where) = $this->reportTicketQuery($params);
    $query = "SELECT otime,ctime FROM $tables $where";
    $vals = $this->db_queryIndexed($query);
    for($i=0; $i<count($vals); $i++) {
      $v = $vals[$i];
      if( $v["ctime"] < 1 ) {
        $v["ctime"] = $this->currTime;
      }
      $diff = $this->dateDiff($v["ctime"],$v["otime"],$this->elapsed_unit);
      $tte += $diff;
    }
    $this->addDebug("reportElapsed","result: $tte/params:".count($params)."/$query",3);
    return round($tte,1);
  }

  function reportHours($params) {
    // returns a set of data to be graphed on a report
    // the return will be a sum of hours for the given criteria
    // $params is a complex array (see db.class->complexWhere)   
    // any field from ZENTRACK_LOGS may be used in $params
    // you will probably need a date range, or it will be an
    // unwieldy report
    list($tables,$where) = $this->reportLogQuery($params);
    $query = "SELECT sum(hours) FROM $tables $where";
    $val = $this->db_get($query);
    if( !strlen($val) )
      $val = "0.00";
    $this->addDebug("reportHours","result: $val/params:"
                    .count($params)."/$query",3);
    return $val;
  }

  function reportEstimated($params) {
    // returns a set of data to be graphed on a report
    // the return will be a sum of hours for the given criteria
    // $params is a complex array (see db.class->complexWhere)   
    // any field from ZENTRACK_TICKETS may be used in $params
    // you will probably need a date range, or it will be an
    // unwieldy report
    list($tables,$where) = $this->reportTicketQuery($params);
    $query = "SELECT sum(est_hours) FROM $tables $where";
    $val = $this->db_get($query);
    if( !strlen($val) )
      $val = "0.00";
    $this->addDebug("reportEstimated","result: $val/params:"
                    .count($params)."/$query",3);
    return $val;
  }

  function reportLogQuery($params) {
    // internal use only!!
    // returns array(tables,where_clause) for
    // use by log table report functions
    $where = "WHERE ";
    $ttr = false;      // ticket table required
    $ticket_table_id = $this->get_report_id("ticket");
    $system_table_id = $this->get_report_id("system");
    $type_table_id = $this->get_report_id("type");
    $bin_table_id = $this->get_report_id("bin");
    if( $params["system_id"] ) {
      $ttr = true;
      $params["system_id"][0] = "t.system_id";
    }
    if( $params["type_id"] ) {
      $ttr = true;
      $params["type_id"][0] = "t.type_id";
    }
    $tables = $this->table_logs." l";
    if( $ttr ) {
      $where .= " t.id = l.ticket_id AND ";
      $tables .= ", ".$this->table_tickets." t";
    }
    $where .= $this->complexWhere($params,"AND");
    return array($tables,$where);
  }

  function reportTicketQuery($params) {
    // internal use only!!
    // returns array(tables,where_clause) for
    // use by ticket table report functions
    $where = "WHERE ";
    $tables = $this->table_tickets." l";
    $where .= $this->complexWhere($params,"AND");
    $where = preg_replace("@l\.ticket_id@","l.id",$where);
    return array($tables,$where);
  }

  
  //#####################################################
  //create link for the search 
  //#####################################################
  function create_link($SCRIPT_NAME,$TODO,$i,$search_text,$search_fields,$search_params){
    $urlp1 = $SCRIPT_NAME."?TODO=".$TODO;  
    $urlp2 = "&orderby=" .$i;
    $urlp3 = "&search_text=" .$search_text;
    if (strip_tags($search_fields["title"]) == "title"){
      $urlp4 = "&search_fields[title]=".strip_tags($search_fields["title"]);
    }
    if (strip_tags($search_fields["description"]) == "description"){
      $urlp5 = "&search_fields[description]=".strip_tags($search_fields["description"]);
    }
    $a = "";
    foreach($search_params as $k=>$v){
      $a = $a."&search_params[$k]=".strip_tags($v);
    }
    $url = $urlp1. $urlp2. $urlp3. $urlp4. $urlp5. $a; 
    return ($url);
  }
  
  /*
  **  VARIABLES TO CONFIGURE (in config file)
  */


  // usage vars
  var $user;
  var $access;
  var $ticket;
  var $id;
  var $date_format_long;
  var $date_format_short;

  // settings vars
  var $settings;

  var $bins;
  var $priorities;
  var $systems;
  var $tasks;
  var $types;
  var $noteTypeID;
  var $projectTypeID;

  var $custom_fields;

  var $language;
  var $strings;
  var $words;
  var $lastUsersBins;
  var $lastUsersID;


  // db vars   

  var $table_access;
  var $table_attachments;
  var $actions;
  var $table_bins;
  var $table_logs;   
  var $table_logs_archived;
  var $table_preferences;
  var $table_priorities;
  var $table_reports;
  var $table_reports_index;
  var $table_reports_temp;
  var $table_settings;
  var $table_systems;
  var $table_tasks;
  var $table_tickets;
  var $table_tickets_archived;
  var $table_types;
  var $table_users;
  var $table_translation_strings;
  var $table_translation_words;
  var $table_notify_list;
  var $table_varfield_idx;

  var $cleanTempReports;
  var $reportImageWidth;
  var $reportImageHeight;

  var $database_type;
  var $database_instance;
  var $database_login;
  var $database_password;
  var $database_host;

  // directory vars
  var $libDir;
  var $listDir;
  var $templateDir;
  var $attachmentsDir;

  // others

  var $elapsed_unit;
  var $projectTypeID; 
  var $projectTypeIDs;
  var $demo_mode;
}

?>
