<?
  /*
  **  zenTrack Class
  **
  **  Author: Kato "PHPzen"
  **  Description: Ticketing system functions
  **  Version: See CVS Repository for version information
  **  Created: 02/22/21
  **  Email:  postmaster@phpzen.net
  **  URL: http://www.phpzen.net
  **
  **  This is the main class containing all of the functionality for use
  **  with the zentrack system.  This class extends zen (basic text formatting
  **  and page utilities), zenDate (date manipulations and calculations) and 
  **  db.class (database access and retrieval)
  */

include_once("$libDir/zen.class");  
  
class zenTrack extends zen {

   
   /*
    *  RETRIEVAL 
   */
   
   
   function get_access( $uid, $flag = 0 ) {
      // retrieves the access priviledges
      // by the uid (user id)
      // if flag set to 1, then it returns
      // a simple array containing all the columns
      //  ( [0] = array(..all columns in db..) )
      // otherwise, returns an array indexed by binID, 
      // with a value of the level for that bin
      //  ( ["binID"] = $bin_level )
      
      $query = "SELECT * FROM ".$this->table_access." WHERE user = $user";
      $vars = $this->db_result($query);
      if( $flag ) {
	 return $vars;
      } else {
	 if( is_array($vars) ) {
	    foreach($vars as $v) {
	       $vals["$v[binID]"] = $v["level"];
	    }
	 }
	 return( $vals );
      }
   }   
   
   function get_attachment($aid) {
      // retrieves all properties for a given attachment
      // this is by the attachmentID and not the ticket or log ID
      // and creates a file location to the actual 
      // attachment which is stored as ["location"]
      
      $query = "SELECT * FROM ".$this->table_attachments." WHERE attachmentID = $aid";
      $vars = $this->db_quickIndexed($query);
      if( is_array($vars) ) {
	 $vars["location"] = $this->attachmentsDir."/".$vars["name"];
      }
      return($vars);
   }

   function get_attachments($id, $flag = 0, $indexed = 0) {
      // retrieves all attachements for a given ticketID
      // indexed by log entry they are associated with
      // if $flag = 1, retrieves by logID instead of ticketID
      // if $indexed = 1, then retrieves in a complex array
      // indexed by ticketID and logID as follows:
      // $vals["ticket1"]["log1"] = array(datarow)
      // otherwise, returns in a simple, non-indexed array
      
      $field = ($flag)? "logID" : "ticketID";
      $where = (is_array($id))?
	" $field IN(".join(",",$id).")" :
        " $field = $id";
      $query = "SELECT * FROM ".$this->table_attachments." WHERE $where ORDER BY name";
      $vars = $this->db_queryIndexed($query);
      if( $indexed ) {
	 for( $i=0; $i<count($vars); $i++ ) {
	    $n = $vars[$i]["logID"];
	    $v = $vars[$i]["ticketID"];
	    $vals["$v"]["$n"][] = $vars[$i];
	 }
      } else {
	 $vals = $vars;
      }
      return($vals);
   }   
   
   function get_log( $lid ) {
      // returns a specific logs data
      $query = "SELECT * FROM ".$this->table_logs." WHERE lid = $lid";
      return( $this->db_quick($query) );
   }

   function get_logs( $id, $sort = 'created DESC', $limit = '' ) {
      // retrieve log entries for the given ticket id
      // $limit specifies the max number to return      
      $query = "SELECT * FROM ".$this->table_logs." WHERE ticketID = $id";
      if( $sort )
	$query .= " ORDER BY $sort";
      if( $limit )
	$query .= " LIMIT $limit";
      return( $this->db_queryIndexed($query) );
   }  
   
   function get_project( $pid, $archive_flag = 0 ) {
      // retrieves all properties from database for given
      // project.  Also returns the following:
      //    children -  an array of tickets that belong to this project 
      //    est_hours - is the estimated time for all tickets associated with 
      //                this project
      //    wkd_hours - is the total hours worked on all tickets for this project
      //    percent_hours - is the percentage completion based on est_ and wkd_
      // if $archive_flag = 1, then will look in archived tickets instead of 
      // active tickets table
      
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "SELECT * FROM $table WHERE id = $pid";
      $vars = $this->db_quickIndexed($query);
      list($vars["est_hours"], $vars["wkd_hours"]) = $this->getProjectHours($pid, $archive_flag);
      $vars["children"] = $this->getProjectChildren($pid, NULL, $archive_flag);
      return($vars);
   }
   
   function get_projects( $params, $sort = 'priority, otime desc', $archive_flag =0 ) {
      // retrieves a list of projects
      // see getTickets() for a list of valid params
      // (with the exception of 'typeID' which is set to
      // the id for projects)
      // note that this does not return an accurate result
      // for est_hours and wkd_hours.  Use getProjectHours() 
      // to determine these values
      // if $archive_flag = 1, then retrieves from archive table
      
      $params["typeID"] = $this->projectTypeID();
      return( $this->get_tickets($params, $sort, NULL, $archive_flag) );
   }
   
   function get_ticket( $id, $archive_flag = 0 ) {
      // retrieves the properties for a 
      // specific ticket by id
      // use get_project() instead for projects
      // to retreive accurate est_hours and wkd_hours relative
      // to a project and all it's children
      // $archive_flag retrieves tickets from archive db instead
      // of the ticket db
      
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "SELECT * FROM $table WHERE id = $id";
      return( $this->db_quickIndexed($query) );
   }
   
   function get_tickets( $params = '', $sort = 'priority, otime desc', $columns = '', $archive_flag = 0 ) {
      // retrieves a list of tickets
      // $params can contain:
      //     bins  - string/array of bins to retrieve for
      //     users - string/array of users to retrieve for
      //     id    - an array of specific ticket ids to retrieve
      // the default columns returned can be overriden by using $columns to 
      // specify what should be returned from this function.  Note that the 
      // sort must correspond to the $columns values for SQL compatibility
      
      $table = ($archive_flag)? 
	$this->table_tickets_archived : $this->table_tickets;
      
      if( !is_array($columns) )
	$columns = array("*");
	
      if( is_array($params) ) {
	 $where = "WHERE ".$this->simpleWhere($params);
      }
      $query = "SELECT ".join(",",$columns)." FROM $table $where";
      if( $sort )
	$query .= " ORDER BY $sort";
      return( $this->db_queryIndexed($query) );
   }      
   
   function get_user( $uid ) {
      // returns a specific user
      // by the user id
      
      $query = "SELECT * FROM ".$this->table_users." WHERE uid = $uid";
      return( $this->db_quickIndexed($query) );
   }

   function get_users( $bins, $params = '', $sort = 'lname, fname' ) {
      // creates a list of users
      // if $bins (array/string) is given
      // then list will be only for users
      // of given bins

      $columns = array(
		       "uid",         "lname",
		       "fname",       "access",
		       "initials",    "email"
		       );

      if( !is_array($bins) ) {
	$bins = array($bins);
      }
      $query = "SELECT DISTINCT userID FROM ".$this->table_access." WHERE binID IN(".join(",",$bins).") AND level >= ".$this->settings["level_user"];
      $ids = $this->db_list($query);
      if( is_array($ids) ) {
	 $where = " (uid IN(".join(",",$ids).") OR access >= ".$this->settings["level_user"].") ";
      } else {
	 $where = " access >= ".$this->settings["level_user"];
      }
      if( $params )
	$where = ($where)? " AND ".$this->simpleWhere($params) : $this->simpleWhere($params);
      if( $where )
	$where = "WHERE $where";
      if( $sort )
	$sort = "ORDER BY $sort";
      $query = "SELECT ".join(",",$columns)." FROM ".$this->table_users." $where $sort";
      return( $this->db_queryIndexed($query) );
   }
   
   
   
   /*
    *  SEARCH FUNCTIONS 
   */
   
   
   
   function search_logs( $params, $archive_flag = 0 ) {
      // search through log entries for given text
      // params is an indexed array with two elements:
      //   $params[key][0] = LIKE, =, >, <, >=, etc..
      //   $params[key][1] = '%value', '%value%', lower('value'), etc
      // this function requires the values to be provided with single
      // quotes and escape chars in place, they will not be added!
      // if archive_flag = 1, then searches ticket archives as well
      // if archive_flag = 2, then searches archives only
      
      $columns = array(
		       "lid",     "ticketID", 
		       "userID",  "action"
		       );
      
      $where = $this->complexWhere($params);
      if( $archive_flag )
	$tables = ($archive_flag == 2)? $this->table_logs_archived : $this->table_logs_archived.", ".$this->table_logs;
      else
	$tables = $this->table_logs;
      $query = "SELECT ".join(",",$columns)." FROM $tables WHERE $where";
      return(  $this->db_queryIndexed($query) );
   }
   
   function search_tickets( $params, $archive_flag = 0 ) {
      // search through tickets for given text
      // acceptable params are:
      // params is an indexed array with two elements:
      //   $params[key][0] = LIKE, =, >, <, >=, etc..
      //   $params[key][1] = '%value', '%value%', lower('value'), etc
      // this function requires the values to be provided with single
      // quotes and escape chars in place, they will not be added!
      // if archive_flag = 1, then searches ticket archives as well
      // if archive_flag = 2, then searches archives only
      
      $columns = array(
		       "id",        "title", 
		       "status",    "otime", 
		       "ctime",     "binID", 
		       "typeID",    "userID"
		       );      
      $where = $this->complexWhere($params);
      if( $archive_flag )
	$tables = ($archive_flag == 2)? $this->table_tickets_archived : $this->table_tickets_archived.", ".$this->table_tickets;
      else
	$tables = $this->table_tickets;
      $query = "SELECT ".join(",",$columns)." FROM $tables WHERE $where ORDER BY status, ctime desc, otime desc";
      return(  $this->db_queryIndexed($query) );      
   }         
   
   
   /*
    *  PROJECT ADMINISTRATION 
   */         
   
   
   function add_project( $params ) {
      // create a new project with the given params
      // (abstracted from add_ticket() to allow
      // for custom functionality)
      // all dates are to be sent as unix timestamps
      
      $params["typeID"] = $this->projectTypeID();
      unset($params["est_hours"]);
      unset($params["wkd_hours"]);
      return( $this->add_ticket($params, $archive_flag) );
   }
   
   function delete_project( $pid, $archive_flag = 0 ) {
      // drop project, all associated tickets
      // all log entries of those tickets, and
      // all their data from the db
      // if $archive_flag = 1, then deletes from the
      // archive table
      
      $children = $this->getProjectChildren($pid, array('id'), $archive_flag);
      for($i=0; $i<count($children); $i++) {
	 $ids[] = $children["id"];
      }
      //drop the tickets under this project      
      $this->delete_ticket($ids, $archive_flag); 
      $this->delete_log($pid, NULL, $archive_flag);
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "DELETE FROM $table WHERE id = $pid";
      return( $this->db_result($query) );
   }
   
   function archive_project( $pid ) {   
      // send a project to the archives
      // and all of it's related tickets and logs
      
      $children = $this->getProjectChildren($pid, array('id'));
      foreach($children as $c) {
	 $this->archive_ticket($c["id"]);
      }
      $fields = $this->db_get_fields($this->table_tickets_archived);
      $query = "INSERT INTO "
	.$this->table_tickets_archived." ($fields) SELECT $fields FROM ".$this->table_tickets
	." WHERE id = $pid";     
      $res = $this->db_result($query);            
      $this->archive_log($pid);
      $this->delete_project($id);
      return( $res );
   }
   
   function close_project( $pid, $params = '', $override = 0 ) {
      // sets the status of a project to 'CLOSED' assuming
      // that the project doesn't require testing and approval
      // and that all children are closed (otherwise will skip)
      // if $override is passed, then this method will
      // close a project, even if testing or approval are
      // required, or there are open children.
      // $params is an array passed on to the log function
      //   (userID, comments)
      
      if( $override || $this->check_status($pid, 'READY') ) {
	 $children = $this->getProjectChildren($pid, array('id'));
	 for( $i=0; $i<count($children); $i++ ) {
	    $this->close_ticket($children[$i]);	 
	 }
	 return( $this->change_status($pid, 'CLOSED', $params) );	 
      }
   }
   
   
   /*
    *  TICKET ACTIONS 
   */
   

   function accept_ticket( $id, $userID, $comments = '', $binID = '' ) {
      // changes the tickets userID to reflect
      // a new owner for the ticket
      // logs this in the db if settings["log_accept"] = "On";

      $params = array( "userID" => $userID );
      $res = $this->update_ticket($id,$params);
      if( $res && $this->settings["log_accept"] == "on" ) {
	 $logParams = array(
			    "action"   =>  'ACCEPTED',
			    "userID"   =>  $userID,
			    "ticketID" =>  $id
			    );
	 if( !$binID ) {
	    $t = $this->get_ticket($id);
	    $binID = $t["binID"];
	 }
	 $logParams["binID"] = $binID;
	 if( $comments )
	   $logParams["entry"] = htmlentities($comments);	 
	 $res = $this->add_log($id, $logParams);
      }
      return( $res );
   }
   
   function approve_ticket( $id, $userID, $comments = '' ) {
      // changes the approval status to 2 for the ticket
      // if the ticket is ready for closure, then this function
      // will also close out the ticket
      
      $t = $this->get_ticket($id);
      $params = array("approved"=>2);
      $res = $this->update_ticket($id,$params);
      if( $res && $this->settings["log_approve"] ) {
	 $logParams = array(
			    "action"   =>  'APPROVED',
			    "userID"   =>  $userID,
			    "ticketID" =>  $id
			    );
	 $logParams["binID"] = $t["binID"];
	 if( $comments )
	   $logParams["entry"] = htmlentities($comments);
	 $this->add_log($id, $logParams);	 
      }     
      if( $t["tested"] != 1 ) {
	 $res = $this->close_ticket($id);
      }
      return( $res );
   }
   
   function assign_ticket( $id, $recipient, $userID = '', $comments = '' ) {
      // set the userID for the ticket to another person
      // the recipient recieves the ticket, the userID is for the 
      // sender
      
      $params = array( "userID" => $recipient );
      $res = $this->update_ticket($id, $params);
      if( $res && $this->settings["log_assign"] == 'on' ) {
	 $logParams = array(
			    "action"   =>  'ASSIGNED',
			    "userID"   =>  $userID
			    );
	 $t = $this->get_ticket($id);
	 $logParams["binID"] = $t["binID"];
	 $logParams["entry"] = "ASSIGNED TO ".$this->formatName($recipient,1);
	 if( $comments )
	   $logParams["entry"] .= "\n\n".$comments;
	 $this->add_log($id, $logParams);	 			    
      }
      if( $res && $this->settings["email_assign"] == "on" ) {
	 $subject = "[".$this->settings["system_name"]."] ticket #$id assigned to you";
	 $emailParams["Assigned by"] = $this->formatName($userID);
	 if( $comments )
	   $emailParams["body"] = htmlentities($comments);
	 $emailParams["tid"] = $id;
	 $message = $this->formatEmailMessage($emailParams);
	 $this->sendEmail($recipient,$subject,$message,$userID);
      }
      return( $res );
   }   

   function attach_to_ticket( $id, $userID, $params, $logID = '' ) {
     // creates an attachment to the given ticket and logs
     // the event if needed
     // the params array contains:
     //     name         - name of the file to display
     //     filename     - name of file on system
     //     filetype     - mime type (i.e. image/gif)
     //     description  - [optional] comments about the file for display
     extract($params);
     $res = $this->add_attachment($name, $filename, $filetype, $id, $logID, $description);
     if( $res && $this->settings["log_attachment"] == 'on' ) {
       $logParams = array(
			  "userID"   => $userID,
			  "action"   => "ATTACHMENT"
			  );
       $logParams["entry"] = "$name--$filetype";
       if( $description )
	 $logParams["entry"] .= "--".$description;	
       if( $logID )
	 $logParams["entry"] .= "\nattached to log $logID";
       $r = $this->add_log( $id, $logParams );
       if( !$r )
	 die("couldn't log it");
     }
     return $res;
   }
      
   function close_ticket( $id, $userID = '', $hours = '', $comments = '' ) {
      // closes the ticket (sets the status to CLOSED)
      // if there is testing or approval yet required, then
      // simply sets status to pending.
      // however, if both of these are completed, then 
      // closes out the ticket
      	
      $t = $this->get_ticket($id);
      if( $t["tested"] != 1 && $t["approved"] != 1 
	 && ($t["status"] == 'PENDING' || $t["status"] == 'OPEN') ) {
	 $params = array(
			 "status"  =>  'CLOSED',
			 "userID"  =>  'NULL',
			 "ctime"   =>  $this->currTime
			 );
	 $res = $this->update_ticket($id, $params);
	 if( $res && $this->settings["log_close"] == "on" ) {
	    $logParams = array(
			       "action"   =>  'CLOSED',
			       "ticketID" =>  $id,
			       "entry"    =>  $entry
			       );
	    if( $userID ) {
	       $logParams["userID"] = $name;
	    }
	    $logParams["binID"] = $t["binID"];	    
	    if( $hours )
	      $logParams["hours"] = $hours;
	    if( $comments )
	      $logParams["entry"] = $comments;
	    $this->add_log($id, $logParams);	 
	 }
	 if( $res && $this->settings["email_closed"] == "on" ) {
	    $bin = $t["binID"];
	    $recipient = $t["creatorID"];
	    $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	    $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	    if( $comments )
	      $emailParams["body"] = htmlentities($comments);
	    $emailParams["tid"] = $id;
	    $message = $this->formatEmailMessage($emailParams);
	    $this->sendEmail($recipient,$subject,$message,$userID);	    
	 }
      } else if( ($t["tested"] == 1 || $t["approved"] == 1) && $t["status"] == "OPEN" ) {
	 $params = array(
			 "status"  =>  'PENDING',
			 "userID"  =>  'NULL'
			 );
	 $res = $this->update_ticket($id, $params);
	 if( $res && $this->settings["log_pending"] == "on" ) {
	    $logParams = array(
			       "action"   =>  'PENDING',
			       "ticketID" =>  $id,
			       "entry"    =>  $entry
			       );
	    if( $userID ) {
	       $logParams["userID"] = $name;
	    }
	    $logParams["binID"] = $t["binID"];	    
	    if( $hours )
	      $logParams["hours"] = $hours;
	    if( $comments )
	      $logParams["entry"] = $comments;
	    $this->add_log($id, $logParams);	 
	 }	 
	 if( $res && $this->settings["email_pending"] == "on" ) {
	    $bin = $t["binID"];
	    $vars = $this->fetch_bin_roles($bin,'manager');
	    $recipient = $vars[0]["userID"];
	    if( $recipient ) {
	       $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	       $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	       if( $comments )
		 $emailParams["body"] = htmlentities($comments);
	       $emailParams["tid"] = $id;
	       $message = $this->formatEmailMessage($emailParams);
	       $this->sendEmail($recipient,$subject,$message,$userID);
	    }
	 }	 
      }
      return($res);
   }
   
   function log_ticket( $id, $userID, $action = 'LOG', $hours = '', $comments = '' ) {
      // create an entry in the ticket log to track hours
      // or work done
      
      $logParams["userID"] = $userID;
      if( $action )
	$logParams["action"] = $action;
      if( $hours )
	$logParams["hours"] = $hours;
      if( $comments )
	$logParams["entry"] = $comments;
      return $this->add_log($id, $logParams);
   }
   
   function move_ticket( $id, $newBin, $userID = '', $comments = '' ) {
      // moves the ticket to a new bin location
      // if comments field is set to 'skip_log' then
      // no log will be generated (assumed to have 
      // been done before calling this)
      
      $t = $this->get_ticket($id);      
      $params = array(
		      "binID"  => $newBin,
		      "userID" => 'NULL'
		      );
      $res = $this->update_ticket($id, $params);
      if( $res && $this->settings["log_move"] == "on" ) {
	 $logParams["action"] = "MOVED";
	 $logParams["binID"] = $t["binID"];
	 $logParams["entry"] = "MOVED TO ".$this->bins["$newBin"];
	 $logParams["ticketID"] = $id;
	 if( $userID )
	   $logParams["userID"] = $userID;
	 if( $comments )
	   $logParams["entry"] .= "\n\n".$comments;
	 $this->add_log($id,$logParams);
      }
      if( $res && $this->settings["email_arrival"] == "on" ) {
	 $recipient = $this->fetch_bin_roles($t["binID"]);
	 if( $recipient ) {
	    $to = $recipient[0]["userID"];
	    $eParams = array(
			     "From" => $this->bins["$t[binID]"], 
			     "Sent" => $this->showDateTime(),
			     "By"   => $this->formatName($userID)
			     );
	    if( $comments )
	      $eParams["body"] = $comments;
	    $eParams["tid"] = $id;
	    $message = $this->formatEmailMessage($eParams);
	    $this->sendEmail($to,$subject,$message,$userID);
	 }
      }
      return($res);
   }
   
   function reject_ticket( $id, $userID, $comments = '' ) {
      list($senderID,$binID) = $this->getTicketSender($id);
      $res = $this->move_ticket( $id, $binID );
      $t = $this->get_ticket($id);
      if( $res && $this->settings["log_reject"] == "on" ) {
	 $logParams["action"] = "REJECTED";
	 $logParams["binID"] = $t["$binID"];
	 $logParams["userID"] = $userID;
	 $logParams["ticketID"] = $t["ticketID"];
	 if( $comments )
	   $logParams["entry"] = $comments;
	 $this->add_log($id,$logParams);
      }
      if( $res && $this->settings["email_reject"] == "on" && $senderID ) {
	 $eParams = array(
			  "From" => $this->bins["$t[binID]"], 
			  "Time" => $this->showDateTime(),
			  "By"   => $this->formatName($userID)			  
			  );
	 if( $comments )
	    $eParams["body"] = $comments;
	 $eParams["tid"] = $id;
	 $message = $this->formatEmailMessage($eParams);
	 $this->sendEmail($senderID,$subject,$message,$userID);
      }      
      return($res);
   }
   
   function relate_ticket( $id, $relations, $userID = '', $comments = '' ) {
      // takes either a comma delimited string
      // or an array of ticket ids
      // checks to insure they exist before performing
      // relations
      // 
      // THIS FUNCTION IS VERY INEFFICIENT AND NEEDS TO BE REVISED
      // IT'S A HORRIBLE HACK FIX NOW, AND PROBABLY REQUIRES
      // THE CREATION OF A NEW DB TABLE AND SOME EDITS
      // TO THIS FUNCTION (possibly the addition of an addRelation()
      // and dropRelation() method to encompass non-global updates)
      
      $t = $this->get_ticket($id);      
      if( !is_array($relations) )
	$relations = split(" *, *", $relations);
      $relations = $this->checkRelations($relations);
  
      if( is_array($relations) ) {
	 $rel = join(",",$relations);
	 $res = $this->update_ticket($id, array("relations"=>$rel));
	 //
	 // 
	 // 
	 // 
	 // need to add some methodology here to update the tickets
	 // which this one is related to to reflect that relation as
	 // well, and to remove relations from tickets which used to
	 // be related to this one which aren't anymore
	 // 
	 // see the comments at the top of this method for more gripes
	 // about this bug
	 // 
	 // 
	 // 
      }                  
      if( $res && $this->settings["log_relate"] == "on" && $userID ) {
	 $logParams["action"] = "RELATED";
	 $logParams["binID"] = $t["binID"];
	 $logParams["userID"] = $userID;
	 $logParams["ticketID"] = $t["ticketID"];
	 $logParams["entry"] = join(",",$relations);
	 if( $comments )
	   $logParams["entry"] .= "\n\n".$comments;
	 $this->add_log($id,$logParams);
      }
      return( $res );
   }
   
   function reopen_ticket( $id, $userID = 'NULL', $tested = 0, $approved = 0, $comments = '' ) {
      // opens a ticket that has been closed
      // this can be used to reopen tickets
      // closed in error, or to make modifications
      // to a closed ticket
      
      $t = $this->get_ticket($id);      
      $params = array(
		      "ctime"    =>   'NULL',
		      "userID"   =>   $userID,
		      "status"   =>   'OPEN',
		      "binID"    =>   $t["binID"],
		      "tested"   =>   $tested,
		      "approved" =>   $approved
		      );
      $res = $this->update_ticket($id, $params);
      if( $res ) {
	 $logParams["action"] = "REOPENED";
	 $logParams["binID"] = $t["binID"];
	 $logParams["userID"] = $userID;
	 $logParams["ticketID"] = $t["ticketID"];	 
	 $logParams["entry"] = "Ticket $id opened in ".$this->bins["$binID"];
	 if( $comments )
	   $logParams["entry"] .= "\n\n".$comments;
	 $this->add_log($id,$logParams);
      }
      if( $res && $this->settings["email_arrival"] == "on" ) {
	 $recipient = $this->fetch_bin_roles($t["binID"],'manager');
	 if( $recipient ) {
	    $to = $recipient[0]["userID"];
	    $eParams = array(
			     "message" => "This ticket has been reopened.",
			     "From"    => $this->bins["$t[binID]"], 
			     "Time"    => $this->showDateTime(),
			     "By"      => $this->formatName($userID)		  
			     );
	    if( $comments )
	      $eParams["body"] = $comments;
	    $eParams["tid"] = $id;
	    $message = $this->formatEmailMessage($eParams);
	    $this->sendEmail($to,$subject,$message,$userID);
	 }
      }
      return( $res );
   }
      
   function test_ticket( $id, $userID, $hours = '', $comments = '' ) {
      // updates the testing parameter to reflect
      // a status of 'testing completed' for the ticket
      
      $t = $this->get_ticket($id);
      $res = $this->update_ticket($id, array("tested"=>2));
      if( $res && $this->settings["log_test"] ) {
	 $logParams["action"] = "TESTED";
	 $logParams["binID"] = $t["binID"];
	 $logParams["userID"] = $userID;
	 $logParams["ticketID"] = $t["ticketID"];	 
	 if( $comments )
	   $logParams["entry"] = $comments;
	 $this->add_log($id,$logParams);	 
      }
      if( $t["approved"] != 1 ) {
	 // go ahead and close the ticket
	 // since it doesn't need to be
	 // approved	 	 
	 $this->close_ticket($id);
      }       	 
      return( $res );
   }
   
   function yank_ticket( $id, $userID, $comments = '' ) {
      // takes a ticket from it's current location and status 
      // (whatever those might be) and 
      // assigns it to the user specified
      
      $t = $this->get_ticket($id);
      $binID = $t["binID"];
      if( is_array($t) ) {
	 if( $this->settings["log_yank"] == "on" ) {
	    $lParams = array(
			     "action"   =>   "YANKED",
			     "userID"   =>   $userID,
			     "binID"    =>   $binID
			     );
	    if( $comments )
	      $lParams["entry"] = $comments;
	    $this->add_log($id,$lParams);
	 }
	 if( $t["status"] == 'CLOSED' ) {
	    $tested = ($t["tested"] == 2)? 1:0;
	    $approved = ($t["approved"] == 2)? 1:0;
	    $this->reopen_ticket($id, $userID, $tested, $approved, $comments);
	 }
	 $this->assign_ticket($id,$userID);
	 return( 1 );
      }
   }        
   
   /*
    *  TICKETS ADMINISTRATION
   */
   
   
   function add_ticket( $params ) {
      // create a new ticket with the
      // given params and return the new
      // insert ID for that ticket
      
      return( $this->db_insert($this->table_tickets, $params) );      
   }

   function archive_ticket( $id ) { 
      // send a ticket and all of it's log
      // entries to the archive db
      
      $ticket = $this->get_ticket($id);
      if( $ticket["typeID"] == $this->projectTypeID() )
	return( $this->archive_project($id) );
      
      $fields = $this->db_get_fields($this->table_tickets_archived);
      $query = "INSERT INTO "
	.$this->table_tickets_archived." ($fields) SELECT $fields FROM ".$this->table_tickets
	." WHERE id = $id";      
      $this->db_result($query);
      $this->archive_log($id);
      $this->delete_ticket($id);
   }   
      
   function delete_ticket( $id, $archive_flag = 0 ) {
      // drop a ticket, its log entries, and 
      // all associated data from the db
      // $id can be an array
      $this->delete_log($id, $archive_flag);
      $table = ($flag)? 
	$this->table_tickets_archived : $this->table_tickets;
      $where = (is_array($id))? " id IN(".join(",",$id).")" : " id = $id";
      $query = "DELETE FROM $table WHERE $where";      
      return( $this->db_result($query) );
   }
   
   function update_ticket( $id, $params ) {
      // update properties of an existing
      // tickets with given params
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_tickets." SET $set WHERE id = $id";
      return( $this->db_result($query) );
   }
   

   
   /*
    *  LOG AND TIME FUNCTIONS 
   */
   
   
   function add_log( $id, $params ) {
      // add a new log entry for ticket
      // with $id
      // params can include any of the 
      // following indexes:
      //    userID
      //    binID
      //    action (the action logged)
      //    entry (the log entry)
      //    ticketID
      
      // set up the parameters for the insert statement
      $table = $this->table_logs;
      $params["ticketID"] = $id;
      $params["created"] = $this->currTime;
      if( !$params["action"] )
	$params["action"] = "LOG";
      if( !$params["userID"] )
	$params["userID"] = $this->settings["bot_name"];
      if( !$params["binID"] ) {
	 $ticket = $this->get_ticket($id);
	 $params["binID"] = $ticket["binID"];
      }
      // add hours to the ticket's total
      if( $params["hours"] ) {
	 if( !$ticket )
	   $ticket = $this->get_ticket($id);
	 $wkd = $params["hours"] + $ticket["wkd_hours"];
	 $query = "UPDATE ".$this->table_tickets." set wkd_hours = $wkd WHERE id = $id";
	 $this->db_result($query);
      }
      return( $this->db_insert($table, $params) );      
   }
   
   function delete_log( $id, $flag = 0, $archive_flag = 0 ) {
      // delete log entries for ticket with
      // $id, if $flag = 1, then deletes only
      // the entry with log_id of $id (i.e. by the
      // log id instead of ticket id)
      // id can be a string or an array
      
      $column = ($flag)? "lid" : "ticketID";
      if( is_array($id) )
	$where = " $column IN(".join(",",$id).")";
      else
	$where = " $column = $id";
      $table = ($archive_flag)? 
	$this->table_logs_archived :
        $this->table_logs;
      if( !$archive_flag ) {
	 $attachments = $this->get_attachments($id, $flag);
	 if( is_array($attachments) ) {
	    foreach($attachments as $a) {
	       $att[] = $a["attachmentID"];
	    }
	    $this->delete_attachment($att);
	 }	 
      }
      $query = "DELETE FROM $table WHERE $where";
      return( $this->db_result($query) );
   }
   
   function archive_log( $id, $flag = 0 ) {
      // moves logs for ticket with $id to the 
      // db archives.  if $flag = 1, then moves
      // only logs with an lid(log id) matching $id
      // instead of by ticketID
      // attachments are deleted from the db
      // when a ticket is archived
      
      $f = ($flag)? "lid" : "ticketID";
      $fields = $this->db_get_fields($this->table_tickets_archived);
      $query = "INSERT INTO "
	.$this->table_tickets_archived." ($fields) SELECT $fields FROM ".$this->table_tickets
	." WHERE $f = $id";            
      $attachments = $this->get_attachments($id, $flag);
      if( is_array($attachments) ) {
	 foreach($attachments as $a) {
	    $att[] = $a["attachmentID"];
	 }
	 $this->delete_attachment($att);
      }	 
      return( $this->db_result($query) );
   }
      
   function add_attachment( $name, $filename, $filetype, $ticketID, $logID = '', $description = '' ) {
      // adds an attachment to the db for tracking
      // does not add the actual file, just it's associations
      // with logs and tickets, logID is optional, the ticketID is not
      // filetype represents the complete mime type as will be used
      // to supply the file back to the user when requested
      
      if( !$ticketID ) {
	 $log = $this->get_log($logID);
	 $ticketID = $log["ticketID"];
      }
      $params = array(
		      "logID"       => $logID,
		      "ticketID"    => $ticketID,
		      "name"        => $name,
		      "filename"    => $filename,
		      "filetype"    => $filetype
		      );
      if( $description )
	$params["description"] = $description;
      $table = $this->table_attachments;
      return( $this->db_insert($table,$params) );
   }
   
   function delete_attachment( $aid ) { 
      // deletes attachments by attachmentID
      // can be an array
      
      if( !is_array($aid) )
	$aid = array($aid);
      for( $i=0; $i<count($aid); $i++ ) {
	 $att = $this->get_attachment($aid[$i]);
	 $file = $this->attachmentDir."/$att[name]";
	 unlink($file);	
      }
      $query = "DELETE FROM ".$this->table_attachments." WHERE attachmentID IN(".join(",",$id).")";
      return( $this->db_result($query) );
   }
   
   function delete_all_attachments( $id ) {
      // deletes all attachments by their logID
      // $id can be an array
      
      if( !is_array($id) )
	$id = array($id);
      foreach($id as $i) {
	 $att = $this->get_attachments($i, $flag);
	 for( $i=0; $i<count($att); $i++ ) {
	    $aid[] = $att["attachmentID"];
	 }
      }
      return( $this->deleteAttachment($aid) );
   }
   
   
   /*
    *  USER ADMINISTRATION
   */
   
   
   function add_user( $params ) {
      // creates a new user entry in the db
      // if $params["access"] is an array
      // then it will also run add_access()
      // with this array once the user has
      // been created
      // if ["password"] is given, it should
      // be the unencrypted value.. if blank,
      // ["password"] will be set automatically
      // to the users last name until that user
      // logs into the system and changes it
      
      if( $params["access"] ) {
	 $access = $params["access"];
	 unset($params["access"]);
      }
      $params["password"] = ($params["password"])?
	md5($params["password"]) : $params["lname"];
      $table = $this->table_users;
      $id = $this->db_insert($table, $params);
      if( $id ) {
	 if( is_array($access) )
	   $this->add_access($id, $access);
	 return($id);
      }
   }
   
   function delete_user( $uid ) {
      // deletes a user from the db by the
      // user's id.  also deletes all access
      // and prefs entries for this user
      // $uid can be an array
      
      $where = (is_array($uid))? " uid IN(".join(",",$uid).")" : " uid = $uid";
      $query = "DELETE FROM ".$this->table_users." WHERE $where";
      $this->delete_access($uid);
      return( $this->db_result($query) );
   }
   
   function update_user( $uid, $params ) {
      // updates user settings by uid
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_users." SET $set WHERE uid = $uid";
      return( $this->db_result($query) );
   }
   
   function add_access( $uid, $params ) {
      // adds new access parameters for the 
      // given user, ignores ones that 
      // currently exist for that user
      // $params is an indexed array containing:
      //   "binID" => level (integer)

      foreach($params as $k=>$v) {
	 $query = "INSERT INTO ".$this->table_access." (userID,binID,level) VALUES($uid,$k,$v)";
	 $res = $this->db_result($query);
	 if( $res )
	   $i++;
      }
      return($i);
   }
   
   function update_access( $uid, $params ) {
      // deletes the users old access privileges 
      // and replaces them with the ones given in 
      // $params, $uid is the userID
      
      $this->delete_access( $uid );
      return( $this->add_access($uid, $params) );
   }
   
   function delete_access( $id, $flag = '' ) {
      // deletes access privedges based on $flag
      //   NULL - by userID
      //   1    - by binID
      //   2    - by aid
      // $id can be an array
      
      if( $flag == 1 )
	$field = "binID";
      else if( $flag == 2 )
	$field = "aid";
      else
	$field = "userID";
      $where = (is_array($id))?
	" $field IN(".join(",",$id).")" :
        " $field = $id";      
      $query = "DELETE FROM ".$this->table_access." WHERE $where";
      return( $this->db_query($id) );
   }
   
   function add_prefs( $uid, $params ) {
      // adds prefs for a uid

      $params["userID"] = $uid;
      list($cols,$vals) = $this->makeInsertVals($params);
      $query = "REPLACE INTO ".$this->table_preferences." ($cols) values($vals)";
      return( $this->db_result($query) );
   }
      
   function delete_prefs( $uid ) {
      // deletes prefs entries by uid
      // uid can be an array
      
      $query = "DELETE FROM ".$this->table_preferences." WHERE userID = $uid";
      return( $this->db_result($query) );
   }
   
   
   /*
    *  SYSTEM ADMINISTRATION
   */
   
   
   function add_setting( $params ) {
      // add a new setting into the db
      
      return( $this->db_insert($this->table_settings, $params) );
   }
   
   function delete_setting( $setID ) {
      // remove a setting based on it's setID
      // setID can be an array      
      
      $where = (is_array($setID))?
	" setID IN(".join(",",$setID).")" : " setID = $setID";
      $query = "DELETE FROM ".$this->table_settings." WHERE $where";
      return( $this->db_result($query) );
   }
   
   function update_setting( $setID, $params ) {
      // update a setting based on it's setID
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_settings." SET $set WHERE setID = $setID";
      return( $this->db_result($query) );
   }
   
   function add_bin( $params ) {
      // add a new bin to the bins table
      
      return( $this->db_insert( $this->table_bins, $params ) );
   }
   
   function delete_bin( $bid ) {
      // remove a bin by the bid (bin ID)
      // bid can be an array
      
      $where = (is_array($bid))? " bid IN(".join(",",$bid).")" : " bid = $bid";
      $query = "DELETE FROM ".$this->table_bins." WHERE $where";
      return( $this->db_result($query) );
   }
   
   function update_bin( $bid, $params ) {
      // update properties for a given bid (bin id)
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_bins." SET $set WHERE bid = $bid";
      return( $this->db_result($query) );
   }
   
   function add_system( $params ) {
      // add a new system to the db
      
      return( $this->db_insert( $this->table_systems, $params ) );      
   }
   
   function delete_system( $sid ) {
      // delete a system from the db via the
      // sid (systemID)
      // $sid can be an array
      
      $where = (is_array($sid))? " sid IN(".join(",",$sid).")" : " sid = $sid ";
      $query = "DELETE FROM ".$this->table_systems." WHERE $where";
      return( $this->db_result($query) );
   }
   
   function update_system( $sid, $params ) {
      // update settings for a given 
      // sid (systemID)
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_systems." SET $set WHERE sid = $sid";
      return( $this->db_result($query) );      
   }
   
   function add_type( $params ) {
      // add a new ticket type
      
      return( $this->db_insert($this->table_types, $params) );
   }
   
   function delete_type( $typeID ) {
      // delete a ticket type by
      // the typeID (can be an array)
      
      $where = (is_array($typeID))?  " typeID IN(".join(",",$typeID).")" : "typeID = $typeID";
      $query = "DELETE FROM ".$this->table_types." WHERE $where";
      return( $this->db_result($query) );
   }
   
   function update_type( $typeID, $params ) {
      // update a ticket type by the typeID
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_systems." SET $set WHERE typeID = $typeID";
      return( $this->db_result($query) );            
   }
   
   
   /*
    *  ACCESS UTILITIES
   */
   
   
   function login_user( $username, $password ) {
      // perform a login check for username and password
      // returns the user's uid
      
      $query = "select uid from ".$this->table_users
	." where login = '$username' and passwd = '".md5($password)."'";
      $uid = $this->db_get($query);
      if( $uid )
	$this->getUser($uid);
      return($uid);
   }
   
   function check_bin_access( $uid, $binID, $level = 1 ) {
      // check the user's access priviledges for the given binID
      // based on the users uid. and $level (returns true
      // if equal to or greater than this)
      
      $access =  $this->getAccess( $uid );
      return( ($access["$binID"] >= $level) );
   }
   
   
   /*
    *  TOOLS 
   */
   
   
   function check_status( $id, $code = 'OPEN' ) {
      // checks to see if a ticket is ready for the 
      // given action, the $code codes are:
      //    OPEN    - is open?
      //    PEND    - is pending?
      //    TEST    - ready for testing?
      //    APPR    - ready for approval?
      //    READY   - ready for closing?
      //    CLOSED  - is closed?
      // returns 1 if $code can be met
      $c = strtoupper(substr($code,0,2));
      $ticket = $this->get_ticket($id);
      if( $c == 'OP' ) {
	 if( $ticket["status"] == 'OPEN' )
	   return 1;
      } else if( $code == 'PE' ) {
	 if( $ticket["status"] == 'PENDING' )
	   return 1;
      } else if( $code == 'TE' ) {
	 if( $ticket["status"] == 'PENDING' && ($ticket["tested"] == 1) )
	   return 1;
      } else if( $code == 'AP' ) {
	 if( $ticket["status"] == 'PENDING' && $ticket["tested"] != 1 )
	   return 1;
      } else if( $code == 'RE' ) {
	 if( ($ticket["status"] == 'PENDING' && $ticket["tested"] == 2 && $ticket["approved"] == 2)
	      ||
	     ($ticket["status"] == 'OPEN' && $ticket["tested"] == 0 && $ticket["approved"] == 0))
	   return 1;
      } else if( $code == 'CL' ) {
	 if( $ticket["status"] == 'CLOSED' )
	   return 1;
      }
   }   
   
   function fetch_bin_roles( $binID, $role = '' ) {
      // fetches members of bin with a particular
      // role.  If $role is given, fetches only
      // members listed as fulfilling that particular
      // role. Returns the userID and their role in an
      // indexed array
      
      $where = ($role)? " binID = $binID and role = '$role'" : " binID = $binID";
      $fields = ($role)? " userID " : " userID, role ";
      $query = "SELECT $fields FROM ".$this->table_access." WHERE $where ORDER BY priority";
      return( $this->db_queryIndexed($query) );
   }
									
   function fetch_user_roles( $userID, $binID = '' ) {
      // fetches a specific user's roles in zenTrack
      // if binID is given, returns only roles for that specific bin
      // returns the binID and role in an indexed array
      
      $where = ($binID)? " userID = $userID AND binID = $binID " : " userID = $userID ";
      $query = "SELECT binID, role FROM ".$this->table_access." WHERE $where ORDER BY priority";
      return( $this->db_queryIndexed($query) );
   }
   
   function format_name( $uid, $flag = '' ) {
      // alias for formatName()      
      return($this->formatName($uid, $flag));
   }
   
   function formatName( $uid, $flag = '' ) {
      // if the user properties are available, pass those here
      // otherwise pass the user id, and he/she will be retrieved
      // from the db (user properties can be passed as an array in
      // place of $id)
      // if $flag = 2, then returns "initials"
      // if $flag = 1, then returns "lname, fname"
      // if !$flag, then returns "fname lname"
      
      if( is_array($uid) )
	$user = $uid;
      else
	$user = $this->get_user($uid);
      
      if( !is_array($user) )
	return( $this->settings["bot_name"] );
      if( $flag == 2 )
	return( $user["initials"] );
      else if( $flag == 1 )
	return( $user["lname"].", ".$user["fname"] );
      else
	return( $user["fname"]." ".$user["lname"] );
   }

   function percentWorked( $etc = 0, $wkd = 0 ) {
      // determines the percent completion for this
      // project
      
      if( $etc > 0 ) {
	 return( ($wkd/$etc*100) );
      }
   }   
   
   function formatEmailMessage( $params ) {
      // takes a list of input parameters and makes
      // a formatted message to be sent, including links 
      // and information about the ticket referenced
      // special params:
      //     message - printed at the top of the email with
      //               line breaks afterwards
      //     body    - printed with extra line breaks
      //     tid     - retrieves the ticket by this id and 
      //               includes it in the email body
      //     log     - retrieves log entries for this ticket
      //               by the id given by log, limited by the
      //               system setting email_max_logs
      //     link    - displays a link to the ticket
      //               (this is done with the tid property too,
      //                use this one instead of tid to display
      //                the link only)
      // all others are printed as is, with html stripped
      
      if( $params["message"] ) {
	 // insure the message gets printed first
	 $message = $params["message"]."\n\n";
	 unset($params["message"]);
      }
      
      // loop through the parameters and print them
      foreach( $params as $k=>$v ) {
	 if( $k == 'body' ) {
	    // include the body of the message
	    $message .= "\n\n$v\n\n";
	 } else if( $k == 'link' ) {
	    $message .= $this->settings["url_view_ticket"]."?id=$v";	    
	 } else if( $k == 'tid' ) {
	    // print a summary of the ticket
	    $message .= "\n\n--- TICKET SUMMARY ---\n\n";
	    $t = $this->get_ticket($v);
	    $url = $this->settings["url_view_ticket"]."?id=$v";
	    $n = $t["binID"];
	    $u = $t["userID"];
	    $s = $t["systemID"];
	    if( $t["userID"] ) {
	       $name = $this->formatName($t["userID"]);
	    } else {
	       $name = "n/a";
	    }
	    $message .= "$t[title]\n\n";	    
	    $message .= "ID:\t$t[id]\n";
	    $message .= "Status:\t$t[status]\n";
	    $message .= "Deadline:\t".$this->showDate($t["deadline"])."\n";
	    $message .= "Bin:\t".$this->bins[$n]."\n";
	    $message .= "Owner:\t$name\n";
	    $message .= "URL:\t$url\n";
	    $message .= "\n\n".htmlentities($t[description])."\n\n------------------\n\n";
	 } else if( $k == "log" ) {
	    // print the log for the ticket
	    if( $this->settings["email_max_logs"] )
	      $lim = $this->settings["email_max_logs"];
	    $logs = $this->get_logs($v, 'created DESC', $lim);
	    $message .= "\n\n";
	    if( is_array($logs) ) {
	       $att = $this->get_attachments($v,null,1);	       
	       $message .= "LOG ENTRIES\n\n";
	       $sep = "--";
	       foreach( $logs as $l ) {
		  $message .= $this->showDateTime($l["created"],'M');
		  $message .= $sep.str_pad($l["action"],8,"-",STR_PAD_LEFT);
		  $message .= $sep.str_pad($this->formatName($l["userID"],2),6,"-",STR_PAD_LEFT);
		  $message .= (strlen($l["hours"]))? $sep.str_pad($l["hours"],4,"-",STR_PAD_LEFT)." hrs":"";
		  //
		  // the log and attachments
		  if( $l["entry"] ) {
		     $message .= "\n".htmlentities($l["entry"])."\n";
		  }
		  if( $att["$id"]["$lid"] ) {
		     $message .= "\nATTACHMENT(s):\n";
		     foreach( $att["$id"]["$lid"] as $a ) {
			$message .= "$a[name] ($a[description])\n";
			$message .= "\t".$this->attachmentUrl."?file=$a[filename]\n";
		     }
		  }		  
		  $message .= "------------------\n\n";
	       }
	       if( $v > 0 && count($logs) == $v ) {
		  $message .= "\nMore log entries.  View them by logging in and viewing this ticket.\n";
		  if( !$params["tid"] && !$params["link"] ) {
		     $message .= $this->settings["url_view_ticket"]."?id=$v";
		  }
	       }
	    } else {
	       $message .= "No log entries\n";
	    }
	    $message .= "\n";	       
	 } else {
	    // just print whatever is indexed, since it didn't
	    // match any special settings
	    $v = strip_tags($v);
	    $message .= "$k:\t$v\n";
	 }
      }
      return($message);
   }
      
   function sendEmail( $recipients, $subject, $message, $sender = '', $cc = '' ) {
      // send email updates to $recipients
      // $recipients and $sender are the uid of the sender and recipient
      // alternately, $recipients can contain valid email addresses rather 
      // than a uid value (to send to non-zentrack users)
      // $recipients, $sender, and $cc can all be an array
      
      // figure out who sent it
      if( !$sender ) {
	 $sender_address = $this->settings["botName"]."<".$this->settings["botEmail"].">";
      } else {
	 if( eregi("^[0-9]+$", $sender) ) {
	    $s = $this->get_user($sender);
	    $sender_address = $this->formatName($s)." <$s[email]>";
	 } else {
	    $sender_address = $sender;
	 }
      }
      
      // figure out who it is being set to
      if( !is_array($recipients) )
	$recipients = array($recipients);
      foreach($recipients as $r) {
	 if( $recipient_address )
	   $recipient_address .= ", ";
	 if( eregi("^[0-9]+$", $r) ) {
	    $s = $this->get_user($r);
	    $recipient_address .= $this->formatName($s)." <$s[email]>";
	 } else {
	    $recipient_address .= $r;
	 }	 
      }
      
      // create headers and CC fields
      $headers .= "From: $sender_address\n";
      if( $cc ) {
	 if( !is_array($cc) )
	   $cc = array($cc);
	 foreach($cc as $c) {
	    if( $cc_address )
	      $cc_address .= ", ";
	    if( eregi("^[0-9]+$", $c) ) {
	       $s = $this->get_user($c);
	       $cc_address .= $this->formatName($s)." <$s[email]>";
	    } else {
	       $cc_address .= $c;
	    }
	 }
	 $headers .= "cc: $cc_address\n";
      }
      
      // finalize and send the message
      $message = addslashes($message);
      $subject = addslashes($subject);
      return( mail( $recipient_address, $subject, $message, $headers ) );      
   }
   
   function getTicketCount( $status = '', $binID = '' ) {
      // counts the number of tickets matching
      // binID and status (if provided) and returns
      // the total
      
      // figure out the where clause
      if( $binID && $status ) {
	 $where = " WHERE binID = $binID AND status = '$status' ";
      } else if( $binID ) {
	 $where = " WHERE binID = $binID ";
      } else if( $status ) {
	 $where = " WHERE status = '$status' ";
      }
      // prepare and execute the select
      $query = "SELECT COUNT(id) FROM ".$this->table_tickets." $where";
      return( $this->db_get($query) );
   }
   
   
   /*
    *  TRANSLATION UTILITIES
   */
   
   
   function prnString( $identifier, $language = '', $flag = 0 ) {
      // return a language string for printing
      // from the pre-fabbed constructs
      // if $flag is set, then the constructs will
      // be reset
      
      // only get the language if needed, and only once
      if( !$language )
	$language = $this->language;
      // get the strings requested and print them
      $this->getStrings($language,$flag);
      return( $this->strings["$identifier"] );
   }
   
   function prn( $words, $language = '', $flag = 0 ) {
      // take a string or array of words and 
      // return translated content (as much as possible)
      // 
      // this is done by exploding the string on spaces
      // replacing all occurences of words in brackets
      // like such: [:identifier:] with their pre-fabbed
      // constructs, and trying to translate all others
      // from the word table      
      // 
      // if the language changes during execution, the 
      // flag will need to be set to insure they are 
      // refreshed     
      
      if( !$language )
	$language = $this->language;
      // prepare language strings
      $this->getStrings($language,$flag);
      
      // check for incoming format of string
      if( !is_array($words) ) {
	 $words = explode(" ", $words);
	 $join = 1;
      }
      
      // determine what words need to be loaded
      foreach($words as $w) {
	 if( ereg("^[a-zA-Z]+$", $w) && (!$this->words["$w"] || $flag) )
	   $get[] = strtolower($w);
      }
      
      // get words that are needed
      if( is_array($get) )
	$this->getWords($get);
      
      // translate the words
      foreach($words as $w) {
	 if( ereg("^\[:([a-zA-Z0-9 _-]+):]", $w, $matches) ) {
	    // this format ( [:something:] ) indicates a pre-formatted
	    // string which is stored in the ZENTRACK_TRANSLATION_STRINGS
	    // section.  
	    $new_words[] = $this->prnString($matches[1]);
	 } else if( $language != 'english' && ereg("^[a-zA-Z]+$", $w) ) {
	    // this is simply a word to be translated
	    $n = strtolower($w);
	    $r = $this->words["$n"];
	    if( $n != $w ) {
	       if( ucwords($n) == ucwords($w) )
		 $r = ucwords($r);
	       else if( strtoupper($n) == $w )
		 $r = strtoupper($r);
	    }
	    $new_words = $r;
	 } else {
	    // this is something other than a word and will be ignored
	    $new_words[] = $w;
	 }
      }
      
      // return properly formatted results
      if( $join == 1 ) {
	 return( join(" ", $new_words) );
      } else {
	 return( $new_words );
      }
   }
   
   function getStrings( $language = '', $flag = 0 ) {
      // returns an array of the translation strings
      // improves efficiency by preventing multiple 
      // retrievals by storing results in a system var
      // the first time this function is called
      // $flag will override the default and reset these
      // values
      
      if( !$this->strings or $flag ) {
	 if( !$language )
	   $language = $this->language;
	 $query = "SELECT identifier, string FROM "
	   .$this->table_language_strings." WHERE language = '$language'";
	 $vars = $this->db_query($query);
	 if( is_array($vars) )
	   foreach($vars as $v)
	     $vals["$v[0]"] = $v[1];
	 $this->strings = $vals;
      }
   }
   
   function getWords( $words, $language = '' ) {
      // this function fetches words from the db that are
      // required for completing word translations
      // to speed this process up greatly, this function can be called
      // at the beginning of a page, with an array of words that will be 
      // used in that page, requiring only 1 database query for
      // all uses of this execution
      
      if( !$language )
	$language = $this->language;
      $query = "SELECT identifier, translation FROM "
	.$this->table_language_words
	." WHERE language = '$language'"
	." AND identifier IN('".join("','",$words)."')";
      $vals = $this->db_query($query);
      if(is_array($vals)) {
	 foreach($vals as $v) {
	    $this->words["$v[0]"] = $v[1];
	 }
      }
   }
   
   function add_translation_word( $identifier, $translation, $language ) {
      // add a new word to the translations dictionary
      
      $params = array("identifier"=>$identifier,"translation"=>$translation,"language"=>$language);
      return( $this->db_insert($this->table_translation_words,$params) );
   }
      
   function add_translation_string( $identifier, $string, $language ) {
      // add a new string to the pre-made sentences for translations
      
      $params = array("identifier"=>$identifier,"string"=>$string,"language"=>$language);
      return( $this->db_insert($this->table_translation_strings,$params) );
   }
   
  
   /*
    *  SYSTEM UTILS 
   */
   
   
   function getUser( $uid ) {
      // retrieves the user who is logged in 
      // to zenTrack.  This function prevents 
      // multiple queries to retrieve user info
      // on a single page by checking the stored
      // user information and validating the uid
      // first.
      // 
      // Do not use this function for any data other
      // than that of the logged in system user
      
      if( !$this->user || $this->user["uid"] != $uid ) {
	 $this->user = $this->get_user($uid);
      }
      return( $this->user );
   }
   
   function getAccess( $uid ) {
      if( !$this->access || $this->access["userID"] != $uid ) {
	 $this->access = $this->get_access($uid);
	 $this->access["userID"] = $uid;
      }
      return( $this->access );
   }
   
   function checkAccess( $uid, $binID, $action = '' ) {
      // takes the userID, the binID and the action in
      // question, and determines whether the logged in
      // user can perform it
      
      $actions = array(
		       "move"    =>  $this->settings["level_move"],
		       "log"     =>  $this->settings["level_user"],
		       "accept"  =>  $this->settings["level_accept"],
		       "assign"  =>  $this->settings["level_assign"],
		       "yank"    =>  $this->settings["level_yank"],
		       "test"    =>  $this->settings["level_test"],
		       "approve" =>  $this->settings["level_approve"],
		       "reject"  =>  $this->settings["level_sup"],
		       "reopen"  =>  $this->settings["level_sup"],
		       "edit"    =>  $this->settings["level_edit"],
		       "upload"  =>  $this->settings["level_user"]
		       );
      $level = $actions["$action"];
      if( !$level ) {
	 $level = $this->settings["level_view"];
      }
      $access = $this->getAccess($uid);
      if( strlen($access["$binID"]) ) {
	 return( $access["$binID"] >= $level );
      } else {
	 $user = $this->getUser($uid);
	 return( $user["access"] >= $level );
      }
   }
   
   function actionApplicable( $id, $action, $userID = '' ) {
      // check to see if an action is applicable to
      // the current ticket, based on it's status, the
      // logged in users access, and the actions requirements
      // if an array is sent in place of the ticket id, it will
      // be used as the tickets parameters (saving a db lookup)
      
      // actions array contains the following params
      //    0 - must be owner of ticket
      //               0 - false
      //               1 - true
      //               2 - must NOT be owner
      //               3 - must not be owned by anyone
      //               4 - must be owned, and must not be owner
      //    1 - must meet checkAccess
      //    2 - ticket status
      //    3 - supervisor override?
      
      $action = strtolower($action);
      $actions = array(          
		       "move"    => array( 1, 1, array('OPEN','PENDING'), 0 ),
		       "log"     => array( 1, 1, array('OPEN','PENDING'), 1 ),
		       "accept"  => array( 3, 1, array('OPEN'),           0 ), 
		       "assign"  => array( 3, 1, array('OPEN'),           0 ),
		       "yank"    => array( 4, 1, 0,                       0 ),
		       "test"    => array( 0, 1, array('PENDING'),        0 ),
		       "approve" => array( 0, 1, array('PENDING'),        0 ),
		       "reject"  => array( 1, 1, array('OPEN','PENDING'), 0 ),
		       "close"   => array( 1, 1, array('OPEN'),           0 ),
		       "relate"  => array( 1, 1, 0,                       0 ),
		       "reopen"  => array( 0, 1, array('CLOSED'),         0 ),
		       "edit"    => array( 0, 1, array('OPEN','PENDING'), 0 ),
		       "upload"  => array( 1, 1, 0,                       1 )		       
		       );
      $c = $actions["$action"];
      if( is_array($id) ) {
	 $ticket = $id;
	 $id = $ticket["id"];
	 $binID = $ticket["binID"];
      } else { 
	 $ticket = $this->get_ticket($id);
	 $binID = $ticket["binID"];
      }
      if( $c[0] == 2 ) {
	 if( $ticket["userID"] == $userID )
	   return false;
      } else if( $c[0] == 3 ) {
	 if( $ticket["userID"] )
	   return false;
      } else if( $c[0] == 4 ) {
	 if( !$ticket["userID"] || $ticket["userID"] == $userID )
	   return false;
      } else if( $c[0] ) {
	 if( $c[3] ) {
	    $user = $this->get_user($userID);
	    $access = $this->getAccess($userID);
	 }	 
	 if( $ticket["userID"] != $userID ) {
	    if( !$c[3] 
	       || ( strlen($access["$binID"]) && $access["binID"] < $this->settings["level_super"] )
	       || ( !strlen($access["$binID"]) && $user["access"] < $this->settings["level_super"])
	       )
	       return false;
	 }
      }
      if( $c[1] ) {
	 if( !$this->checkAccess($userID, $binID, $action) ) 
	   return false;
      }
      if( $c[2] ) {
	 if( !is_array($c[2]) )
	   $c[2] = array($c[2]);
	 if( !in_array($ticket["status"],$c[2]) )
	   return false;
      }
      if( $action == "approve" && ($ticket["tested"] == 1 || $ticket["approved"] != 1) )
	return false;
      else if( $action == "reject" && !$this->getTicketSender($id) ) 
	return false;
      else if( $action == "test" && $ticket["tested"] != 1 )
	return false;
      
      return true;
   }
   
   function getBins($flag = 0) {
      // if flag is set, retrieves a full
      // indexed array, otherwise, just
      // a list of names, indexed by bid,
      // ordered by priority and alphebetized 
      
      if( !$flag ) {
	 $query = "SELECT bid, name FROM ".$this->table_bins
	   ." WHERE active = 1 ORDER BY priority, name";
	 $vars = $this->db_query($query);
	 foreach($vars as $v) {
	    $vals["$v[0]"] = $v[1];
	 }
	 return($vals);
      } else {
	 $query = "SELECT * FROM ".$this->table_bins
	   ." WHERE active = 1 ORDER BY priority, name";
	 return( $this->db_queryIndexed($query) );
      }
   }

   function checkRelations( $relations ) {
      // takes either an array or comma delimited
      // string.  insures that the tickets to be 
      // related actually exist and returns only
      // the ids that are in db
      
      if( !is_array($relations) ) {
	 $join = 1;
	 $relations = ereg_replace("[^0-9,]", "", $relations);
	 $relations = explode(",",$relations);
      }
      foreach($relations as $r) {
	 if( $this->get_ticket($r) ) {
	    $vals[] = $r;
	 }
      }
      if( $join ) {
	 return( join(",",$vals) );
      } else {
	 return( $vals );
      }
   }   
   
   function getTasks() {
      // if flag is set, retrieves an
      // indexed array, otherwise, just
      // a list of names ordered by priority
      // and alphebetized      

      if( !$flag ) {
	 $query = "SELECT name FROM ".$this->table_tasks." ORDER BY priority, name";
	 return( $this->db_list($query) );
      } else {
	 $query = "SELECT * FROM ".$this->table_tasks." ORDER BY priority, name";
	 return( $this->db_queryIndexed($query) );
      }            
   }
   
   function getSystems() {
      // if flag is set, retrieves an
      // indexed array, otherwise, just
      // a list of names ordered by priority
      // and alphebetized
      
      if( !$flag ) {
	 $query = "SELECT name FROM ".$this->table_systems." ORDER BY priority, name";
	 return( $this->db_list($query) );
      } else {
	 $query = "SELECT * FROM ".$this->table_systems." ORDER BY priority, name";
	 return( $this->db_queryIndexed($query) );
      }            
   }
   
   function getPriorities( $flag = 0 ) {
      // if flag is set, retrieves all
      // details in an unordered list
      // otherwise, retrieves an indexed
      // list sorted by priority
      
      if( !$flag ) {
	 $query = "SELECT priority,name FROM ".$this->table_priorities." ORDER BY priority desc, name";
	 $vars = $this->db_query($query);
	 for($i=0; $i<count($vars); $i++) {
	    $p = $vars[$i][0];
	    $vals[$p] = $vars[$i][1];
	 }
	 return($vals);
      } else {
	 $query = "SELECT * FROM ".$this->table_priorities." ORDER BY priority, name";
	 return( $this->db_queryIndexed($query) );
      }            
   }
   
   function statusHighlight( $priority ) {
      // prints out status with proper <span>
      // tags to highlight critical status items
      
      if( $priority <= $this->settings["level_hot"] ) {
	 $pri = "hot";
      } else if( $priority <= $this->settings["level_highlight"] ) {
	 $pri = "highlight";
      } else {
	 $pri = "";
      }
      return $pri;
   }
      
   function getSettings($flag = 0) {
      // pulls the variables from the settings table
      // into an indexed array.
      // if flag is set, then it retrieves all
      // data for the settings into an array
      // otherwise, just sets a string equal to the value
      
      $fields = ($flag)? "*" : "name, value";
      if( $flag )
	$order = " ORDER BY name";
      $query = "SELECT $fields FROM ".$this->table_settings." $order";
      $vars = $this->db_queryIndexed($query);
      foreach($vars as $v) {
	 $vals["$v[name]"] = ($flag)? $v : $v["value"];
      }
      return($vals);
   }
   
   function getTypes() {
      // if flag is set, retrieves an
      // indexed array, otherwise, just
      // a list of names ordered by priority
      // and alphebetized
      
      if( !$flag ) {
	 $query = "SELECT name FROM ".$this->table_types." ORDER BY priority, name";
	 return( $this->db_list($query) );
      } else {
	 $query = "SELECT * FROM ".$this->table_types." ORDER BY priority, name";
	 return( $this->db_queryIndexed($query) );
      }            
   }

   function getProjectChildren( $pid, $columns = '', $archive_flag = 0 ) {
      // returns array of tickets for the project by its pid ($pid)
      // this is seperated from the get_tickets() for abstraction
      // (i.e. future expansion compatability)
      // the returned values of getProjectChildren() will always be
      // unsorted if using $columns (sorry!)
      
      $params = array("projectID"=>$pid);
      $sort = "status desc, priority, otime desc";
      $vars = $this->get_tickets($params, $sort, $columns, $archive_flag);
      return( $vars );
   }
   
   function getProjectHours( $pid, $archive_flag = 0 ) {
      $columns = array("id","est_hours","wkd_hours","typeID");
      $tickets = $this->getProjectChildren($pid,$columns,$archive_flag);
      for( $i=0; $i<count($tickets); $i++ ) {
	 $t = $tickets[$i];
	 if( $t["typeID"] == $this->projectTypeID() ) {
	    list($eh,$wh) = $this->getProjectHours($t["id"],$archive_flag);
	    $est_hours += $eh;
	    $wkd_hours += $wh;
	 } else {
	    $est_hours += $t["est_hours"];
	    $wdk_hours += $t["wkd_hours"];
	 }
      }
      return( array($est_hours,$wkd_hours) );
   }   
   
   function getTicketSender( $id ) {
      $query = "SELECT userID,binID FROM "
	.$this->table_logs
	." WHERE ticketID = $id"
	." AND (action = 'MOVED' OR action = 'ASSIGNED')"
	." ORDER BY created DESC"
	." LIMIT 1";
      return( $this->db_quickIndexed($query) );
   }
   
   function projectTypeID() {
      // returns the binID associated with projects
      // this function prevents multiple calls for this
      // id by storing it the first time it is called
      if( !strlen($this->projectTypeID) ) {
	 foreach( $this->types as $k=>$b ) {
	    if( eregi("project",$b) ) {
	       $this->projectTypeID = $k;
	       break;
	    }
	 }
      }
      return $this->projectTypeID;
   }
   
   /*
    *  INVOKE 
   */
   
   
   function zenTrack( $file, $user = '', $language = '' ) {
      // $file is the configuration file
      // containing all of the settings for
      // zenTrack to use during operation
      // $user is the logged in userid for this
      // user.  If given, then the user will be retrieved
      // and saved for use in other methods (to
      // prevent multiple queries)
      // if $language is given, it will override the value
      // from the configVars file
      
      include("$file");
      
      $this->zen();
      $this->DB( $this->database_host, $this->database_login, $this->database_password, $this->database_instance);
      
      putenv( "ORACLE_SID=".$this->database_instance); //oracle specific requirement
      
      $this->bins        = $this->getBins();
      $this->systems     = $this->getSystems();
      $this->strings     = $this->getStrings($this->language);
      $this->settings    = $this->getSettings();
      $this->settings["font_size_small"] = $this->settings["font_size"] - 2;
      $this->settings["font_size_large"] = $this->settings["font_size"] + 4;
      // this is a quick hack to fix an oops
      // should eventually go through code and fix this
      $this->settings["color_title_txt"] = $this->settings["color_title_text"];
      $this->types       = $this->getTypes();
      $this->priorities  = $this->getPriorities();
      $this->tasks       = $this->getTasks();
      
      if( $user ) {
	 $this->user = $this->get_user($uid);
	 $this->access = $this->get_access($uid);
      }
      if( $language )
	$this->language = $language;
   }
   
  
   /*
    *  REPORTING FUNCTIONS (incomplete... add later)
   */     
   
   
   function report_user( $uid, $start = '', $end = '' ) {
      // will fetch all tickets assigned to this user
      // all actions conducted by this user, and 
      // calculate summary report as well
      // $start is the oldest date to be retrieved (unix timestamp)
      // $end is the newest date to be retrieved (unix timestamp)
      
      
   }
   
   function report_project( $id, $start = '', $end = '' ) {
      // will retrieve all tickets associated with project
      // and actions conducted on project and produce an 
      // overall summary for the time period
      // $start is the oldest date to be retrieved (unix timestamp)
      // $end is the newest date to be retrieved (unix timestamp)
      
   }
   
   function report_ticket( $id, $start = '', $end = '' ) {
      // will retrieve all actions and logs for this ticket, 
      // and produce a summary report for the given
      // time period
      // $start is the oldest date to be retrieved (unix timestamp)
      // $end is the newest date to be retrieved (unix timestamp)
      
   }
   
   function report_compare( $type, $start, $end ) {
      // will retrieve all actions, logs, tickets created, closed, etc
      // based on one of the following parameters:
      //    bins
      //    types
      //    systems
      //    priorities
      //    users
      //    projects
      // start and end times are required!
      // $start is the oldest date to be retrieved (unix timestamp)
      // $end is the newest date to be retrieved (unix timestamp)
      
   }
   
   
   /*
   **  VARIABLES TO CONFIGURE (in config file)
   */
   
   
   // usage vars
   var $user;
   var $access;
   var $ticket;
   var $id;
   var $date_format_long;
   var $date_format_short;
   
   // settings vars
   var $settings;
   
   var $bins;
   var $priorities;
   var $systems;
   var $tasks;
   var $types;
   
   var $language;
   var $strings;
   var $words;
   
   
   // db vars   
   
   var $table_access;
   var $table_attachments;
   var $table_bins;
   var $table_logs;   
   var $table_logs_archived;
   var $table_preferences;
   var $table_priorities;
   var $table_settings;
   var $table_systems;
   var $table_tasks;
   var $table_tickets;
   var $table_tickets_archived;
   var $table_types;
   var $table_users;
   var $table_translation_strings;
   var $table_translation_words;

   var $database_type;
   var $database_instance;
   var $database_login;
   var $database_password;
   var $database_host;
                       
   // directory vars
   var $libDir;
   var $listDir;
   var $templateDir;
   var $attachmentsDir;
   
   // others

   var $projectTypeID; 
}
 
?>
