<?
  /* 
  **  zenTrack Class
  **
  **  Author: Kato "phpzen"
  **  Description: Ticketing system functions
  **  Version: See CVS Repository for version information
  **  Created: 02/22/21
  **  Email:  postmaster@phpzen.net
  **  URL: http://www.phpzen.net
  **
  **  This is the main class containing all of the functionality for use
  **  with the zentrack system.  This class extends zen (basic text formatting
  **  and page utilities), zenDate (date manipulations and calculations) and 
  **  db.class (database access and retrieval)
  */

include_once("$libDir/zen.class");  
  
class zenTrack extends zen {

   
   /*
    *  RETRIEVAL 
   */
   
   
   function get_access( $user_id, $flag = 0 ) {
      // retrieves the access priviledges
      // by the user_id (user id)
      // if flag set to 1, then it returns
      // a simple array containing all the columns
      //  ( [0] = array(..all columns in db..) )
      // otherwise, returns an array indexed by bin_id, 
      // with a value of the level for that bin
      //  ( ["bin_id"] = $bin_level )
      
      $query = "SELECT * FROM ".$this->table_access." WHERE user_id = $user_id "
	." AND lvl is not null";
      $this->addDebug("get_access()Query",$query,3);
      $vars = $this->db_queryIndexed($query);
      if( $flag ) {
	return $vars;	
      } else {	
	if( is_array($vars) ) {
	  foreach($vars as $v) {
	    $vals["$v[bin_id]"] = $v["lvl"];
	  }
	}
	return( $vals );
      }
   }   
   
   function get_attachment($access_id) {
      // retrieves all properties for a given attachment
      // this is by the attachment_id and not the ticket or log ID
      // and creates a file location to the actual 
      // attachment which is stored as ["location"]
      
      $query = "SELECT * FROM ".$this->table_attachments." WHERE attachment_id = $access_id";
      $vars = $this->db_quickIndexed($query);
      if( is_array($vars) ) {
    $vars["location"] = $this->attachmentsDir."/".$vars["name"];
      }
      return($vars);
   }

   function get_attachments($id, $flag = 0, $indexed = 0) {
      // retrieves all attachements for a given ticket_id
      // indexed by log entry they are associated with
      // if $flag = 1, retrieves by log_id instead of ticket_id
      // if $indexed = 1, then retrieves in a complex array
      // indexed by ticket_id and log_id as follows:
      // $vals["ticket1"]["log1"] = array(datarow)
      // otherwise, returns in a simple, non-indexed array
      
      $field = ($flag)? "log_id" : "ticket_id";
      $where = (is_array($id))?
   " $field IN(".join(",",$id).")" :
        " $field = $id";
      $query = "SELECT * FROM ".$this->table_attachments." WHERE $where ORDER BY name";
      $vars = $this->db_queryIndexed($query);
      if( $indexed ) {
    for( $i=0; $i<count($vars); $i++ ) {
       $n = $vars[$i]["log_id"];
       $v = $vars[$i]["ticket_id"];
       $vals["$v"]["$n"][] = $vars[$i];
    }
      } else {
    $vals = $vars;
      }
      return($vals);
   }   
   
   function get_log( $lid ) {
      // returns a specific logs data
      $query = "SELECT * FROM ".$this->table_logs." WHERE lid = $lid";
      return( $this->db_quick($query) );
   }

   function get_logs( $id, $sort = 'created DESC', $limit = '' ) {
      // retrieve log entries for the given ticket id
      // $limit specifies the max number to return      
      $query = "SELECT * FROM ".$this->table_logs." WHERE ticket_id = $id";
      if( $sort )
   $query .= " ORDER BY $sort";
      if( $limit )
   $query .= " LIMIT $limit";
      return( $this->db_queryIndexed($query) );
   }  
   
   function get_project( $pid, $archive_flag = 0 ) {
      // retrieves all properties from database for given
      // project.  Also returns the following:
      //    children -  an array of tickets that belong to this project 
      //    est_hours - is the estimated time for all tickets associated with 
      //                this project
      //    wkd_hours - is the total hours worked on all tickets for this project
      //    percent_hours - is the percentage completion based on est_ and wkd_
      // if $archive_flag = 1, then will look in archived tickets instead of 
      // active tickets table
      
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "SELECT * FROM $table WHERE id = $pid";
      $vars = $this->db_quickIndexed($query);
      list($vars["est_hours"], $vars["wkd_hours"]) = $this->getProjectHours($pid, $archive_flag);
      $vars["children"] = $this->getProjectChildren($pid, NULL, $archive_flag);
      return($vars);
   }
   
   function get_projects( $params, $sort = 'priority, otime desc', $archive_flag =0 ) {
      // retrieves a list of projects
      // see getTickets() for a list of valid params
      // (with the exception of 'type_id' which is set to
      // the id for projects)
      // note that this does not return an accurate result
      // for est_hours and wkd_hours.  Use getProjectHours() 
      // to determine these values
      // if $archive_flag = 1, then retrieves from archive table
      
      $params["type_id"] = $this->projectTypeID();
      return( $this->get_tickets($params, $sort, NULL, $archive_flag) );
   }
   
   function get_ticket( $id, $archive_flag = 0 ) {
      // retrieves the properties for a 
      // specific ticket by id
      // use get_project() instead for projects
      // to retreive accurate est_hours and wkd_hours relative
      // to a project and all it's children
      // $archive_flag retrieves tickets from archive db instead
      // of the ticket db
      
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "SELECT * FROM $table WHERE id = $id";
      return( $this->db_quickIndexed($query) );
   }
   
   function get_tickets( $params = '', $sort = 'priority, otime desc', $columns = '', $archive_flag = 0 ) {
      // retrieves a list of tickets
      // $params can contain:
      //     bins  - string/array of bins to retrieve for
      //     users - string/array of users to retrieve for
      //     id    - an array of specific ticket ids to retrieve
      // the default columns returned can be overriden by using $columns to 
      // specify what should be returned from this function.  Note that the 
      // sort must correspond to the $columns values for SQL compatibility
      
      $table = ($archive_flag)? 
   $this->table_tickets_archived : $this->table_tickets;
      
      if( !is_array($columns) )
   $columns = array("*");
   
      if( is_array($params) ) {
    $where = "WHERE ".$this->simpleWhere($params);
      }
      $query = "SELECT ".join(",",$columns)." FROM $table $where";
      if( $sort )
   $query .= " ORDER BY $sort";
      return( $this->db_queryIndexed($query) );
   }      
   
   function get_user( $user_id ) {
      // returns a specific user
      // by the user id
            
      $query = "SELECT * FROM ".$this->table_users." WHERE user_id = $user_id";
      return( $this->db_quickIndexed($query) );
   }

   function get_users( $bins = '', $level = 'level_view', $active = 1, $sort = 'lname, fname' ) {
     // creates a list of users
     // $bins is an optional array/string of binIDs
     // to which the users returned will have access
     // $level is the level of access required ("level_view","level_user",etc)
     // which defaults to "level_view" if unspecified
     // if $active is set to 1, then only retrieves 
     // accounts which are currently activated

      if( !is_array($bins) && strlen($bins) ) {
   if( ereg(",",$bins) ) 
     $bins = explode(",",$bins);
   else
     $bins = array($bins);
      }
      $level = ($this->settings["$level"])? $this->settings["$level"] : 0;
      if( $bins ) {
   $query = "SELECT DISTINCT user_id FROM ".$this->table_access." WHERE bin_id IN(".join(",",$bins).") AND lvl >= $level";
   $ids = $this->db_list($query);
      } 
      if( is_array($ids) ) {
    $where = " (user_id IN(".join(",",$ids).") OR access_level >= $level) ";
      } else {
    $where = " access_level >= $level ";
      }
      if( $active )
   $where .= " AND active = 1 ";
      if( $where )
   $where = "WHERE $where";
      if( $sort )
   $sort = "ORDER BY $sort";
      $query = "SELECT * FROM ".$this->table_users." $where $sort";
      $this->addDebug("get_users()Query",$query,2);
      return( $this->db_queryIndexed($query) );
   }
   
   
   
   /*
    *  SEARCH FUNCTIONS 
   */
   
   
   
   function search_logs( $params, $offset = 0, $archive_flag = 0 ) {
     // search through log entries for given text
     // params is an indexed array with two elements:
     //   $params[key][0] = LIKE, =, >, <, >=, etc..
     //   $params[key][1] = '%value', '%value%', lower('value'), etc
     // see db.class complexWhere() for more details concerning
     // the params array
     // this function requires the values to be provided with single
     // quotes and escape chars in place, they will not be added!
     // if archive_flag = 1, then searches ticket archives as well
     // if archive_flag = 2, then searches archives only
     
      $columns = array(
             "lid",     "ticket_id", 
             "user_id",  "action",
                  "entry",   "bin_id"
             );
      
      $where = $this->build_search_clause($params, "AND");
      if( $archive_flag )
   $tables = ($archive_flag == 2)? 
      $this->table_logs_archived : 
      $this->table_logs_archived.", ".$this->table_logs;
      else
   $tables = $this->table_logs;
      $query = "SELECT ".join(",",$columns)." FROM $tables WHERE $where ORDER BY created DESC";
      $this->addDebug("search_logsQuery",$query,2);
      return(  $this->db_queryIndexed($query) );
   }
   
   function search_tickets( $params, $andor = 'AND', 
             $archive_flag=0,$order_by='status DESC, priority' ) {
      // search through tickets for given text
      // acceptable params are:
      // params is an indexed array with two elements:
      //   $params[key][0] = LIKE, =, >, <, >=, etc..
      //   $params[key][1] = '%value', '%value%', lower('value'), etc
      // see db.class->build_search_clause() for details concerning
      // the params array
      // if archive_flag = 1, then searches ticket archives as well
      // if archive_flag = 2, then searches archives only
      
      $where = $this->build_search_clause($params, $andor);
      if( $archive_flag )
   $tables = ($archive_flag == 2)? 
        $this->table_tickets_archived : 
        $this->table_tickets_archived.", ".$this->table_tickets;
      else
   $tables = $this->table_tickets;
      $query = "SELECT * "
   ." FROM $tables WHERE $where"
        ." ORDER BY $order_by";
      $this->addDebug("search_ticketsQuery:",$query,2);
      return(  $this->db_queryIndexed($query) );      
   }

   function search_users( $params, $andor = "AND", $order_by = 'lname,fname' ) {
     // search for users and return a detailed list
     // of users who match the criteria given
     // see db.class->build_search_clause() for details about
     // constructing a $params array

     $table = $this->table_users;
     $where = $this->build_search_clause($params,$andor);
     $query = "SELECT * FROM $table WHERE $where"
       ." ORDER BY $order_by";
     $this->addDebug("search_users()Query",$query,2);
     return( $this->db_queryIndexed($query) );
   }
   
   
   /*
    *  PROJECT ADMINISTRATION 
   */
   

   function add_project( $params ) {
      // create a new project with the given params
      // (abstracted from add_ticket() to allow
      // for custom functionality)
      // all dates are to be sent as unix timestamps
      
      $params["type_id"] = $this->projectTypeID();
      unset($params["est_hours"]);
      unset($params["wkd_hours"]);
      return( $this->add_ticket($params) );
   }
   
   function delete_project( $pid, $archive_flag = 0 ) {
      // drop project, all associated tickets
      // all log entries of those tickets, and
      // all their data from the db
      // if $archive_flag = 1, then deletes from the
      // archive table
      
      $children = $this->getProjectChildren($pid, array('id'), $archive_flag);
      for($i=0; $i<count($children); $i++) {
    $ids[] = $children["id"];
      }
      //drop the tickets under this project      
      $this->delete_ticket($ids, $archive_flag); 
      $this->delete_log($pid, NULL, $archive_flag);
      $table = ($archive_flag)? $this->table_tickets_archived : $this->table_tickets;
      $query = "DELETE FROM $table WHERE id = $pid";
      return( $this->db_result($query) );
   }
   
   function archive_project( $pid ) {   
      // send a project to the archives
      // and all of it's related tickets and logs
      
      $children = $this->getProjectChildren($pid, array('id'));
      foreach($children as $c) {
    $this->archive_ticket($c["id"]);
      }
      $fields = $this->db_get_fields($this->table_tickets_archived);
      $query = "INSERT INTO "
   .$this->table_tickets_archived." ($fields) SELECT $fields FROM ".$this->table_tickets
   ." WHERE id = $pid";
      $res = $this->db_result($query);
      $this->archive_log($pid);
      $this->delete_project($id);
      return( $res );
   }
   
   function close_project( $pid, $params = '', $override = 0 ) {
      // sets the status of a project to 'CLOSED' assuming
      // that the project doesn't require testing and approval
      // and that all children are closed (otherwise will skip)
      // if $override is passed, then this method will
      // close a project, even if testing or approval are
      // required, or there are open children.
      // $params is an array passed on to the log function
      //   (user_id, comments)
      
     if( $override || $this->check_status($pid, 'READY') ) {
       $children = $this->getProjectChildren($pid, array('id'));
       for( $i=0; $i<count($children); $i++ ) {
	 $this->close_ticket($children[$i]);    
       }
       return( $this->change_status($pid, 'CLOSED', $params) );    
     }
   }
   
   
   /*
    *  TICKET ACTIONS 
   */
   

   function accept_ticket( $id, $user_id, $comments = '', $bin_id = '' ) {
     // changes the tickets user_id to reflect
     // a new owner for the ticket
     // logs this in the db if settings["log_accept"] = "On";
     
     $params = array( "user_id" => $user_id );
     $res = $this->update_ticket($id,$params);
     if( $res && $this->settings["log_accept"] == "on" ) {
       $logParams = array(
			  "action"   =>  'ACCEPTED',
			  "user_id"   =>  $user_id,
			  "ticket_id" =>  $id
			  );
       if( !$bin_id ) {
	 $t = $this->get_ticket($id);
	 $bin_id = $t["bin_id"];
       }
       $logParams["bin_id"] = $bin_id;
       if( $comments )
	 $logParams["entry"] = htmlentities($comments);   
       $res = $this->add_log($id, $logParams);
     }
     return( $res );
   }
   
   function approve_ticket( $id, $user_id, $comments = '' ) {
     // changes the approval status to 2 for the ticket
     // if the ticket is ready for closure, then this function
     // will also close out the ticket
     
     $t = $this->get_ticket($id);
     $params = array("approved"=>2);
     $res = $this->update_ticket($id,$params);
     if( $res && $this->settings["log_approve"] ) {
       $logParams = array(
			  "action"   =>  'APPROVED',
			  "user_id"   =>  $user_id,
			  "ticket_id" =>  $id
			  );
       $logParams["bin_id"] = $t["bin_id"];
       if( $comments )
	 $logParams["entry"] = htmlentities($comments);
       $this->add_log($id, $logParams);    
     }     
     if( $t["tested"] != 1 ) {
       $res = $this->close_ticket($id);
     }
     else if( $this->settings["email_pending"] == "on" ) {
       $bin = $t["bin_id"];
       $vars = $this->fetch_bin_roles($bin,'manager');
       if( is_array($vars) ) {
	 foreach($vars as $v) {
	   $recipient[] = $v["user_id"];
	 }
       }
       if( is_array($recipient) ) {
	 $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	 $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	 if( $comments )
	   $emailParams["body"] = htmlentities($comments);
	 $emailParams["tid"] = $id;
	 $message = $this->formatEmailMessage($emailParams);
	 $this->sendEmail($recipient,$subject,$message,$user_id);
       }       
     }
     return( $res );
   }
   
   function assign_ticket( $id, $recipient, $user_id = '', $comments = '' ) {
      // set the user_id for the ticket to another person
      // the recipient recieves the ticket, the user_id is for the 
      // sender
      
      $params = array( "user_id" => $recipient );
      $res = $this->update_ticket($id, $params);
      if( $res ) {
   // move the ticket somewhere that the user
   // will be able to access it, if required
   $ticket = $this->get_ticket($id);
   $userBins = $this->getUsersBins($recipient,"level_user");
   if( is_array($userBins)&&!in_array($ticket["bin_id"],$userBins) ) {
     $user = $this->get_user($recipient);
     if( $user["homebin"] ) {
       $this->move_ticket($id,$user["homebin"]);
     }
     else {
       $this->move_ticket($id,$userBins[0]);
     }
   }
      }
      if( $res && $this->settings["log_assign"] == 'on' ) {
    $logParams = array(
             "action"   =>  'ASSIGNED',
             "user_id"   =>  $user_id
             );
    $t = $this->get_ticket($id);
    $logParams["bin_id"] = $t["bin_id"];
    $logParams["entry"] = "ASSIGNED TO ".$this->formatName($recipient,1);
    if( $comments )
      $logParams["entry"] .= "\n\n".$comments;
    $this->add_log($id, $logParams);                
      }
      if( $res && $this->settings["email_assign"] == "on" ) {
    $subject = "[".$this->settings["system_name"]."] ticket #$id assigned to you";
    $emailParams["Assigned by"] = $this->formatName($user_id);
    if( $comments )
      $emailParams["body"] = htmlentities($comments);
    $emailParams["tid"] = $id;
    $message = $this->formatEmailMessage($emailParams);
    $this->sendEmail($recipient,$subject,$message,$user_id);
      }
      return( $res );
   }   

   function attach_to_ticket( $id, $user_id, $params, $log_id = '' ) {
     // creates an attachment to the given ticket and logs
     // the event if needed
     // the params array contains:
     //     name         - name of the file to display
     //     filename     - name of file on system
     //     filetype     - mime type (i.e. image/gif)
     //     description  - [optional] comments about the file for display
     extract($params);
     $res = $this->add_attachment($name, $filename, $filetype, $id, $log_id, $description);
     if( $res && $this->settings["log_attachment"] == 'on' ) {
       $logParams = array(
           "user_id"   => $user_id,
           "action"   => "ATTACHMENT"
           );
       $logParams["entry"] = "$name--$filetype";
       if( $description )
    $logParams["entry"] .= "--".$description;   
       if( $log_id )
    $logParams["entry"] .= "\nattached to log $log_id";
       $r = $this->add_log( $id, $logParams );
       if( !$r )
    die("couldn't log it");
     }
     return $res;
   }
      
   function close_ticket( $id, $user_id = '', $hours = '', $comments = '' ) {
     // closes the ticket (sets the status to CLOSED)
     // if there is testing or approval yet required, then
     // simply sets status to pending.
     // however, if both of these are completed, then 
     // closes out the ticket

     // get ticket info
     $t = $this->get_ticket($id);
     if( $this->check_status($t,"READY") ) {
       // if ticket is ready to close, then close it
       $params = array(
		       "status"  =>  'CLOSED',
		       "user_id"  =>  'NULL',
		       "ctime"   =>  $this->currTime
		       );
       $res = $this->update_ticket($id, $params);
       if( $this->settings["log_close"] == "on" ) {
	 // create a log entry
	 $logParams = array(
			    "action"   =>  'CLOSED',
			    "ticket_id" =>  $id,
			    "entry"    =>  $entry
			    );
	 // get the params
	 if( $user_id ) {
	   $logParams["user_id"] = $user_id;
	 }
	 $logParams["bin_id"] = $t["bin_id"];
	 if( $hours )
	   $logParams["hours"] = $hours;
	 if( $comments )
	   $logParams["entry"] = $comments;
	 // send the log
	 $this->add_log($id, $logParams);    
       }
       if( $this->settings["email_closed"] == "on" ) {
	 // send email
	 $bin = $t["bin_id"];
	 $recipient = $t["creator_id"];
	 $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	 $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	 if( $comments )
	   $emailParams["body"] = htmlentities($comments);
	 $emailParams["tid"] = $id;
	 $message = $this->formatEmailMessage($emailParams);
	 $this->sendEmail($recipient,$subject,$message,$user_id);       
       } 
     } else if( ($t["tested"] == 1 || $t["approved"] == 1) 
		&& $t["status"] == "OPEN" ) {
       // update status to pending
       $params = array(
		       "status"  =>  'PENDING',
		       "user_id"  =>  'NULL'
		       );
       $res = $this->update_ticket($id, $params);
       if( $this->settings["log_pending"] == "on" ) {
	 // make a log entry
	 $logParams = array(
			    "action"   =>  'PENDING',
			    "ticket_id" =>  $id,
			    "entry"    =>  $entry
			    );
	 if( $user_id ) {
	   $logParams["user_id"] = $user_id;
	 }
	 $logParams["bin_id"] = $t["bin_id"];      
	 if( $hours )
	   $logParams["hours"] = $hours;
	 if( $comments )
	   $logParams["entry"] = $comments;
	 $this->add_log($id, $logParams);    
       }  
       if( $this->settings["email_pending"] == "on" ) {
	 // send an email
	 $bin = $t["bin_id"];
	 // get people to send email to
	 if( $t["tested"] == 1 ) {
	   $vars = $this->fetch_bin_roles($bin,'tester');
	 } else {
	   $vars = $this->fetch_bin_roles($bin,'manager');
	 }
	 // determine if we found anyone
	 if( is_array($vars) ) {
	   foreach($vars as $v) {
	     $recipient[] = $v["user_id"];
	   }
	 }
	 if( is_array($recipient) ) {
	   // send the email
	   $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	   $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	   if( $comments )
	     $emailParams["body"] = htmlentities($comments);
	   $emailParams["tid"] = $id;
	   $message = $this->formatEmailMessage($emailParams);
	   $this->sendEmail($recipient,$subject,$message,$user_id);
	 } 
       } 
     }
     return($res);
   }
   
   function log_ticket( $id, $user_id, $action = 'LOG', $hours = '', $comments = '' ) {
      // create an entry in the ticket log to track hours
      // or work done
      
      $logParams["user_id"] = $user_id;
      if( $action )
   $logParams["action"] = $action;
      if( $hours )
   $logParams["hours"] = $hours;
      if( $comments )
   $logParams["entry"] = $comments;
      return $this->add_log($id, $logParams);
   }
   
   function move_ticket( $id, $newBin, $user_id = '', $comments = '' ) {
     // moves the ticket to a new bin location
     // if comments field is set to 'skip_log' then
     // no log will be generated (assumed to have 
     // been done before calling this)
     
     $t = $this->get_ticket($id);      
     $params = array(
		     "bin_id"  => $newBin,
		     "user_id" => 'NULL'
		     );
     $res = $this->update_ticket($id, $params);
     if( $res && $this->settings["log_move"] == "on" ) {
       $logParams["action"] = "MOVED";
       $logParams["bin_id"] = $t["bin_id"];
       $logParams["entry"] = "MOVED TO ".$this->bins["$newBin"];
       $logParams["ticket_id"] = $id;
       if( $user_id )
	 $logParams["user_id"] = $user_id;
       if( $comments )
	 $logParams["entry"] .= "\n\n".$comments;
       $this->add_log($id,$logParams);
     }
     if( $res && $this->settings["email_arrival"] == "on" ) {
       $recipient = $this->fetch_bin_roles($t["bin_id"]);
       if( is_array($recipient) ) {
	 foreach($recipient as $r) {
	   $to[] = $r["user_id"];
	 }
	 $eParams = array(
			  "From" => $this->bins["$t[bin_id]"], 
			  "Sent" => $this->showDateTime(),
			  "By"   => $this->formatName($user_id)
			  );
	 if( $comments )
	   $eParams["body"] = $comments;
	 $eParams["tid"] = $id;
	 $message = $this->formatEmailMessage($eParams);
	 $this->sendEmail($to,$subject,$message,$user_id);
       }
     }
     return($res);
   }
   
   function reject_ticket( $id, $user_id, $comments = '' ) {
     $sender = $this->getTicketSender($id);
     if( !$sender["bin_id"] && $sender["user_id"] )
       $res = $this->assign_ticket($id,$sender["user_id"],$user_id);
     else if( $sender["bin_id"] )
       $res = $this->move_ticket( $id, $sender["bin_id"], $sender["user_id"] );
     $t = $this->get_ticket($id);
     if( $res && $this->settings["log_reject"] == "on" ) {
       $logParams["action"] = "REJECTED";
       $logParams["bin_id"] = $t["bin_id"];
       $logParams["user_id"] = $user_id;
       $logParams["ticket_id"] = $t["id"];
       if( $comments )
	 $logParams["entry"] = $comments;
       $this->add_log($id,$logParams);
     }
     if( $res && $this->settings["email_reject"] == "on" && $senderID ) {
       $eParams = array(
			"From" => $this->bins["$t[bin_id]"], 
			"Time" => $this->showDateTime(),
			"By"   => $this->formatName($user_id)           
			);
       if( $comments )
	 $eParams["body"] = $comments;
       $eParams["tid"] = $id;
       $message = $this->formatEmailMessage($eParams);
       $this->sendEmail($senderID,$subject,$message,$user_id);
     }      
     return($res);
   }
   
   function relate_ticket( $id, $relations, $user_id = '', $comments = '' ) {
      // takes either a comma delimited string
      // or an array of ticket ids
      // checks to insure they exist before performing
      // relations
      // 
      // THIS FUNCTION IS VERY INEFFICIENT AND NEEDS TO BE REVISED
      // IT'S A HORRIBLE HACK FIX NOW, AND PROBABLY REQUIRES
      // THE CREATION OF A NEW DB TABLE AND SOME EDITS
      // TO THIS FUNCTION (possibly the addition of an addRelation()
      // and dropRelation() method to encompass non-global updates)
      
      $t = $this->get_ticket($id);      
      if( !is_array($relations) ) {
    $relations = trim($relations);
    $relations = split(" *, *", $relations);
      }
      $relations = $this->checkRelations($relations,$id);
  
      $rel = (is_array($relations))? join(",",$relations) : "";
      $res = $this->update_ticket($id, array("relations"=>$rel));
      if( is_array($relations) ) {      
    //
    // 
    // 
    // 
    // need to add some methodology here to update the tickets
    // which this one is related to to reflect that relation as
    // well, and to remove relations from tickets which used to
    // be related to this one which aren't anymore
    // 
    // see the comments at the top of this method for more gripes
    // about this bug
    // 
    // 
    // 
      }

      if( $res && $this->settings["log_relate"] == "on" && $user_id ) {
    $logParams["action"] = "RELATED";
    $logParams["bin_id"] = $t["bin_id"];
    $logParams["user_id"] = $user_id;
    $logParams["ticket_id"] = $t["ticket_id"];
    $logParams["entry"] = join(",",$relations);
    if( $comments )
      $logParams["entry"] .= "\n\n".$comments;
    $this->add_log($id,$logParams);
      }
      return( $res );
   }
   
   function reopen_ticket( $id, $user_id = 'NULL', $comments = '' ) {
     // opens a ticket that has been closed
     // this can be used to reopen tickets
     // closed in error, or to make modifications
     // to a closed ticket
     
     $t = $this->get_ticket($id);      
     $params = array(
		     "ctime"    =>   'NULL',
		     "user_id"   =>   $user_id,
		     "status"   =>   'OPEN',
		     "bin_id"    =>   $t["bin_id"],
		     "tested"   =>   ($t["tested"]>0)? 1 : 0,
		     "approved" =>   ($t["approved"]>0)? 1 : 0
		     );
     $res = $this->update_ticket($id, $params);
     if( $res ) {
       $logParams["action"] = "REOPENED";
       $logParams["bin_id"] = $t["bin_id"];
       $logParams["user_id"] = $user_id;
       $logParams["ticket_id"] = $t["ticket_id"];   
       $logParams["entry"] = "Ticket $id opened in ".$this->bins["$bin_id"];
       if( $comments )
	 $logParams["entry"] .= "\n\n".$comments;
       $this->add_log($id,$logParams);
     }
     if( $res && $this->settings["email_arrival"] == "on" ) {
       $recipient = $this->fetch_bin_roles($t["bin_id"],'manager');
       if( $recipient ) {
	 foreach($recipient as $r) {
	   $to[] = $r["user_id"];
	 }
	 $eParams = array(
			  "message" => "This ticket has been reopened.",
			  "From"    => $this->bins["$t[bin_id]"], 
			  "Time"    => $this->showDateTime(),
			  "By"      => $this->formatName($user_id)        
			  );
	 if( $comments )
         $eParams["body"] = $comments;
	 $eParams["tid"] = $id;
	 $message = $this->formatEmailMessage($eParams);
	 $this->sendEmail($to,$subject,$message,$user_id);
       }
     }
     return( $res );
   }
      
   function test_ticket( $id, $user_id, $hours = '', $comments = '' ) {
      // updates the testing parameter to reflect
      // a status of 'testing completed' for the ticket
      
     $t = $this->get_ticket($id);
     $res = $this->update_ticket($id, array("tested"=>2));
     if( $res && $this->settings["log_test"] ) {
       $logParams["action"] = "TESTED";
       $logParams["bin_id"] = $t["bin_id"];
       $logParams["user_id"] = $user_id;
       $logParams["ticket_id"] = $t["ticket_id"];   
       if( $comments )
	 $logParams["entry"] = $comments;
       $this->add_log($id,$logParams);  
     }
     if( $t["approved"] != 1 ) {
       // go ahead and close the ticket
       // since it doesn't need to be
       // approved       
       $this->close_ticket($id);
     }         
     else if( $this->settings["email_pending"] == "on" ) {
       $bin = $t["bin_id"];
       $vars = $this->fetch_bin_roles($bin,'manager');
       if( is_array($vars) ) {
	 foreach($vars as $v) {
	   $recipient[] = $v["user_id"];
	 }
       }
       if( is_array($recipient) ) {
	 $subject = "[".$this->settings["system_name"]."] ticket #$id closed";
	 $emailParams["Close Time"] = $this->showDateTime($this->currTime);
	 if( $comments )
	   $emailParams["body"] = htmlentities($comments);
	 $emailParams["tid"] = $id;
	 $message = $this->formatEmailMessage($emailParams);
	 $this->sendEmail($recipient,$subject,$message,$user_id);
       }       
     }
     return( $res );
   }
   
   function yank_ticket( $id, $user_id, $comments = '' ) {
     // takes a ticket from it's current location and status 
     // (whatever those might be) and 
     // assigns it to the user specified
     
     $t = $this->get_ticket($id);
     $bin_id = $t["bin_id"];
     if( is_array($t) ) {
       if( $this->settings["log_yank"] == "on" ) {
	 $lParams = array(
			  "action"   =>   "YANKED",
			  "user_id"   =>   $user_id,
			  "bin_id"    =>   $bin_id
			  );
	 if( $comments )
	   $lParams["entry"] = $comments;
	 $this->add_log($id,$lParams);
       }
       if( $t["status"] == 'CLOSED' ) {
	 $tested = ($t["tested"] == 2)? 1:0;
	 $approved = ($t["approved"] == 2)? 1:0;
	 $this->reopen_ticket($id, $user_id, $tested, $approved, $comments);
       }
       $this->assign_ticket($id,$user_id);
       return( 1 );
     }
   }
   
   /*
    *  TICKETS ADMINISTRATION
   */
   
   
   function add_ticket( $params ) {
     // create a new ticket with the
     // given params and return the new
     // insert ID for that ticket
     
     $id = $this->db_insert($this->table_tickets,$params);
     if( $id ) {
       $lParams = array(
			"action"   =>   "CREATED",
			"user_id"   =>   $params["creator_id"],
			"bin_id"    =>   $params["bin_id"]
			);
       $this->add_log($id,$lParams);
       if( $this->settings["email_created"] == "on" ) {
	 // send email
	 $bin = $t["bin_id"];
	 if( $params["user_id"] )
	   $recipient[] = $params["user_id"];
	 $vals = $this->fetch_bin_roles($params["bin_id"],"manager");
	 if( is_array($vals) ) {
	   foreach($vals as $v) {
	     $recipient[] = $v["user_id"];
	   }
	 }
	 if( is_array($recipient) ) {
	   $recipient = array_unique($recipient);
	   $subject = "[".$this->settings["system_name"]."] ticket #$id created";
	   $emailParams["Open Time"] = $this->showDateTime($this->currTime);
	   if( $comments )
	     $emailParams["body"] = htmlentities($comments);
	   $emailParams["tid"] = $id;
	   $message = $this->formatEmailMessage($emailParams);
	   $this->sendEmail($recipient,$subject,$message,$params["creator_id"]);
	 }
       } 
     }
     return $id;
   }
   
   function archive_ticket( $id ) { 
     // send a ticket and all of it's log
     // entries to the archive db
     
     $ticket = $this->get_ticket($id);
     if( $ticket["type_id"] == $this->projectTypeID() )
       return( $this->archive_project($id) );
      
     $fields = $this->db_get_fields($this->table_tickets_archived);
     $query = "INSERT INTO "
       .$this->table_tickets_archived
       ." ($fields) SELECT $fields FROM ".$this->table_tickets
       ." WHERE id = $id";      
      $this->db_result($query);
      $this->archive_log($id);
      $this->delete_ticket($id);
   }   
      
   function delete_ticket( $id, $archive_flag = 0 ) {
     // drop a ticket, its log entries, and 
     // all associated data from the db
     // $id can be an array
     $this->delete_log($id, $archive_flag);
     $table = ($flag)? 
       $this->table_tickets_archived : $this->table_tickets;
     $where = (is_array($id))? " id IN(".join(",",$id).")" : " id = $id";
     $query = "DELETE FROM $table WHERE $where";
     $this->addDebug("delete_ticket",$query,2);
     return( $this->db_result($query) );
   }
   
   function update_ticket( $id, $params ) {
      // update properties of an existing
     // tickets with given params
     $set = $this->makeInsertVals($params,1);
     $query = "UPDATE ".$this->table_tickets." SET $set WHERE id = $id";
     $this->addDebug("update_ticket",$query,3);
     return( $this->db_result($query) );
   }      
   
   /*
    *  LOG AND TIME FUNCTIONS 
   */
   
   
   function add_log( $id, $params ) {
     // add a new log entry for ticket
     // with $id
     // params can include any of the 
     // following indexes:
     //    user_id
     //    bin_id
     //    action (the action logged)
     //    entry (the log entry)
     //    ticket_id
     
     // set up the parameters for the insert statement
     $table = $this->table_logs;
     $params["ticket_id"] = $id;
     $params["created"] = $this->currTime;
     if( !$params["action"] )
       $params["action"] = "LOG";
     if( !$params["user_id"] )
       $params["user_id"] = 0;//$this->settings["bot_name"];
     if( !$params["bin_id"] ) {
       $ticket = $this->get_ticket($id);
       $params["bin_id"] = $ticket["bin_id"];
     }
     // add hours to the ticket's total
     if( $params["hours"] ) {
       if( !$ticket )
	 $ticket = $this->get_ticket($id);
       $wkd = $params["hours"] + $ticket["wkd_hours"];
       $query = "UPDATE ".$this->table_tickets
	 ." set wkd_hours = $wkd WHERE id = $id";
       $this->db_result($query);
     }
     return( $this->db_insert($table, $params) );      
   }
   
   function delete_log( $id, $flag = 0, $archive_flag = 0 ) {
     // delete log entries for ticket with
     // $id, if $flag = 1, then deletes only
     // the entry with log_id of $id (i.e. by the
     // log id instead of ticket id)
     // id can be a string or an array
     
     $column = ($flag)? "lid" : "ticket_id";
     if( is_array($id) )
       $where = " $column IN(".join(",",$id).")";
     else
       $where = " $column = $id";
     $table = ($archive_flag)? 
       $this->table_logs_archived :
       $this->table_logs;
     if( !$archive_flag ) {
       $attachments = $this->get_attachments($id, $flag);
       if( is_array($attachments) ) {
	 foreach($attachments as $a) {
	$att[] = $a["attachment_id"];
	 }
	 $this->delete_attachment($att);
       }  
     }
     $query = "DELETE FROM $table WHERE $where";
     return( $this->db_result($query) );
   }
   
   function archive_log( $id, $flag = 0 ) {
     // moves logs for ticket with $id to the 
     // db archives.  if $flag = 1, then moves
     // only logs with an lid(log id) matching $id
     // instead of by ticket_id
     // attachments are deleted from the db
     // when a ticket is archived
      
     $f = ($flag)? "lid" : "ticket_id";
     $fields = $this->db_get_fields($this->table_tickets_archived);
     $query = "INSERT INTO "
       .$this->table_tickets_archived." ($fields) SELECT $fields FROM "
       .$this->table_tickets
       ." WHERE $f = $id";            
     $attachments = $this->get_attachments($id, $flag);
     if( is_array($attachments) ) {
       foreach($attachments as $a) {
	 $att[] = $a["attachment_id"];
       }
       $this->delete_attachment($att);
     }   
     return( $this->db_result($query) );
   }
   
   function add_attachment( $name, $filename, $filetype, $ticket_id, $log_id = '', $description = '' ) {
     // adds an attachment to the db for tracking
     // does not add the actual file, just it's associations
     // with logs and tickets, log_id is optional, the ticket_id is not
     // filetype represents the complete mime type as will be used
     // to supply the file back to the user when requested
     
     if( !$ticket_id ) {
       $log = $this->get_log($log_id);
       $ticket_id = $log["ticket_id"];
     }
     $params = array(
		     "log_id"       => $log_id,
		     "ticket_id"    => $ticket_id,
		     "name"        => $name,
		     "filename"    => $filename,
		     "filetype"    => $filetype
		     );
     if( $description )
       $params["description"] = $description;
     $table = $this->table_attachments;
     return( $this->db_insert($table,$params) );
   }
   
   function delete_attachment( $access_id ) { 
     // deletes attachments by attachment_id
     // can be an array
     
     if( !is_array($access_id) )
       $access_id = array($access_id);
     for( $i=0; $i<count($access_id); $i++ ) {
       $att = $this->get_attachment($access_id[$i]);
       $file = $this->attachmentDir."/$att[name]";
       unlink($file);   
     }
     $query = "DELETE FROM ".$this->table_attachments
       ." WHERE attachment_id IN(".join(",",$id).")";
     return( $this->db_result($query) );
   }
   
   function delete_all_attachments( $id ) {
     // deletes all attachments by their log_id
     // $id can be an array
     
     if( !is_array($id) )
       $id = array($id);
     foreach($id as $i) {
       $att = $this->get_attachments($i, $flag);
       for( $i=0; $i<count($att); $i++ ) {
	 $access_id[] = $att["attachment_id"];
       }
     }
     return( $this->deleteAttachment($access_id) );
   }
   
   
   /*
    *  USER ADMINISTRATION
    */
   
   
   function add_user( $params ) {
     // creates a new user entry in the db
     // if $params["access"] is an array
     // then it will also run add_access()
     // with this array once the user has
     // been created
     // if ["passphrase"] is given, it should
     // be the unencrypted value.. if blank,
     // ["passphrase"] will be set automatically
     // to the users last name until that user
     // logs into the system and changes it
     
     if( $params["access"] ) {
       $access = $params["access"];
       unset($params["access"]);
     }
     $params["passphrase"] = ($params["passphrase"])?
       $this->encval($params["passphrase"]) : $this->encval($params["lname"]);
     $table = $this->table_users;
     $id = $this->db_insert($table, $params);
     if( $id ) {
       if( is_array($access_level) )
	 $this->add_access($id, $access_level);
       return($id);
     }
   }
   
   function delete_user( $user_id ) {
      // deletes a user from the db by the
      // user's id.  also deletes all access
      // and prefs entries for this user
      // $user_id can be an array
      
      $where = (is_array($user_id))? " user_id IN(".join(",",$user_id).")" : " user_id = $user_id";
      $query = "DELETE FROM ".$this->table_users." WHERE $where";
      $this->addDebug("delete_user()Query",$query,2);
      $this->delete_access($user_id);
      return( $this->db_result($query) );
   }
   
   function update_user( $user_id, $params ) {
     // updates user settings by user_id
     // do not encrypt the passphrase, this is done
     // automatically
      
      if( $params["passphrase"] )
	$params["passphrase"] = $this->encval($params["passphrase"]);
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_users." SET $set WHERE user_id = $user_id";
      $this->addDebug("update_user()Query",$query,2);
      return( $this->db_result($query) );
   }
   
   function add_access( $user_id, $params ) {
     // adds new access parameters for the 
     // given user, ignores ones that 
     // currently exist for that user
     // $params is an indexed array containing:
     //   "bin_id" => level (integer)
     
     foreach($params as $k=>$v) {
       if( !strlen($v[0]) )
	 $v[0] = 'NULL';
       if( !strlen($v[1]) )
	 $v[1] = 'NULL';
       else
	 $v[1] = "'$v[1]'";
       $query = "INSERT INTO ".$this->table_access
	 ." (user_id,bin_id,lvl,notes) VALUES($user_id,$k,$v[0],$v[1])";
       $res = $this->db_result($query);
       if( $res )
	 $i++;
     }
     return($i);
   }
   
   function update_access( $user_id, $params ) {
      // deletes the users old access privileges 
      // and replaces them with the ones given in 
      // $params, $user_id is the user_id
      
      $this->delete_access( $user_id );
      return( $this->add_access($user_id, $params) );
   }
   
   function delete_access( $id, $flag = '' ) {
      // deletes access privedges based on $flag
      //   NULL - by user_id
      //   1    - by bin_id
      //   2    - by access_id
      // $id can be an array
      
      if( $flag == 1 )
   $field = "bin_id";
      else if( $flag == 2 )
   $field = "access_id";
      else
   $field = "user_id";
      $where = (is_array($id))?
   " $field IN(".join(",",$id).")" :
        " $field = $id";      
      $query = "DELETE FROM ".$this->table_access." WHERE $where";
      $this->addDebug("delete_access()Query",$query,2);
      return( $this->db_result($query) );
   }
   
   function add_prefs( $user_id, $params ) {
      // adds prefs for a user_id

      $params["user_id"] = $user_id;
      list($cols,$vals) = $this->makeInsertVals($params);
      $query = "REPLACE INTO ".$this->table_preferences." ($cols) values($vals)";
      return( $this->db_result($query) );
   }
      
   function delete_prefs( $user_id ) {
      // deletes prefs entries by user_id
      // user_id can be an array      

      $query = "DELETE FROM ".$this->table_preferences." WHERE user_id = $user_id";
      return( $this->db_result($query) );
   }

   function reset_password( $user_id ) {
     // resets the users passphrase to the default value
     // for a user.  This will probably be the users last name

     $user = $this->get_user($user_id);
     $params["passphrase"] = $user["lname"];
     return $this->update_user($user_id, $params);
   }
   
   
   /*
    *  SYSTEM ADMINISTRATION
   */
   
   
   function add_bin( $params ) {
      // add a new bin to the bins table
      
      return( $this->db_insert( $this->table_bins, $params ) );
   }

   function add_priority( $params ) {
      // add a new priorty
      
      return( $this->db_insert( $this->table_priorities, $params ) );
   }

   function add_setting( $params ) {
      // add a new setting into the db
      
      return( $this->db_insert($this->table_settings, $params) );
   }
   
   function add_system( $params ) {
      // add a new system to the db
      
      return( $this->db_insert( $this->table_systems, $params ) );      
   }

   function add_task( $params ) {
     // add a new task to the system
     
     return( $this->db_insert( $this->table_tasks, $params) );
   }
   
   function add_type( $params ) {
      // add a new ticket type
      
      return( $this->db_insert($this->table_types, $params) );
   }
   
   function update_bin( $bid, $params ) {
      // update properties for a given bid (bin id)
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_bins." SET $set WHERE bid = $bid";
      $this->addDebug("update_bin()Query",$query,2);
      return( $this->db_result($query) );
   }

   function update_priority( $pid, $params ) {
      // update properties for a given priority
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_priorities." SET $set WHERE pid = $pid";
      $this->addDebug("update_priority()Query",$query,2);
      return( $this->db_result($query) );
   }
   
   function update_setting( $setting_id, $params ) {
      // update a setting based on it's setting_id
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_settings." SET $set WHERE setting_id = $setting_id";
      $this->addDebug("update_setting()Query",$query,2);
      return( $this->db_result($query) );
   }
   
   function update_system( $sid, $params ) {
      // update settings for a given 
      // sid (system_id)
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_systems." SET $set WHERE sid = $sid";
      $this->addDebug("update_system()Query",$query,2);
      return( $this->db_result($query) );      
   }

   function update_task( $task_id, $params ) {
      // update a ticket task by task_id
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_tasks." SET $set WHERE task_id = $task_id";
      $this->addDebug("update_task()Query",$query,2);
      return( $this->db_result($query) );            
   }
   
   function update_type( $type_id, $params ) {
      // update a ticket type by the type_id
      
      $set = $this->makeInsertVals($params,1);
      $query = "UPDATE ".$this->table_types." SET $set WHERE type_id = $type_id";
      $this->addDebug("update_type()Query",$query,2);
      return( $this->db_result($query) );            
   }
   
   
   /*
    *  ACCESS UTILITIES
   */
   
   
   function login_user( $username, $passphrase ) {
      // perform a login check for username and passphrase
      // returns the user's user_id
      
      $query = "select user_id from ".$this->table_users
   ." where login = '$username' and passphrase = '".$this->encval($passphrase)."' and active > 0";
      $user_id = $this->db_get($query);
         $this->addDebug("zentrack.class:login_user($user_id)",$query,2);
      if( $user_id )
         $this->getUser($user_id);
      return($user_id);
   }

   function check_bin_access( $user_id, $bin_id, $level = 1 ) {
     // check the user's access priviledges for the given bin_id
     // based on the users user_id. and $level (returns true
     // if equal to or greater than this)
     
     $access =  $this->getAccess( $user_id );
     return( ($access["$bin_id"] >= $level) );
   }
      
   /*
    *  TOOLS 
   */   
   
   function check_status( $id, $code = 'OPEN' ) {
      // checks to see if a ticket is ready for the 
      // given action, the $code codes are:
      //    OPEN    - is open?
      //    PEND    - is pending?
      //    TEST    - ready for testing?
      //    APPR    - ready for approval?
      //    READY   - ready for closing?
      //    CLOSED  - is closed?
      // returns 1 if $code can be met
      $c = strtoupper(substr($code,0,2));
      if( is_array($id) ) {
	$ticket = $id;
      } else {
	$ticket = $this->get_ticket($id);
      }
      if( $c == 'OP' ) {
	return( $ticket["status"] == 'OPEN' );
      } else if( $c == 'PE' ) {
	return( $ticket["status"] == 'PENDING' );
      } else if( $c == 'TE' ) {
	return( $ticket["status"] == 'PENDING' && ($ticket["tested"] == 1) );
      } else if( $c == 'AP' ) {
	return( $ticket["status"] == 'PENDING' && $ticket["tested"] != 1 );
      } else if( $c == 'RE' ) {
	return( ($ticket["status"] == 'PENDING' && $ticket["tested"] == 2 
		 && $ticket["approved"] == 2)
		||
		($ticket["status"] == 'OPEN' && $ticket["tested"] == 0 
		 && $ticket["approved"] == 0));
      } else if( $c == 'CL' ) {
	return( $ticket["status"] == 'CLOSED' );
      }
   }   
   
   function fetch_bin_roles( $bin_id, $role = '' ) {
     // fetches members of bin with a particular
     // role.  If $role is given, fetches only
     // members listed as fulfilling that particular
     // role. Returns the user_id and their role in an
     // indexed array
     
     // check the role id
     if( preg_match("@[^0-9]@", $role) ) {
       $role = $this->getRoleID($role);
     }
     // set up the query parameters
     $where = ($role)? " bin_id = $bin_id and notes = '$role'" : 
       " bin_id = $bin_id";
     if( $role ) {
       $where .= " AND notes = '$role' ";
     }
     else {
       $where .= " AND notes IS NOT NULL ";
     }
     // set the fields to retrieve
     $fields = ($role)? " user_id " : " user_id, notes ";
     // run the query
     $query = "SELECT $fields FROM ".$this->table_access
       ." WHERE $where";
     $vals = $this->db_queryIndexed($query);
     $this->addDebug("fetch_bin_roles","result: ".count($vals).", query: $query",3);
     return( $vals );
   }
   
   function fetch_user_roles( $user_id, $bin_id = '' ) {
      // fetches a specific user's roles in zenTrack
      // if bin_id is given, returns only roles for that specific bin
      // returns the bin_id and role in an indexed array
      
     $where = ($bin_id)? " user_id = $user_id AND bin_id = $bin_id " : 
       " user_id = $user_id ";
     $query = "SELECT bin_id, notes FROM "
       .$this->table_access." WHERE $where"
       ." AND (notes IS NOT NULL) ";
     $vals = $this->db_queryIndexed($query);
     $this->addDebug("fetch_user_roles","result: ".count($vals).", query: $query",3);
     return( $vals );
   }
   
   function format_name( $user_id, $flag = '' ) {
      // alias for formatName()      
      return($this->formatName($user_id, $flag));
   }
   
   function formatName( $user_id, $flag = '' ) {
      // if the user properties are available, pass those here
      // otherwise pass the user id, and he/she will be retrieved
      // from the db (user properties can be passed as an array in
      // place of $id)
      // if $flag = 2, then returns "initials"
      // if $flag = 1, then returns "lname, fname"
      // if !$flag, then returns "fname lname"
      
     if( is_array($user_id) )
       $user = $user_id;
     else
       $user = $this->get_user($user_id);
     
     if( !is_array($user) )
       return( "n/a" );
     if( $flag == 2 )
       return( $user["initials"] );
     else if( $flag == 1 )
       return( $user["lname"].", ".$user["fname"] );
     else
       return( $user["fname"]." ".$user["lname"] );
   }

   function percentWorked( $etc = 0, $wkd = 0 ) {
      // determines the percent completion for this
      // project
      
     if( $etc > 0 ) {
       return( round($wkd/$etc*100,1) );
     }
   }   
   
   function formatEmailMessage( $params ) {
      // takes a list of input parameters and makes
      // a formatted message to be sent, including links 
      // and information about the ticket referenced
      // special params:
      //     message - printed at the top of the email with
      //               line breaks afterwards
      //     body    - printed with extra line breaks
      //     tid     - retrieves the ticket by this id and 
      //               includes it in the email body
      //     log     - retrieves log entries for this ticket
      //               by the id given by log, limited by the
      //               system setting email_max_logs
      //     link    - displays a link to the ticket
      //               (this is done with the tid property too,
      //                use this one instead of tid to display
      //                the link only)
      // all others are printed as is, with html stripped
      
     if( $params["message"] ) {
       // insure the message gets printed first
       $message = $params["message"]."\n\n";
       unset($params["message"]);
     }
     
     // loop through the parameters and print them
     foreach( $params as $k=>$v ) {
       if( $k == 'body' ) {
	 // include the body of the message
	 $message .= "\n\n$v\n\n";
       } else if( $k == 'link' ) {
	 $message .= $this->settings["url_view_ticket"]."?id=$v";       
       } else if( $k == 'tid' ) {
	 // print a summary of the ticket
	 $message .= "\n\n--- TICKET SUMMARY ---\n\n";
	 $t = $this->get_ticket($v);
	 $url = $this->settings["url_view_ticket"]."?id=$v";
	 $n = $t["bin_id"];
	 $u = $t["user_id"];
	 $s = $t["system_id"];
	 if( $t["user_id"] ) {
	   $name = $this->formatName($t["user_id"]);
	 } else {
	   $name = "n/a";
	 }
	 $message .= "$t[title]\n\n";     
	 $message .= "ID:\t$t[id]\n";
	 $message .= "Status:\t$t[status]\n";
	 $message .= "Deadline:\t".$this->showDate($t["deadline"])."\n";
	 $message .= "Bin:\t".$this->bins[$n]."\n";
	 $message .= "Owner:\t$name\n";
	 $message .= "URL:\t$url\n";
	 $des = preg_replace("#&quot;#",'"',preg_replace("#&amp;#","&",$t["description"]));
	 $des = preg_replace("@<br( /)?>@", "", $des);
	 $message .= "\n\n$des\n\n------------------\n\n";
       } else if( $k == "log" ) {
	 // print the log for the ticket
	 if( $this->settings["email_max_logs"] )
	   $lim = $this->settings["email_max_logs"];
	 $logs = $this->get_logs($v, 'created DESC', $lim);
	 $message .= "\n\n";
	 if( is_array($logs) ) {
	   $att = $this->get_attachments($v,null,1);          
	   $message .= "LOG ENTRIES\n\n";
	   $sep = "--";
	   foreach( $logs as $l ) {
	     $message .= $this->showDateTime($l["created"],'M');
	     $message .= $sep.str_pad($l["action"],8,"-",STR_PAD_LEFT);
	     $message .= $sep.str_pad($this->formatName($l["user_id"],2),6,"-",STR_PAD_LEFT);
	     $message .= (strlen($l["hours"]))? $sep.str_pad($l["hours"],4,"-",STR_PAD_LEFT)." hrs":"";
	     //
	     // the log and attachments
	     if( $l["entry"] ) {
	       $log["entry"] = "\n".stripslashes($l["entry"])."\n";
	       $log["entry"] = preg_replace("#&amp;#", "&", $log["entry"]);
	       $log["entry"] = preg_replace("#&quot;#", '"', $log["entry"]);
	       $l["entry"] = preg_replace("@<br( /)?>@", "", $log["entry"]);
	       $message .= "\n".$l["entry"]."\n";
	     }
	     if( $att["$id"]["$lid"] ) {
	       $message .= "\nATTACHMENT(s):\n";
	       foreach( $att["$id"]["$lid"] as $a ) {
		 $message .= "$a[name] ($a[description])\n";
		 $message .= "\t".$this->attachmentUrl."?file=$a[filename]\n";
	       }
	     }        
	     $message .= "------------------\n\n";
	   }
	   if( $v > 0 && count($logs) == $v ) {
	     $message .= "\nMore log entries.  View them by logging in and viewing this ticket.\n";
	     if( !$params["tid"] && !$params["link"] ) {
	       $message .= $this->settings["url_view_ticket"]."?id=$v";
	     }
	   }
	 } else {
	   $message .= "No log entries\n";
	 }
	 $message .= "\n";          
       } else {
	 // just print whatever is indexed, since it didn't
	 // match any special settings
	 $v = strip_tags($v);
	 $message .= "$k:\t$v\n";
       }
     }
     return($message);
   }
   
   function sendEmail( $recipients, $subject, $message, $sender = '', $cc = '' ) {
      // send email updates to $recipients
      // $recipients and $sender are the user_id of the sender and recipient
      // alternately, $recipients can contain valid email addresses rather 
      // than a user_id value (to send to non-zentrack users)
      // $recipients, $sender, and $cc can all be an array
      
     // figure out who sent it
     $message = (get_magic_quotes_gpc())? stripslashes($message) : $message;
     $message = preg_replace(
			     array("#&lt;#", "#&gt;#", "#&quot;#", "#&amp;#"),
			     array("<",">",'"',"&"),
			     $message);
     if( !$sender ) {
       $sender_address = $this->settings["admin_email"];
     } else {
       if( eregi("^[0-9]+$", $sender) ) {
	 $s = $this->get_user($sender);
	 $sender_address = $s["email"];
       } else {
	 $sender_address = $sender;
       }
     }
     
     // figure out who it is being set to
     if( !is_array($recipients) )
       $recipients = array($recipients);
     foreach($recipients as $r) {
       if( $recipient_address )
	 $recipient_address .= ", ";
       if( eregi("^[0-9]+$", $r) ) {
	 $s = $this->get_user($r);
	 if( $s["email"] ) {
	   $recipient_address .= $s["email"];
	 }
       } else {
	 $recipient_address .= $r;
       }  
     }
     
     if( strlen($recipient_address) ) {
       // create headers and CC fields
       $headers .= "From: $sender_address\n";
       if( $cc ) {
	 if( !is_array($cc) )
	   $cc = array($cc);
	 foreach($cc as $c) {
	   if( $cc_address )
	     $cc_address .= ", ";
	   if( eregi("^[0-9]+$", $c) ) {
	     $s = $this->get_user($c);
	     $cc_address .= $s["email"];
	   } else {
	     $cc_address .= $c;
	   }
	 }
	 $headers .= "cc: $cc_address\n";
       }
       
       // finalize and send the message
       $message = (get_magic_quotes_gpc())? $message : addslashes($message);
       $subject = (get_magic_quotes_gpc())? $subject : addslashes($subject);
       $this->addDebug("sendEmail","$recipient_address,$subject,$headers",3);
       return( @mail( $recipient_address, $subject, $message, $headers ) );      
     } else {
       $this->addDebug("sendEmail","recipient_address was blank... "
		       ."this could be that the email was sent to a user "
		       ."who doesn't have an email address",2);
     }
   }
   
   function getTicketCount( $status = '', $bin_id = '' ) {
     // counts the number of tickets matching
     // bin_id and status (if provided) and returns
     // the total
     
     // figure out the where clause
     if( $bin_id && $status ) {
       $where = " WHERE bin_id = $bin_id AND status = '$status' ";
     } else if( $bin_id ) {
       $where = " WHERE bin_id = $bin_id ";
     } else if( $status ) {
       $where = " WHERE status = '$status' ";
     }
     // prepare and execute the select
     $query = "SELECT COUNT(id) FROM ".$this->table_tickets." $where";
     return( $this->db_get($query) );
   }
   
   
   /*
    *  TRANSLATION UTILITIES
    */
   
   function showLongDate($utime = '') {
     // displays a long date format
     if( !$utime )
       $utime = time();
     return strftime($this->date_fmt_long,$utime);
   }
   
   function showDate( $utime = '') {
     // displays a short date and time
     if( !$utime )
       $utime = time();
     return strftime($this->date_fmt_short,$utime);
   }
   
   function showDateTime( $utime = '' ) {
     // displays a short date with time
     if( !$utime )
       $utime = time();
     return strftime($this->date_and_time,$utime);
   }
   
   function showTime( $utime = '' ) {
     if( !$utime )
       $utime = time();
     return strftime($this->time_fmt,$utime);
   }
   
   function showTimeElapsed($start,$end,$round=1,$units=1) {
     // shows the elapsed time rounded to $round decimals
     // and the units abbreviated to $substr length
     // if $units is 0, shows whole name
     // if $units is null, skips unit name
     // if $units is > 0, abbreviate units
     $num = round($this->dateDiff($end,$start,$this->elapsed_unit),$round);
     $abr = "";
     if( $units > 0 ) {
       $abr = " "
	 .substr(preg_replace("@[aeiou]@", "", $this->elapsed_unit),0,2)
	 ."s.";
     } else if( strlen($units) ) {
       $abr = " ".$this->elapsed_unit;
     }
     return "$num$abr";    
   }
   
   function prnString( $identifier, $language = '', $flag = 0 ) {
     // return a language string for printing
     // from the pre-fabbed constructs
     // if $flag is set, then the constructs will
     // be reset
     
     // only get the language if needed, and only once
     if( !$language )
       $language = $this->language;
     // get the strings requested and print them
     $this->getStrings($language,$flag);
     return( $this->strings["$identifier"] );
   }
   
   function prn( $words, $language = '', $flag = 0 ) {
     // take a string or array of words and 
     // return translated content (as much as possible)
     // 
     // this is done by exploding the string on spaces
     // replacing all occurences of words in brackets
     // like such: [:identifier:] with their pre-fabbed
     // constructs, and trying to translate all others
     // from the word table      
     // 
     // if the language changes during execution, the 
     // flag will need to be set to insure they are 
     // refreshed     
     
     /*
      *  DISABLED UNTIL 2.1
      if( !$language ) {
      $language = $this->language;
      }
      // prepare language strings
      $this->getStrings($language,$flag);
      
      // check for incoming format of string
      if( !is_array($words) ) {
      $words = explode(" ", $words);
      $join = 1;
      }
      
      // determine what words need to be loaded
      foreach($words as $w) {
      if( ereg("^[a-zA-Z]+$", $w) && (!$this->words["$w"] || $flag) )
      $get[] = strtolower($w);
      }
      
      // get words that are needed
      if( is_array($get) )
      $this->getWords($get);
      
      // translate the words
      foreach($words as $w) {
      if( ereg("^\[:([a-zA-Z0-9 _-]+):]", $w, $matches) ) {
      // this format ( [:something:] ) indicates a pre-formatted
      // string which is stored in the ZENTRACK_TRANSLATION_STRINGS
      // section.  
      $new_words[] = $this->prnString($matches[1]);
      } else if( $language != 'english' && ereg("^[a-zA-Z]+$", $w) ) {
      // this is simply a word to be translated
       $n = strtolower($w);
       $r = $this->words["$n"];
       if( $n != $w ) {
          if( ucwords($n) == ucwords($w) )
       $r = ucwords($r);
          else if( strtoupper($n) == $w )
       $r = strtoupper($r);
       }
       $new_words = $r;
       } else {
       // this is something other than a word and will be ignored
       $new_words[] = $w;
       }
       }
       
       // return properly formatted results
       if( $join == 1 ) {
       return( join(" ", $new_words) );
       } else {
       return( $new_words );
       }
     */
     return $words;
   }
   
   function getStrings( $language = '', $flag = 0 ) {
      // returns an array of the translation strings
      // improves efficiency by preventing multiple 
      // retrievals by storing results in a system var
      // the first time this function is called
      // $flag will override the default and reset these
      // values
      
     if( !$this->strings or $flag ) {
       if( !$language )
	 $language = $this->language;
       $query = "SELECT identifier, string FROM "
	 .$this->table_translation_strings." WHERE language = '$language'";
       $vars = $this->db_query($query);
       if( is_array($vars) )
	 foreach($vars as $v)
	   $vals["$v[0]"] = $v[1];
       $this->strings = $vals;
     }
   }
   
   function getWords( $words, $language = '' ) {
      // this function fetches words from the db that are
      // required for completing word translations
      // to speed this process up greatly, this function can be called
      // at the beginning of a page, with an array of words that will be 
      // used in that page, requiring only 1 database query for
      // all uses of this execution
      
     if( !$language )
       $language = $this->language;
     $query = "SELECT identifier, translation FROM "
       .$this->table_translation_words
       ." WHERE language = '$language'"
       ." AND identifier IN('".join("','",$words)."')";
     $vals = $this->db_query($query);
     if(is_array($vals)) {
       foreach($vals as $v) {
	 $this->words["$v[0]"] = $v[1];
       }
     }
   }
   
   function add_translation_word( $identifier, $translation, $language ) {
      // add a new word to the translations dictionary
     
     $params = array("identifier"=>$identifier,"translation"=>$translation,"language"=>$language);
     return( $this->db_insert($this->table_translation_words,$params) );
   }
   
   function add_translation_string( $identifier, $string, $language ) {
     // add a new string to the pre-made sentences for translations
     
     $params = array("identifier"=>$identifier,"string"=>$string,"language"=>$language);
     return( $this->db_insert($this->table_translation_strings,$params) );
   }
   
  
   /*
    *  SYSTEM UTILS 
   */
   
   function get_table_id( $n ) {
     // this function needs help
     // needs to be fixed up
     // and made dynamic... right now
     // it's just a quick hack to prevent 
     // a horrible fix later
     $n = strtolower($n);
     $n = preg_replace("@s$@", "", $n);
     $n = preg_replace("@^zentrack@", "", $n);
     $names = array( "project"    => "id",
		     "ticket"     => "id",
		     "system"     => "sid",
		     "type"       => "type_id",
		     "user"       => "user_id",
		     "bin"        => "bid",
		     "setting"    => "setting_id",
		     "log"        => "lid",
		     "attachment" => "attachment_id");
     return $names["$n"];
   }
   
   function getUser( $user_id ) {
     // retrieves the user who is logged in 
     // to zenTrack.  This function prevents 
     // multiple queries to retrieve user info
     // on a single page by checking the stored
     // user information and validating the user_id
     // first.
     // 
     // Do not use this function for any data other
     // than that of the logged in system user
      
     if( !$this->user || $this->user["user_id"] != $user_id ) {
       $this->user = $this->get_user($user_id);
     }
     return( $this->user );
   }
   
   function getAccess( $user_id ) {
     if( !$this->access || $this->access["user_id"] != $user_id ) {
       $this->access = $this->get_access($user_id);
       $this->access["user_id"] = $user_id;
     }
     return( $this->access );
   }
   
   function getUsersBins( $user_id, $level = "level_view" ) {
     // gets the users bins, compares those to the
     // settings required to access $this->bins and 
     // then checks against the users default level to
     // return a simple list of binIDs that this user
     // has access to
     // $user_id is the user's id
     // $level is the access level to meet
     // (i.e. could be set to level_user to only
     // retrieve bins this user_id is a "user" for,
     // defaults to level_view)
     // this function caches results for efficiency, so repeating
     // calls for the same user will not result slow the system
     
     if( $user_id != $this->lastUsersID || !is_array($this->lastUsersBins) ) {
       $access = $this->getAccess($user_id);
       $user   = $this->getUser($user_id);
       if( is_array($this->bins) ) {
	 foreach($this->bins as $k=>$v) {
	   if( $k ) {
	     if( strlen($access["$k"]) ) {
	       if( $access["$k"] >= $this->settings["$level"] ) {
		 $vars[] = $k;
	       }
	     } else {
	       if( $user["access_level"] >= $this->settings["$level"] ) {
		 $vars[] = $k;
	       }
	     }
	   }
	 }
       }
       $this->lastUsersBins = $vars;
     }
     $adp = (is_array($this->lastUsersBins))? join(",",$this->lastUsersBins) : "-none-";
     $this->addDebug("getUsersBins()results",$adp,3);
     return $this->lastUsersBins;
   }

   function checkCreator( $user_id, $ticket_id ) {
     // checks to see if the $user is the creator the ticket
     // they have special priviledges
     if( !$this->settings["allow_cview"] )
       return false;
     $ticket = $this->get_ticket($ticket_id);
     return( $user_id == $ticket["creator_id"] );       
   }
   
   function checkAccess( $user_id, $bin_id, $action = '' ) {
      // takes the user_id, the bin_id and the action in
      // question, and determines whether the logged in
      // user can perform it
      
      $actions = array(
             "create"  =>  $this->settings["level_create"],
             "move"    =>  $this->settings["level_move"],
             "log"     =>  $this->settings["level_user"],
             "accept"  =>  $this->settings["level_accept"],
             "assign"  =>  $this->settings["level_assign"],
             "yank"    =>  $this->settings["level_yank"],
             "test"    =>  $this->settings["level_test"],
             "approve" =>  $this->settings["level_approve"],
             "reject"  =>  $this->settings["level_sup"],
             "reopen"  =>  $this->settings["level_sup"],
             "edit"    =>  $this->settings["level_edit"],
             "upload"  =>  $this->settings["level_user"],
             "print"   =>  $this->settings["level_view"],
             "email"   =>  $this->settings["level_view"]
             );
      $level = $actions["$action"];
      if( !strlen($level) ) {
	$level = ($this->settings["$action"])? 
	  $this->settings["$action"] : $this->settings["level_view"];
      }
      $access = $this->getAccess($user_id);
      if( strlen($access["$bin_id"]) ) {
	return( $access["$bin_id"] >= $level );
      } else {
	$user = $this->getUser($user_id);
	return( $user["access_level"] >= $level );
      }
   }
   
   function actionApplicable( $id, $action, $user_id = '' ) {
      // check to see if an action is applicable to
      // the current ticket, based on it's status, the
      // logged in users access, and the actions requirements
      // if an array is sent in place of the ticket id, it will
      // be used as the tickets parameters (saving a db lookup)
      
      // actions array contains the following params
      //    0 - must be owner of ticket
      //               0 - false
      //               1 - true
      //               2 - must NOT be owner
      //               3 - must not be owned by anyone
      //               4 - must be owned, and must not be owner
      //    1 - must meet checkAccess
      //    2 - ticket status
      //    3 - supervisor override?
      
      $action = strtolower($action);
      $actions = array(          
             "move"    => array( 1, 1, array('OPEN','PENDING'), 0 ),
             "log"     => array( 1, 1, array('OPEN','PENDING'), 1 ),
             "accept"  => array( 3, 1, array('OPEN'),           0 ), 
             "assign"  => array( 3, 1, array('OPEN'),           0 ),
             "yank"    => array( 4, 1, 0,                       0 ),
             "test"    => array( 0, 1, array('PENDING'),        0 ),
             "approve" => array( 0, 1, array('PENDING'),        0 ),
             "reject"  => array( 1, 1, array('OPEN','PENDING'), 0 ),
             "close"   => array( 1, 1, array('OPEN'),           0 ),
             "relate"  => array( 1, 1, 0,                       0 ),
             "reopen"  => array( 0, 1, array('PENDING','CLOSED'), 0 ),
             "edit"    => array( 0, 1, array('OPEN','PENDING'), 0 ),
             "upload"  => array( 1, 1, 0,                       1 ),
             "print"   => array( 0, 1, 0,                       0 ),
             "email"   => array( 0, 1, 0,                       0 )
             );
      $n = "allow_$action";
      if( $this->settings["$n"] && $this->settings["$n"] != "on" )
	return false;
      $c = $actions["$action"];
      if( is_array($id) ) {
	$ticket = $id;
	$id = $ticket["id"];
	$bin_id = $ticket["bin_id"];
      } else { 
	$ticket = $this->get_ticket($id);
	$bin_id = $ticket["bin_id"];
      }
      
      if( $c[0] == 2 ) {
	if( $ticket["user_id"] == $user_id )
	  return false;
      } else if( $c[0] == 3 ) {
	if( $ticket["user_id"] )
	  return false;
      } else if( $c[0] == 4 ) {
	if( !$ticket["user_id"] || $ticket["user_id"] == $user_id )
	  return false;
      } else if( $c[0] ) {
	if( $c[3] ) {
	  $user = $this->get_user($user_id);
	  $access = $this->getAccess($user_id);
	}  
	if( $ticket["user_id"] != $user_id ) {
	  if( !$c[3] 
	      || ( strlen($access["$bin_id"]) 
		   && $access["bin_id"] < $this->settings["level_super"] )
	      || ( !strlen($access["$bin_id"]) 
		   && $user["access_level"] < $this->settings["level_super"])
	      )
	    return false;
	}
      }
      if( $c[1] ) {
	if( !$this->checkAccess($user_id, $bin_id, $action) ) 
	  return false;
      }
      if( $c[2] ) {
	if( !is_array($c[2]) )
	  $c[2] = array($c[2]);
	if( !in_array($ticket["status"],$c[2]) )
	  return false;
      }
      if( $action == "approve" && ($ticket["tested"] == 1 || $ticket["approved"] != 1) )
	return false;
      else if( $action == "reject" && !$this->getTicketSender($id) ) 
	return false;
      else if( $action == "test" && $ticket["tested"] != 1 )
	return false;
      
      return true;
   }
   
   function getBinName($id) {
     // returns the name of a bin
     // from the given bin id
     $bins = $this->getBins(0,0);
     return((isset($bins["$id"]))? $bins["$id"] : "");
   }
   
   function getBins($flag = 0,$active = 1) {
     // if flag is set, retrieves a full
     // indexed array, otherwise, just
     // a list of names, indexed by bid,
     // ordered by priority and alphebetized 
     // set $active to zero to retrieve 
     // the bins which are disabled as well
      
     if( !$flag ) {
       $query = "SELECT bid, name FROM ".$this->table_bins;
       if( $active )
	 $query .= " WHERE active = $active";       
       $vars = $this->db_query($query);
       foreach($vars as $v) {
	 $vals["$v[0]"] = $v[1];
       }
       return($vals);
     } else {
       $query = "SELECT * FROM ".$this->table_bins;
       if( $active )
	 $query .= " WHERE active = $active";
       $query .= " ORDER BY priority DESC, name";
       return( $this->db_queryIndexed($query) );
     }
   }
   
   function checkRelations( $relations, $id = '' ) {
     // takes either an array or comma delimited
     // string.  insures that the tickets to be 
     // related actually exist and returns only
     // the ids that are in db
     
     if( !is_array($relations) ) {
       $join = 1;
       $relations = ereg_replace("[^0-9,]", "", $relations);
       $relations = explode(",",$relations);
     }
     foreach($relations as $r) {
       if( !$id || ($id && $r != $id) ) {
	 if( $this->get_ticket($r) ) {
	   $vals[] = $r;
	 }
       }
     }
     if( $join ) {
       return( join(",",$vals) );
     } else {
       return( $vals );
     }
   }

   function getRoleName($id) {
     // returns the name
     // for a given role id
     $roles = $this->getRoles();
     return $roles["$id"]["name"];
   }

   function getRoleID($name) {
     // returns the id for
     // a given role name
     $roles = $this->getRoles();
     foreach($roles as $k=>$v) {
       if( strtolower($v["name"]) == strtolower($name) )
	 return $k;
     }
     $this->addDebug("getRoleID","role '$name' wasn't found!", 1);
   }

   function getRoles($active = 1) {
     // planning for the future
     // we will probably want to add these
     // to the database
     // to make them customizeable and
     // available for triggers and flowpaths
     return array(
		  "1"=>array("role_id"=>1,"name"=>"Manager"),
		  "2"=>array("role_id"=>2,"name"=>"Tester")
		  );
   }
   
   function getTasks($flag = 0,$active = 1) {
     // if flag is set, retrieves an
     // indexed array, otherwise, just
     // a list of names ordered by priority
     // and alphebetized      
     
     if( !$flag ) {
       $query = "SELECT task_id, name, priority FROM ".$this->table_tasks;
       if( $active )
	 $query .= " WHERE active = $active";
       $vars = $this->db_query($query);
       if( is_array($vars) ) {
	 foreach($vars as $v) {
	   $vals["$v[0]"] = $v[1];
	 }
       }
       return $vals;
     } else {
       $where = ($active)? " WHERE active = $active" : "";
       $query = "SELECT * FROM ".$this->table_tasks." $where ORDER BY priority DESC, name";
       return( $this->db_queryIndexed($query) );
     }
   }
   
   function getSystems($flag = 0,$active = 1) {
     // if flag is set, retrieves an
     // array, ordered by priority and
     // alphebatized, otherwise, just
     // an array of names indexed by id
     
     if( !$flag ) {
       $query = "SELECT sid, name FROM ".$this->table_systems;
       if( $active )
	 $query .= " WHERE active = $active";
       $vars = $this->db_query($query);
       if( is_array($vars) ) {
	 foreach($vars as $v) {
	   $vals["$v[0]"] = $v[1];
	 }
       }
       return($vals);
     } else {
       $where = ($active)? " WHERE active = $active" : "";
       $query = "SELECT * FROM ".$this->table_systems." $where ORDER BY priority DESC, name";
       return( $this->db_queryIndexed($query) );
     }            
   }
   
   function getPriorities( $flag = 0, $active = 1 ) {
     // if flag is set, retrieves all
     // details in an unordered list
     // otherwise, retrieves an indexed
     // list sorted by priority
     
     if( !$flag ) {
       $query = "SELECT pid,priority,name FROM ".$this->table_priorities;
       if( $active )
	 $query .= " WHERE active = $active";
       $vars = $this->db_query($query);
       for($i=0; $i<count($vars); $i++) {
	 $p = $vars[$i][0];
	 $vals[$p] = $vars[$i][2];
       }
       return($vals);
     } else {
       $where = ($active)? " WHERE active = $active" : "";
       $query = "SELECT * FROM ".$this->table_priorities." $where ORDER BY priority DESC, name";
       return( $this->db_queryIndexed($query) );
     }            
   }
   
   function statusHighlight( $priority ) {
     // prints out status with proper <span>
     // tags to highlight critical status items
     
     if( $priority <= $this->settings["level_hot"] ) {
       $pri = "hot";
     } else if( $priority <= $this->settings["level_highlight"] ) {
       $pri = "highlight";
     } else {
       $pri = "";
     }
     return $pri;
   }
   
   function getSettings($flag = 0) {
     // pulls the variables from the settings table
     // into an indexed array.
     // if flag is set, then it retrieves all
     // data for the settings into an array
     // otherwise, just sets a string equal to the value
     global $rootUrl;        
     
     $fields = ($flag)? "*" : "name, value";
     if( $flag )
       $order = " ORDER BY name";
     else
       $order = "";
     $query = "SELECT $fields FROM ".$this->table_settings." $order";
     $vars = $this->db_queryIndexed($query);
     foreach($vars as $v) {
       if( preg_match("@^url_@",$v["name"]) ) {
	 if(preg_match("@/$@", $rootUrl) && preg_match("@^/@", $v["value"]) ) {
	   preg_replace("@/$@", $rootUrl) . $v["value"];
	 } else if( !preg_match("@/$@", $rootUrl) && !preg_match("@^/@", $v["value"]) ) {
	   $v["value"] = $rootUrl ."/".$v["value"];    
	 } else {
	   $v["value"] = $rootUrl . $v["value"];
	 }
       }
       $vals["{$v['name']}"] = ($flag)? $v : $v["value"];
     }
     return($vals);
   }
   
   function getTypeName($id) {
     // retrieves the name of the type
     // with the given id
     $types = $this->getTypes();
     return( (isset($types["$id"]))? $types["$id"] : "" );
   }
   
   function getTypes($flag = 0, $active = 1) {
      // if flag is not set, retrieves an
      // indexed array, otherwise, just
      // a list of names ordered by priority
      // and alphebetized
     
     if( !$flag ) {
       $query = "SELECT type_id,name FROM ".$this->table_types;
       if( $active )
	 $query .= " WHERE active = $active";
       $vars = $this->db_query($query);
       if( is_array($vars) ) {
	 foreach($vars as $v) {
	   $vals["$v[0]"] = $v[1];
	 }
       }
       return($vals);
     } else {
       $where = ($active)? " WHERE active = $active" : "";
       $query = "SELECT * FROM ".$this->table_types." $where ORDER BY priority DESC, name";
       return( $this->db_queryIndexed($query) );
     }            
   }
   
   function getProjectChildren( $pid, $columns = '', $archive_flag = 0 ) {
      // returns array of tickets for the project by its pid ($pid)
      // this is seperated from the get_tickets() for abstraction
      // (i.e. future expansion compatability)
      // the returned values of getProjectChildren() will always be
      // unsorted if using $columns (sorry!)
      
      $params = array("project_id"=>$pid);
      $sort = "status desc, priority, otime desc";
      $vars = $this->get_tickets($params, $sort, $columns, $archive_flag);
      return( $vars );
   }
   
   function getProjectHours( $pid, $archive_flag = 0 ) {
      $columns = array("id","est_hours","wkd_hours","type_id");
      $tickets = $this->getProjectChildren($pid,$columns,$archive_flag);
      for( $i=0; $i<count($tickets); $i++ ) {
    $t = $tickets[$i];
    if( $t["type_id"] == $this->projectTypeID() ) {
       list($eh,$wh) = $this->getProjectHours($t["id"],$archive_flag);
       $est_hours += $eh;
       $wkd_hours += $wh;
    } else {
       $est_hours += $t["est_hours"];
       $wdk_hours += $t["wkd_hours"];
    }
      }
      return( array($est_hours,$wkd_hours) );
   }   
   
   function getTicketSender( $id ) {
     $query = "SELECT user_id,bin_id FROM "
       .$this->table_logs
       ." WHERE ticket_id = $id"
       ." AND (action = 'MOVED' OR action = 'ASSIGNED' OR action = 'CREATED')"
       ." ORDER BY created DESC";
     $vars = $this->db_quickIndexed($query);      
     if( count($vars) ) {
       $this->addDebug("getTicketSender",join(",",$vars)."/".$query,3);
     } else {
       $this->addDebug("getTicketSender","couldn't find sender/".$query,2);
     }
     return $vars;
   }
   
   function projectTypeID() {
     // returns the type id associated with projects
     // this function prevents multiple calls for this
     // id by storing it the first time it is called
     // if $val is provided, returns true/false whether
     // $val is a project type id
     if( !strlen($this->projectTypeID) ) {
       $this->projectTypeID = -1;
       foreach( $this->types as $k=>$b ) {
	 if( preg_match("@project@i",$b) ) {
	   $this->projectTypeID = $k;
	   break;
	 }
       }
     }
     return $this->projectTypeID;
   }

   function projectTypeIDs() {
     // returns the type id associated with projects
     // this function prevents multiple calls for this
     // id by storing it the first time it is called
     // if $val is provided, returns true/false whether
     // $val is a project type id
     if( !is_array($this->projectTypeIDs) ) {
       $this->projectTypeIDs = array();
       foreach( $this->types as $k=>$b ) {
	 if( preg_match("@project@i",$b) ) {
	   $this->projectTypeIDs[] = $k;
	 }
       }
     }
     return $this->projectTypeIDs;
   }
   
   function inProjectTypeIDs($type_id) {
     // determines whether the id provided
     // is a valid project id
     // and returns true or false
     return( in_array($type_id,$this->projectTypeIDs()) );
   }

   function noteTypeID( ) {
     // returns the bin id associated with note
     // types for use with the auto-close function
     if( !strlen($this->noteTypeID) ) {
       foreach( $this->types as $k=>$b ) {
	 if( preg_match("@note@i",$b) ) {
	   $this->noteTypeID = $k;
	   break;
	 }
       }
     }
     return $this->noteTypeID;
   }
   
   /*
    *  INVOKE 
    */
   
   
   function zenTrack( $file, $user = '', $language = '' ) {
      // $file is the configuration file
      // containing all of the settings for
      // zenTrack to use during operation
      // $user is the logged in userid for this
      // user.  If given, then the user will be retrieved
      // and saved for use in other methods (to
      // prevent multiple queries)
      // if $language is given, it will override the value
      // from the configVars file
      
      include("$file");
      
      $this->zen();
      $this->DB( $this->database_host, $this->database_login, 
       $this->database_password, $this->database_instance);
      
      $this->bins        = $this->getBins();
      $this->systems     = $this->getSystems();
      //$this->strings     = $this->getStrings($this->language);
      $this->settings    = $this->getSettings();
      $this->settings["font_size_small"] = $this->settings["font_size"] - 2;
      $this->settings["font_size_large"] = $this->settings["font_size"] + 4;
      // this is a quick hack to fix an oops
      // should eventually go through code and fix this
      $this->settings["color_title_txt"] = $this->settings["color_title_text"];
      $this->types       = $this->getTypes();
      $this->priorities  = $this->getPriorities();
      $this->tasks       = $this->getTasks();

      $this->date_fmt_long  = $this->settings["date_fmt_long"];
      $this->date_fmt_short = $this->settings["date_fmt_short"];
      $this->time_fmt       = $this->settings["date_fmt_time"];
      $this->elapsed_unit   = $this->settings["time_elapsed_unit"];
      $this->date_and_time  = $this->date_fmt_short." ".$this->time_fmt;
      $this->language       = $this->settings["language_default"];

      if( $user ) {
   $this->user = $this->get_user($user_id);
   $this->access = $this->get_access($user_id);
      }
      if( $language )
   $this->language = $language;
   }
   
  
   /*
    *  REPORTING FUNCTIONS
   */     

   /**
    * retrieves a list of report templates, bin_id and user_id are
    * both optional, and can be arrays.
    */
   function getReportTemplates( $bin_id = '', $user_id = '' ) {
     $query = "SELECT DISTINCT i.report_id,r.report_name FROM "
       .$this->table_reports_index
       ." i,".$this->table_reports." r WHERE i.report_id = r.report_id AND ("
       ."(i.bid IS NULL OR i.bid = '') "
       ." OR (i.user_id IS NULL or i.user_id = '') ";
     if( $bin_id ) {
       $query .= (is_array($bin_id))? 
    " OR i.bid IN(".join(",",$bin_id).")" : " OR i.bid = $bin_id";
     }
     if( $user_id ) {
       $query .= (is_array($user_id))? 
    " OR i.user_id IN(".join(",",$user_id).")" : " OR i.user_id = $user_id";
     }
     $query .= ") ORDER BY r.report_name";
     $this->addDebug("getReportTemplates",$query,3);
     return $this->db_queryIndexed($query);
   }
   
   /**
    * saves a report format
    * from the temporary templates
    * to the permanent database
    * $bins is optional list of bins who can view report
    * $users is optional list of users who can view report
    */
   function saveReport( $name, $temp_id, $bins = '', $users = '' ) {
     // get the params
     $params = $this->getTempReport($temp_id);
     if( !is_array($params) || !count($params) )
       return false;
     // get rid of extra tempid info
     unset($params["created"]);
     unset($params["report_id"]);
     $params["report_name"] = $name;
     $res = $this->db_insert($this->table_reports,$params);
     // add indexes to bins
     $t = $this->table_reports_index;
     if( $res && is_array($bins) ) {
       foreach($bins as $v) {
    $this->db_result("INSERT INTO $t (report_id,bid) VALUES($res,$v)");
       }
     }
     // add indexes to users
     if( $res && is_array($users) ) {
       foreach($users as $v) {
    $this->db_result("INSERT INTO $t (report_id,user_id) VALUES($res,$v)");
       }       
     }
     // return results
     return $res;
   }
   
   /**
    * drops a report template from the permanent database
    */
   function deleteReport( $rid ) {
     $query = "DELETE FROM ".$this->table_reports." WHERE report_id = $rid";
     return $this->db_result($query);
   }

   /**
    * adds a report format to the
    * temporary database
    */
   function addTempReport( $params ) {
     $params["created"] = $this->dateSQL();
     $this->cleanTempReports($this->cleanTempReports);
     return $this->db_insert($this->table_reports_temp,$params);
   }
   
   /**
    * removes old temporary reports from 
    * the database
    */
   function cleanTempReports( $days ) {
     $date = $this->dateSQL(strtotime("-$days days"));
     $query = "DELETE FROM ".$this->table_reports_temp." WHERE created < '$date'";
     $this->addDebug("cleanTempReports",$query,3);
     return $this->db_result($query);
   }

   /**
    * retrieves all properties for a temporary
    * report by the id
    */
   function getTempReport( $rid ) {
     $query = "SELECT * FROM ".$this->table_reports_temp." WHERE report_id = $rid";
     return $this->db_quickIndexed($query);
   }

   /**
    * retrieves all properties for a permanent
    * report by the id
    */
   function getReportParams( $rid ) {
     $query = "SELECT * FROM ".$this->table_reports." WHERE report_id = $rid";
     return $this->db_quickIndexed($query);
   }

   function reportActivity($params) {
     // returns a set of data to be graphed on the report
     // will be a count of entries matching given criteria
     // $params is a complex array (see db.class->complexWhere)     
     // any field from ZENTRACK_LOGS table may be used in the params
     // clause.. if not given, matches all activity between start and end
     // you will need to provide a date range or it will probably be a massive and
     // hardly useful report
     list($tables,$where) = $this->reportLogQuery($params);
     $query = "SELECT count(*) FROM $tables $where ORDER BY created";
     $val = $this->db_get($query);
     if( !strlen($val) )
       $val = 0;
     $this->addDebug("reportActivity","result: $val/params:"
           .count($params)."/$query",3);
     return $val;
   }

   function reportTickets($params) {
     // returns a set of data to be graphed on a report
     // the return will be a count of tickets matching criteria
     // $params is a complex array (see db.class->complexWhere)   
     // any field from ZENTRACK_TICKETS may be used in $params
     // note that it is probably important to include some sort
     // of date range on either the otime or ctime or use 
     // ctime >= $start and otime <= $end... otherwise
     // this could be a massive report
     list($tables,$where) = $this->reportTicketQuery($params);
     $query = "SELECT count(*) FROM $tables $where";
     $val = $this->db_get($query);
     if( !strlen($val) )
       $val = 0;
     $this->addDebug("reportTickets","result: $val/params:"
           .count($params)."/$query",3);
     return $val;
   }

   function reportElapsed($params) {
     // returns a set of data to be graphed on a report
     // the return will be a sum of hours for the given criteria
     // $params is a complex array (see db.class->complexWhere)   
     // any field from ZENTRACK_TICKETS may be used in $params
     // you will need to provide a date range or it will probably 
     // be an unwieldy report
     $tte = 0;
     list($tables,$where) = $this->reportTicketQuery($params);
     $query = "SELECT otime,ctime FROM $tables $where";
     $vals = $this->db_queryIndexed($query);
     for($i=0; $i<count($vals); $i++) {
       $v = $vals[$i];
       if( $v["ctime"] < 1 ) {
          $v["ctime"] = $this->currTime;
       }
       $diff = $this->dateDiff($v["ctime"],$v["otime"],$this->elapsed_unit);
       $tte += $diff;
     }
     $this->addDebug("reportElapsed","result: $tte/params:".count($params)."/$query",3);
     return round($tte,1);
   }

   function reportHours($params) {
     // returns a set of data to be graphed on a report
     // the return will be a sum of hours for the given criteria
     // $params is a complex array (see db.class->complexWhere)   
     // any field from ZENTRACK_LOGS may be used in $params
     // you will probably need a date range, or it will be an
     // unwieldy report
     list($tables,$where) = $this->reportLogQuery($params);
     $query = "SELECT sum(hours) FROM $tables $where";
     $val = $this->db_get($query);
     if( !strlen($val) )
       $val = "0.00";
     $this->addDebug("reportHours","result: $val/params:"
           .count($params)."/$query",3);
     return $val;
   }

   function reportEstimated($params) {
     // returns a set of data to be graphed on a report
     // the return will be a sum of hours for the given criteria
     // $params is a complex array (see db.class->complexWhere)   
     // any field from ZENTRACK_TICKETS may be used in $params
     // you will probably need a date range, or it will be an
     // unwieldy report
     list($tables,$where) = $this->reportTicketQuery($params);
     $query = "SELECT sum(est_hours) FROM $tables $where";
     $val = $this->db_get($query);
     if( !strlen($val) )
       $val = "0.00";
     $this->addDebug("reportEstimated","result: $val/params:"
           .count($params)."/$query",3);
     return $val;
   }

   function reportLogQuery($params) {
     // internal use only!!
     // returns array(tables,where_clause) for
     // use by log table report functions
     $where = "WHERE ";
     $ttr = false;      // ticket table required
     $ticket_table_id = $this->get_table_id("ticket");
     $system_table_id = $this->get_table_id("system");
     $type_table_id = $this->get_table_id("type");
     $bin_table_id = $this->get_table_id("bin");
     if( $params["system_id"] ) {
       $ttr = true;
       $params["system_id"][0] = "t.system_id";
     }
     if( $params["type_id"] ) {
       $ttr = true;
       $params["type_id"][0] = "t.type_id";
     }
     $tables = $this->table_logs." l";
     if( $ttr ) {
       $where .= " t.id = l.ticket_id AND ";
       $tables .= ", ".$this->table_tickets." t";
     }
     $where .= $this->complexWhere($params,"AND");
     return array($tables,$where);
   }

   function reportTicketQuery($params) {
     // internal use only!!
     // returns array(tables,where_clause) for
     // use by ticket table report functions
     $where = "WHERE ";
     $tables = $this->table_tickets." l";
     $where .= $this->complexWhere($params,"AND");
     $where = preg_replace("@l\.ticket_id@","l.id",$where);
     return array($tables,$where);
   }

   
   /*
   **  VARIABLES TO CONFIGURE (in config file)
   */
   
   
   // usage vars
   var $user;
   var $access;
   var $ticket;
   var $id;
   var $date_format_long;
   var $date_format_short;
   
   // settings vars
   var $settings;
   
   var $bins;
   var $priorities;
   var $systems;
   var $tasks;
   var $types;
   var $noteTypeID;
   var $projectTypeID;
   
   var $language;
   var $strings;
   var $words;
   var $lastUsersBins;
   var $lastUsersID;
   
   
   // db vars   
   
   var $table_access;
   var $table_attachments;
   var $table_bins;
   var $table_logs;   
   var $table_logs_archived;
   var $table_preferences;
   var $table_priorities;
   var $table_reports;
   var $table_reports_index;
   var $table_reports_temp;
   var $table_settings;
   var $table_systems;
   var $table_tasks;
   var $table_tickets;
   var $table_tickets_archived;
   var $table_types;
   var $table_users;
   var $table_translation_strings;
   var $table_translation_words;

   var $cleanTempReports;
   var $reportImageWidth;
   var $reportImageHeight;

   var $database_type;
   var $database_instance;
   var $database_login;
   var $database_password;
   var $database_host;
                       
   // directory vars
   var $libDir;
   var $listDir;
   var $templateDir;
   var $attachmentsDir;
   
   // others

   var $elapsed_unit;
   var $projectTypeID; 
   var $projectTypeIDs;
   var $demo_mode;
}
 
?>
